
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfileImage
 * 
 */
export type UserProfileImage = $Result.DefaultSelection<Prisma.$UserProfileImagePayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseLike
 * 
 */
export type CourseLike = $Result.DefaultSelection<Prisma.$CourseLikePayload>
/**
 * Model UserCourseProgress
 * 
 */
export type UserCourseProgress = $Result.DefaultSelection<Prisma.$UserCourseProgressPayload>
/**
 * Model CourseModule
 * 
 */
export type CourseModule = $Result.DefaultSelection<Prisma.$CourseModulePayload>
/**
 * Model userModuleProgress
 * 
 */
export type userModuleProgress = $Result.DefaultSelection<Prisma.$userModuleProgressPayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model MiniModule
 * 
 */
export type MiniModule = $Result.DefaultSelection<Prisma.$MiniModulePayload>
/**
 * Model MiniModuleProgress
 * 
 */
export type MiniModuleProgress = $Result.DefaultSelection<Prisma.$MiniModuleProgressPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model LessonVideo
 * 
 */
export type LessonVideo = $Result.DefaultSelection<Prisma.$LessonVideoPayload>
/**
 * Model LessonSolution
 * 
 */
export type LessonSolution = $Result.DefaultSelection<Prisma.$LessonSolutionPayload>
/**
 * Model UserLessonProgress
 * 
 */
export type UserLessonProgress = $Result.DefaultSelection<Prisma.$UserLessonProgressPayload>
/**
 * Model CourseRating
 * 
 */
export type CourseRating = $Result.DefaultSelection<Prisma.$CourseRatingPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ChallengeLike
 * 
 */
export type ChallengeLike = $Result.DefaultSelection<Prisma.$ChallengeLikePayload>
/**
 * Model ChallengeInstructions
 * 
 */
export type ChallengeInstructions = $Result.DefaultSelection<Prisma.$ChallengeInstructionsPayload>
/**
 * Model ChallengeSolutions
 * 
 */
export type ChallengeSolutions = $Result.DefaultSelection<Prisma.$ChallengeSolutionsPayload>
/**
 * Model CompletedChallenges
 * 
 */
export type CompletedChallenges = $Result.DefaultSelection<Prisma.$CompletedChallengesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  SUPERADMIN: 'SUPERADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Level: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type Level = (typeof Level)[keyof typeof Level]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Level = $Enums.Level

export const Level: typeof $Enums.Level

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfileImage`: Exposes CRUD operations for the **UserProfileImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfileImages
    * const userProfileImages = await prisma.userProfileImage.findMany()
    * ```
    */
  get userProfileImage(): Prisma.UserProfileImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseLike`: Exposes CRUD operations for the **CourseLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseLikes
    * const courseLikes = await prisma.courseLike.findMany()
    * ```
    */
  get courseLike(): Prisma.CourseLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCourseProgress`: Exposes CRUD operations for the **UserCourseProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCourseProgresses
    * const userCourseProgresses = await prisma.userCourseProgress.findMany()
    * ```
    */
  get userCourseProgress(): Prisma.UserCourseProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseModule`: Exposes CRUD operations for the **CourseModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseModules
    * const courseModules = await prisma.courseModule.findMany()
    * ```
    */
  get courseModule(): Prisma.CourseModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userModuleProgress`: Exposes CRUD operations for the **userModuleProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserModuleProgresses
    * const userModuleProgresses = await prisma.userModuleProgress.findMany()
    * ```
    */
  get userModuleProgress(): Prisma.userModuleProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.miniModule`: Exposes CRUD operations for the **MiniModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MiniModules
    * const miniModules = await prisma.miniModule.findMany()
    * ```
    */
  get miniModule(): Prisma.MiniModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.miniModuleProgress`: Exposes CRUD operations for the **MiniModuleProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MiniModuleProgresses
    * const miniModuleProgresses = await prisma.miniModuleProgress.findMany()
    * ```
    */
  get miniModuleProgress(): Prisma.MiniModuleProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonVideo`: Exposes CRUD operations for the **LessonVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonVideos
    * const lessonVideos = await prisma.lessonVideo.findMany()
    * ```
    */
  get lessonVideo(): Prisma.LessonVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonSolution`: Exposes CRUD operations for the **LessonSolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonSolutions
    * const lessonSolutions = await prisma.lessonSolution.findMany()
    * ```
    */
  get lessonSolution(): Prisma.LessonSolutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLessonProgress`: Exposes CRUD operations for the **UserLessonProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLessonProgresses
    * const userLessonProgresses = await prisma.userLessonProgress.findMany()
    * ```
    */
  get userLessonProgress(): Prisma.UserLessonProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseRating`: Exposes CRUD operations for the **CourseRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseRatings
    * const courseRatings = await prisma.courseRating.findMany()
    * ```
    */
  get courseRating(): Prisma.CourseRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeLike`: Exposes CRUD operations for the **ChallengeLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeLikes
    * const challengeLikes = await prisma.challengeLike.findMany()
    * ```
    */
  get challengeLike(): Prisma.ChallengeLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeInstructions`: Exposes CRUD operations for the **ChallengeInstructions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeInstructions
    * const challengeInstructions = await prisma.challengeInstructions.findMany()
    * ```
    */
  get challengeInstructions(): Prisma.ChallengeInstructionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeSolutions`: Exposes CRUD operations for the **ChallengeSolutions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeSolutions
    * const challengeSolutions = await prisma.challengeSolutions.findMany()
    * ```
    */
  get challengeSolutions(): Prisma.ChallengeSolutionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.completedChallenges`: Exposes CRUD operations for the **CompletedChallenges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompletedChallenges
    * const completedChallenges = await prisma.completedChallenges.findMany()
    * ```
    */
  get completedChallenges(): Prisma.CompletedChallengesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserProfileImage: 'UserProfileImage',
    Course: 'Course',
    CourseLike: 'CourseLike',
    UserCourseProgress: 'UserCourseProgress',
    CourseModule: 'CourseModule',
    userModuleProgress: 'userModuleProgress',
    Video: 'Video',
    MiniModule: 'MiniModule',
    MiniModuleProgress: 'MiniModuleProgress',
    Lesson: 'Lesson',
    LessonVideo: 'LessonVideo',
    LessonSolution: 'LessonSolution',
    UserLessonProgress: 'UserLessonProgress',
    CourseRating: 'CourseRating',
    Challenge: 'Challenge',
    Message: 'Message',
    ChallengeLike: 'ChallengeLike',
    ChallengeInstructions: 'ChallengeInstructions',
    ChallengeSolutions: 'ChallengeSolutions',
    CompletedChallenges: 'CompletedChallenges'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userProfileImage" | "course" | "courseLike" | "userCourseProgress" | "courseModule" | "userModuleProgress" | "video" | "miniModule" | "miniModuleProgress" | "lesson" | "lessonVideo" | "lessonSolution" | "userLessonProgress" | "courseRating" | "challenge" | "message" | "challengeLike" | "challengeInstructions" | "challengeSolutions" | "completedChallenges"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfileImage: {
        payload: Prisma.$UserProfileImagePayload<ExtArgs>
        fields: Prisma.UserProfileImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>
          }
          findFirst: {
            args: Prisma.UserProfileImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>
          }
          findMany: {
            args: Prisma.UserProfileImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>[]
          }
          create: {
            args: Prisma.UserProfileImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>
          }
          createMany: {
            args: Prisma.UserProfileImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>[]
          }
          delete: {
            args: Prisma.UserProfileImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>
          }
          update: {
            args: Prisma.UserProfileImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfileImagePayload>
          }
          aggregate: {
            args: Prisma.UserProfileImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfileImage>
          }
          groupBy: {
            args: Prisma.UserProfileImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileImageCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileImageCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseLike: {
        payload: Prisma.$CourseLikePayload<ExtArgs>
        fields: Prisma.CourseLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>
          }
          findFirst: {
            args: Prisma.CourseLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>
          }
          findMany: {
            args: Prisma.CourseLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>[]
          }
          create: {
            args: Prisma.CourseLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>
          }
          createMany: {
            args: Prisma.CourseLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>[]
          }
          delete: {
            args: Prisma.CourseLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>
          }
          update: {
            args: Prisma.CourseLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>
          }
          deleteMany: {
            args: Prisma.CourseLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>[]
          }
          upsert: {
            args: Prisma.CourseLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLikePayload>
          }
          aggregate: {
            args: Prisma.CourseLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseLike>
          }
          groupBy: {
            args: Prisma.CourseLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseLikeCountArgs<ExtArgs>
            result: $Utils.Optional<CourseLikeCountAggregateOutputType> | number
          }
        }
      }
      UserCourseProgress: {
        payload: Prisma.$UserCourseProgressPayload<ExtArgs>
        fields: Prisma.UserCourseProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCourseProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCourseProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          findFirst: {
            args: Prisma.UserCourseProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCourseProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          findMany: {
            args: Prisma.UserCourseProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>[]
          }
          create: {
            args: Prisma.UserCourseProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          createMany: {
            args: Prisma.UserCourseProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCourseProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>[]
          }
          delete: {
            args: Prisma.UserCourseProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          update: {
            args: Prisma.UserCourseProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserCourseProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCourseProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCourseProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserCourseProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCourseProgressPayload>
          }
          aggregate: {
            args: Prisma.UserCourseProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCourseProgress>
          }
          groupBy: {
            args: Prisma.UserCourseProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCourseProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCourseProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserCourseProgressCountAggregateOutputType> | number
          }
        }
      }
      CourseModule: {
        payload: Prisma.$CourseModulePayload<ExtArgs>
        fields: Prisma.CourseModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findFirst: {
            args: Prisma.CourseModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          findMany: {
            args: Prisma.CourseModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          create: {
            args: Prisma.CourseModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          createMany: {
            args: Prisma.CourseModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          delete: {
            args: Prisma.CourseModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          update: {
            args: Prisma.CourseModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          deleteMany: {
            args: Prisma.CourseModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>[]
          }
          upsert: {
            args: Prisma.CourseModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseModulePayload>
          }
          aggregate: {
            args: Prisma.CourseModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseModule>
          }
          groupBy: {
            args: Prisma.CourseModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseModuleCountArgs<ExtArgs>
            result: $Utils.Optional<CourseModuleCountAggregateOutputType> | number
          }
        }
      }
      userModuleProgress: {
        payload: Prisma.$userModuleProgressPayload<ExtArgs>
        fields: Prisma.userModuleProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userModuleProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userModuleProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>
          }
          findFirst: {
            args: Prisma.userModuleProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userModuleProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>
          }
          findMany: {
            args: Prisma.userModuleProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>[]
          }
          create: {
            args: Prisma.userModuleProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>
          }
          createMany: {
            args: Prisma.userModuleProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userModuleProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>[]
          }
          delete: {
            args: Prisma.userModuleProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>
          }
          update: {
            args: Prisma.userModuleProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>
          }
          deleteMany: {
            args: Prisma.userModuleProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userModuleProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userModuleProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>[]
          }
          upsert: {
            args: Prisma.userModuleProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userModuleProgressPayload>
          }
          aggregate: {
            args: Prisma.UserModuleProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserModuleProgress>
          }
          groupBy: {
            args: Prisma.userModuleProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserModuleProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.userModuleProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserModuleProgressCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      MiniModule: {
        payload: Prisma.$MiniModulePayload<ExtArgs>
        fields: Prisma.MiniModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MiniModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MiniModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>
          }
          findFirst: {
            args: Prisma.MiniModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MiniModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>
          }
          findMany: {
            args: Prisma.MiniModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>[]
          }
          create: {
            args: Prisma.MiniModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>
          }
          createMany: {
            args: Prisma.MiniModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MiniModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>[]
          }
          delete: {
            args: Prisma.MiniModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>
          }
          update: {
            args: Prisma.MiniModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>
          }
          deleteMany: {
            args: Prisma.MiniModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MiniModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MiniModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>[]
          }
          upsert: {
            args: Prisma.MiniModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModulePayload>
          }
          aggregate: {
            args: Prisma.MiniModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMiniModule>
          }
          groupBy: {
            args: Prisma.MiniModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<MiniModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.MiniModuleCountArgs<ExtArgs>
            result: $Utils.Optional<MiniModuleCountAggregateOutputType> | number
          }
        }
      }
      MiniModuleProgress: {
        payload: Prisma.$MiniModuleProgressPayload<ExtArgs>
        fields: Prisma.MiniModuleProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MiniModuleProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MiniModuleProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>
          }
          findFirst: {
            args: Prisma.MiniModuleProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MiniModuleProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>
          }
          findMany: {
            args: Prisma.MiniModuleProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>[]
          }
          create: {
            args: Prisma.MiniModuleProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>
          }
          createMany: {
            args: Prisma.MiniModuleProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MiniModuleProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>[]
          }
          delete: {
            args: Prisma.MiniModuleProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>
          }
          update: {
            args: Prisma.MiniModuleProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>
          }
          deleteMany: {
            args: Prisma.MiniModuleProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MiniModuleProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MiniModuleProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>[]
          }
          upsert: {
            args: Prisma.MiniModuleProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiniModuleProgressPayload>
          }
          aggregate: {
            args: Prisma.MiniModuleProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMiniModuleProgress>
          }
          groupBy: {
            args: Prisma.MiniModuleProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<MiniModuleProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.MiniModuleProgressCountArgs<ExtArgs>
            result: $Utils.Optional<MiniModuleProgressCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      LessonVideo: {
        payload: Prisma.$LessonVideoPayload<ExtArgs>
        fields: Prisma.LessonVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>
          }
          findFirst: {
            args: Prisma.LessonVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>
          }
          findMany: {
            args: Prisma.LessonVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>[]
          }
          create: {
            args: Prisma.LessonVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>
          }
          createMany: {
            args: Prisma.LessonVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonVideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>[]
          }
          delete: {
            args: Prisma.LessonVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>
          }
          update: {
            args: Prisma.LessonVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>
          }
          deleteMany: {
            args: Prisma.LessonVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonVideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>[]
          }
          upsert: {
            args: Prisma.LessonVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonVideoPayload>
          }
          aggregate: {
            args: Prisma.LessonVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonVideo>
          }
          groupBy: {
            args: Prisma.LessonVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonVideoCountArgs<ExtArgs>
            result: $Utils.Optional<LessonVideoCountAggregateOutputType> | number
          }
        }
      }
      LessonSolution: {
        payload: Prisma.$LessonSolutionPayload<ExtArgs>
        fields: Prisma.LessonSolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonSolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonSolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>
          }
          findFirst: {
            args: Prisma.LessonSolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonSolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>
          }
          findMany: {
            args: Prisma.LessonSolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>[]
          }
          create: {
            args: Prisma.LessonSolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>
          }
          createMany: {
            args: Prisma.LessonSolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonSolutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>[]
          }
          delete: {
            args: Prisma.LessonSolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>
          }
          update: {
            args: Prisma.LessonSolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>
          }
          deleteMany: {
            args: Prisma.LessonSolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonSolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonSolutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>[]
          }
          upsert: {
            args: Prisma.LessonSolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonSolutionPayload>
          }
          aggregate: {
            args: Prisma.LessonSolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonSolution>
          }
          groupBy: {
            args: Prisma.LessonSolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonSolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonSolutionCountArgs<ExtArgs>
            result: $Utils.Optional<LessonSolutionCountAggregateOutputType> | number
          }
        }
      }
      UserLessonProgress: {
        payload: Prisma.$UserLessonProgressPayload<ExtArgs>
        fields: Prisma.UserLessonProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLessonProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLessonProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          findFirst: {
            args: Prisma.UserLessonProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLessonProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          findMany: {
            args: Prisma.UserLessonProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>[]
          }
          create: {
            args: Prisma.UserLessonProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          createMany: {
            args: Prisma.UserLessonProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLessonProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>[]
          }
          delete: {
            args: Prisma.UserLessonProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          update: {
            args: Prisma.UserLessonProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserLessonProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLessonProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLessonProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserLessonProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLessonProgressPayload>
          }
          aggregate: {
            args: Prisma.UserLessonProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLessonProgress>
          }
          groupBy: {
            args: Prisma.UserLessonProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLessonProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLessonProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserLessonProgressCountAggregateOutputType> | number
          }
        }
      }
      CourseRating: {
        payload: Prisma.$CourseRatingPayload<ExtArgs>
        fields: Prisma.CourseRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>
          }
          findFirst: {
            args: Prisma.CourseRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>
          }
          findMany: {
            args: Prisma.CourseRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>[]
          }
          create: {
            args: Prisma.CourseRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>
          }
          createMany: {
            args: Prisma.CourseRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>[]
          }
          delete: {
            args: Prisma.CourseRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>
          }
          update: {
            args: Prisma.CourseRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>
          }
          deleteMany: {
            args: Prisma.CourseRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>[]
          }
          upsert: {
            args: Prisma.CourseRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseRatingPayload>
          }
          aggregate: {
            args: Prisma.CourseRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseRating>
          }
          groupBy: {
            args: Prisma.CourseRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseRatingCountArgs<ExtArgs>
            result: $Utils.Optional<CourseRatingCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ChallengeLike: {
        payload: Prisma.$ChallengeLikePayload<ExtArgs>
        fields: Prisma.ChallengeLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>
          }
          findFirst: {
            args: Prisma.ChallengeLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>
          }
          findMany: {
            args: Prisma.ChallengeLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>[]
          }
          create: {
            args: Prisma.ChallengeLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>
          }
          createMany: {
            args: Prisma.ChallengeLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>[]
          }
          delete: {
            args: Prisma.ChallengeLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>
          }
          update: {
            args: Prisma.ChallengeLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeLikePayload>
          }
          aggregate: {
            args: Prisma.ChallengeLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeLike>
          }
          groupBy: {
            args: Prisma.ChallengeLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeLikeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeLikeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeInstructions: {
        payload: Prisma.$ChallengeInstructionsPayload<ExtArgs>
        fields: Prisma.ChallengeInstructionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeInstructionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeInstructionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>
          }
          findFirst: {
            args: Prisma.ChallengeInstructionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeInstructionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>
          }
          findMany: {
            args: Prisma.ChallengeInstructionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>[]
          }
          create: {
            args: Prisma.ChallengeInstructionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>
          }
          createMany: {
            args: Prisma.ChallengeInstructionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeInstructionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>[]
          }
          delete: {
            args: Prisma.ChallengeInstructionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>
          }
          update: {
            args: Prisma.ChallengeInstructionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeInstructionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeInstructionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeInstructionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeInstructionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstructionsPayload>
          }
          aggregate: {
            args: Prisma.ChallengeInstructionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeInstructions>
          }
          groupBy: {
            args: Prisma.ChallengeInstructionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeInstructionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeInstructionsCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeInstructionsCountAggregateOutputType> | number
          }
        }
      }
      ChallengeSolutions: {
        payload: Prisma.$ChallengeSolutionsPayload<ExtArgs>
        fields: Prisma.ChallengeSolutionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeSolutionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeSolutionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>
          }
          findFirst: {
            args: Prisma.ChallengeSolutionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeSolutionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>
          }
          findMany: {
            args: Prisma.ChallengeSolutionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>[]
          }
          create: {
            args: Prisma.ChallengeSolutionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>
          }
          createMany: {
            args: Prisma.ChallengeSolutionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeSolutionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>[]
          }
          delete: {
            args: Prisma.ChallengeSolutionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>
          }
          update: {
            args: Prisma.ChallengeSolutionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeSolutionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeSolutionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeSolutionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeSolutionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeSolutionsPayload>
          }
          aggregate: {
            args: Prisma.ChallengeSolutionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeSolutions>
          }
          groupBy: {
            args: Prisma.ChallengeSolutionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeSolutionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeSolutionsCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeSolutionsCountAggregateOutputType> | number
          }
        }
      }
      CompletedChallenges: {
        payload: Prisma.$CompletedChallengesPayload<ExtArgs>
        fields: Prisma.CompletedChallengesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompletedChallengesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompletedChallengesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>
          }
          findFirst: {
            args: Prisma.CompletedChallengesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompletedChallengesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>
          }
          findMany: {
            args: Prisma.CompletedChallengesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>[]
          }
          create: {
            args: Prisma.CompletedChallengesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>
          }
          createMany: {
            args: Prisma.CompletedChallengesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompletedChallengesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>[]
          }
          delete: {
            args: Prisma.CompletedChallengesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>
          }
          update: {
            args: Prisma.CompletedChallengesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>
          }
          deleteMany: {
            args: Prisma.CompletedChallengesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompletedChallengesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompletedChallengesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>[]
          }
          upsert: {
            args: Prisma.CompletedChallengesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedChallengesPayload>
          }
          aggregate: {
            args: Prisma.CompletedChallengesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompletedChallenges>
          }
          groupBy: {
            args: Prisma.CompletedChallengesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompletedChallengesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompletedChallengesCountArgs<ExtArgs>
            result: $Utils.Optional<CompletedChallengesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userProfileImage?: UserProfileImageOmit
    course?: CourseOmit
    courseLike?: CourseLikeOmit
    userCourseProgress?: UserCourseProgressOmit
    courseModule?: CourseModuleOmit
    userModuleProgress?: userModuleProgressOmit
    video?: VideoOmit
    miniModule?: MiniModuleOmit
    miniModuleProgress?: MiniModuleProgressOmit
    lesson?: LessonOmit
    lessonVideo?: LessonVideoOmit
    lessonSolution?: LessonSolutionOmit
    userLessonProgress?: UserLessonProgressOmit
    courseRating?: CourseRatingOmit
    challenge?: ChallengeOmit
    message?: MessageOmit
    challengeLike?: ChallengeLikeOmit
    challengeInstructions?: ChallengeInstructionsOmit
    challengeSolutions?: ChallengeSolutionsOmit
    completedChallenges?: CompletedChallengesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ratings: number
    ChallengeLike: number
    image: number
    createdCourses: number
    progress: number
    userModuleProgress: number
    MiniModuleProgress: number
    userLessonProgress: number
    courseLikes: number
    CompletedChallenges: number
    sentMessages: number
    receivedMessages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ratings?: boolean | UserCountOutputTypeCountRatingsArgs
    ChallengeLike?: boolean | UserCountOutputTypeCountChallengeLikeArgs
    image?: boolean | UserCountOutputTypeCountImageArgs
    createdCourses?: boolean | UserCountOutputTypeCountCreatedCoursesArgs
    progress?: boolean | UserCountOutputTypeCountProgressArgs
    userModuleProgress?: boolean | UserCountOutputTypeCountUserModuleProgressArgs
    MiniModuleProgress?: boolean | UserCountOutputTypeCountMiniModuleProgressArgs
    userLessonProgress?: boolean | UserCountOutputTypeCountUserLessonProgressArgs
    courseLikes?: boolean | UserCountOutputTypeCountCourseLikesArgs
    CompletedChallenges?: boolean | UserCountOutputTypeCountCompletedChallengesArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengeLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileImageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserModuleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userModuleProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMiniModuleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MiniModuleProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompletedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedChallengesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    modules: number
    progress: number
    ratings: number
    videos: number
    users: number
    likedBy: number
    completedChallenges: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
    progress?: boolean | CourseCountOutputTypeCountProgressArgs
    ratings?: boolean | CourseCountOutputTypeCountRatingsArgs
    videos?: boolean | CourseCountOutputTypeCountVideosArgs
    users?: boolean | CourseCountOutputTypeCountUsersArgs
    likedBy?: boolean | CourseCountOutputTypeCountLikedByArgs
    completedChallenges?: boolean | CourseCountOutputTypeCountCompletedChallengesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseProgressWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseRatingWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLikedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLikeWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCompletedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedChallengesWhereInput
  }


  /**
   * Count Type CourseModuleCountOutputType
   */

  export type CourseModuleCountOutputType = {
    miniModules: number
    progress: number
  }

  export type CourseModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniModules?: boolean | CourseModuleCountOutputTypeCountMiniModulesArgs
    progress?: boolean | CourseModuleCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModuleCountOutputType
     */
    select?: CourseModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountMiniModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MiniModuleWhereInput
  }

  /**
   * CourseModuleCountOutputType without action
   */
  export type CourseModuleCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userModuleProgressWhereInput
  }


  /**
   * Count Type MiniModuleCountOutputType
   */

  export type MiniModuleCountOutputType = {
    lessons: number
    lessonVideos: number
    progress: number
  }

  export type MiniModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | MiniModuleCountOutputTypeCountLessonsArgs
    lessonVideos?: boolean | MiniModuleCountOutputTypeCountLessonVideosArgs
    progress?: boolean | MiniModuleCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * MiniModuleCountOutputType without action
   */
  export type MiniModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleCountOutputType
     */
    select?: MiniModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MiniModuleCountOutputType without action
   */
  export type MiniModuleCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * MiniModuleCountOutputType without action
   */
  export type MiniModuleCountOutputTypeCountLessonVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonVideoWhereInput
  }

  /**
   * MiniModuleCountOutputType without action
   */
  export type MiniModuleCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MiniModuleProgressWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    solutions: number
    progress: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solutions?: boolean | LessonCountOutputTypeCountSolutionsArgs
    progress?: boolean | LessonCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonSolutionWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonProgressWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    instructions: number
    likesList: number
    solutions: number
    completions: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructions?: boolean | ChallengeCountOutputTypeCountInstructionsArgs
    likesList?: boolean | ChallengeCountOutputTypeCountLikesListArgs
    solutions?: boolean | ChallengeCountOutputTypeCountSolutionsArgs
    completions?: boolean | ChallengeCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountInstructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstructionsWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountLikesListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeLikeWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeSolutionsWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedChallengesWhereInput
  }


  /**
   * Count Type CompletedChallengesCountOutputType
   */

  export type CompletedChallengesCountOutputType = {
    Course: number
  }

  export type CompletedChallengesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | CompletedChallengesCountOutputTypeCountCourseArgs
  }

  // Custom InputTypes
  /**
   * CompletedChallengesCountOutputType without action
   */
  export type CompletedChallengesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallengesCountOutputType
     */
    select?: CompletedChallengesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompletedChallengesCountOutputType without action
   */
  export type CompletedChallengesCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    hash: string | null
    username: string | null
    role: $Enums.Role | null
    isPremium: boolean | null
    provider: string | null
    photo: string | null
    courseId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    hash: string | null
    username: string | null
    role: $Enums.Role | null
    isPremium: boolean | null
    provider: string | null
    photo: string | null
    courseId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    hash: number
    username: number
    role: number
    isPremium: number
    provider: number
    photo: number
    courseId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    hash?: true
    username?: true
    role?: true
    isPremium?: true
    provider?: true
    photo?: true
    courseId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    hash?: true
    username?: true
    role?: true
    isPremium?: true
    provider?: true
    photo?: true
    courseId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    hash?: true
    username?: true
    role?: true
    isPremium?: true
    provider?: true
    photo?: true
    courseId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    email: string
    hash: string
    username: string | null
    role: $Enums.Role
    isPremium: boolean
    provider: string
    photo: string | null
    courseId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    hash?: boolean
    username?: boolean
    role?: boolean
    isPremium?: boolean
    provider?: boolean
    photo?: boolean
    courseId?: boolean
    course?: boolean | User$courseArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    ChallengeLike?: boolean | User$ChallengeLikeArgs<ExtArgs>
    image?: boolean | User$imageArgs<ExtArgs>
    createdCourses?: boolean | User$createdCoursesArgs<ExtArgs>
    progress?: boolean | User$progressArgs<ExtArgs>
    userModuleProgress?: boolean | User$userModuleProgressArgs<ExtArgs>
    MiniModuleProgress?: boolean | User$MiniModuleProgressArgs<ExtArgs>
    userLessonProgress?: boolean | User$userLessonProgressArgs<ExtArgs>
    courseLikes?: boolean | User$courseLikesArgs<ExtArgs>
    CompletedChallenges?: boolean | User$CompletedChallengesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    hash?: boolean
    username?: boolean
    role?: boolean
    isPremium?: boolean
    provider?: boolean
    photo?: boolean
    courseId?: boolean
    course?: boolean | User$courseArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    hash?: boolean
    username?: boolean
    role?: boolean
    isPremium?: boolean
    provider?: boolean
    photo?: boolean
    courseId?: boolean
    course?: boolean | User$courseArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    hash?: boolean
    username?: boolean
    role?: boolean
    isPremium?: boolean
    provider?: boolean
    photo?: boolean
    courseId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "email" | "hash" | "username" | "role" | "isPremium" | "provider" | "photo" | "courseId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | User$courseArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    ChallengeLike?: boolean | User$ChallengeLikeArgs<ExtArgs>
    image?: boolean | User$imageArgs<ExtArgs>
    createdCourses?: boolean | User$createdCoursesArgs<ExtArgs>
    progress?: boolean | User$progressArgs<ExtArgs>
    userModuleProgress?: boolean | User$userModuleProgressArgs<ExtArgs>
    MiniModuleProgress?: boolean | User$MiniModuleProgressArgs<ExtArgs>
    userLessonProgress?: boolean | User$userLessonProgressArgs<ExtArgs>
    courseLikes?: boolean | User$courseLikesArgs<ExtArgs>
    CompletedChallenges?: boolean | User$CompletedChallengesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | User$courseArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | User$courseArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      ratings: Prisma.$CourseRatingPayload<ExtArgs>[]
      ChallengeLike: Prisma.$ChallengeLikePayload<ExtArgs>[]
      image: Prisma.$UserProfileImagePayload<ExtArgs>[]
      createdCourses: Prisma.$CoursePayload<ExtArgs>[]
      progress: Prisma.$UserCourseProgressPayload<ExtArgs>[]
      userModuleProgress: Prisma.$userModuleProgressPayload<ExtArgs>[]
      MiniModuleProgress: Prisma.$MiniModuleProgressPayload<ExtArgs>[]
      userLessonProgress: Prisma.$UserLessonProgressPayload<ExtArgs>[]
      courseLikes: Prisma.$CourseLikePayload<ExtArgs>[]
      CompletedChallenges: Prisma.$CompletedChallengesPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      email: string
      hash: string
      username: string | null
      role: $Enums.Role
      isPremium: boolean
      provider: string
      photo: string | null
      courseId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends User$courseArgs<ExtArgs> = {}>(args?: Subset<T, User$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ratings<T extends User$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, User$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ChallengeLike<T extends User$ChallengeLikeArgs<ExtArgs> = {}>(args?: Subset<T, User$ChallengeLikeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    image<T extends User$imageArgs<ExtArgs> = {}>(args?: Subset<T, User$imageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCourses<T extends User$createdCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends User$progressArgs<ExtArgs> = {}>(args?: Subset<T, User$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userModuleProgress<T extends User$userModuleProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$userModuleProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MiniModuleProgress<T extends User$MiniModuleProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$MiniModuleProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userLessonProgress<T extends User$userLessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$userLessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courseLikes<T extends User$courseLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$courseLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CompletedChallenges<T extends User$CompletedChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$CompletedChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly hash: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isPremium: FieldRef<"User", 'Boolean'>
    readonly provider: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly courseId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.course
   */
  export type User$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * User.ratings
   */
  export type User$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    where?: CourseRatingWhereInput
    orderBy?: CourseRatingOrderByWithRelationInput | CourseRatingOrderByWithRelationInput[]
    cursor?: CourseRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseRatingScalarFieldEnum | CourseRatingScalarFieldEnum[]
  }

  /**
   * User.ChallengeLike
   */
  export type User$ChallengeLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    where?: ChallengeLikeWhereInput
    orderBy?: ChallengeLikeOrderByWithRelationInput | ChallengeLikeOrderByWithRelationInput[]
    cursor?: ChallengeLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeLikeScalarFieldEnum | ChallengeLikeScalarFieldEnum[]
  }

  /**
   * User.image
   */
  export type User$imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    where?: UserProfileImageWhereInput
    orderBy?: UserProfileImageOrderByWithRelationInput | UserProfileImageOrderByWithRelationInput[]
    cursor?: UserProfileImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileImageScalarFieldEnum | UserProfileImageScalarFieldEnum[]
  }

  /**
   * User.createdCourses
   */
  export type User$createdCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.progress
   */
  export type User$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    where?: UserCourseProgressWhereInput
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    cursor?: UserCourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * User.userModuleProgress
   */
  export type User$userModuleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    where?: userModuleProgressWhereInput
    orderBy?: userModuleProgressOrderByWithRelationInput | userModuleProgressOrderByWithRelationInput[]
    cursor?: userModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserModuleProgressScalarFieldEnum | UserModuleProgressScalarFieldEnum[]
  }

  /**
   * User.MiniModuleProgress
   */
  export type User$MiniModuleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    where?: MiniModuleProgressWhereInput
    orderBy?: MiniModuleProgressOrderByWithRelationInput | MiniModuleProgressOrderByWithRelationInput[]
    cursor?: MiniModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MiniModuleProgressScalarFieldEnum | MiniModuleProgressScalarFieldEnum[]
  }

  /**
   * User.userLessonProgress
   */
  export type User$userLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    where?: UserLessonProgressWhereInput
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    cursor?: UserLessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * User.courseLikes
   */
  export type User$courseLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    where?: CourseLikeWhereInput
    orderBy?: CourseLikeOrderByWithRelationInput | CourseLikeOrderByWithRelationInput[]
    cursor?: CourseLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLikeScalarFieldEnum | CourseLikeScalarFieldEnum[]
  }

  /**
   * User.CompletedChallenges
   */
  export type User$CompletedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    where?: CompletedChallengesWhereInput
    orderBy?: CompletedChallengesOrderByWithRelationInput | CompletedChallengesOrderByWithRelationInput[]
    cursor?: CompletedChallengesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompletedChallengesScalarFieldEnum | CompletedChallengesScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfileImage
   */

  export type AggregateUserProfileImage = {
    _count: UserProfileImageCountAggregateOutputType | null
    _avg: UserProfileImageAvgAggregateOutputType | null
    _sum: UserProfileImageSumAggregateOutputType | null
    _min: UserProfileImageMinAggregateOutputType | null
    _max: UserProfileImageMaxAggregateOutputType | null
  }

  export type UserProfileImageAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileImageSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserProfileImageMinAggregateOutputType = {
    id: number | null
    path: string | null
    userId: number | null
  }

  export type UserProfileImageMaxAggregateOutputType = {
    id: number | null
    path: string | null
    userId: number | null
  }

  export type UserProfileImageCountAggregateOutputType = {
    id: number
    path: number
    userId: number
    _all: number
  }


  export type UserProfileImageAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileImageSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserProfileImageMinAggregateInputType = {
    id?: true
    path?: true
    userId?: true
  }

  export type UserProfileImageMaxAggregateInputType = {
    id?: true
    path?: true
    userId?: true
  }

  export type UserProfileImageCountAggregateInputType = {
    id?: true
    path?: true
    userId?: true
    _all?: true
  }

  export type UserProfileImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfileImage to aggregate.
     */
    where?: UserProfileImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileImages to fetch.
     */
    orderBy?: UserProfileImageOrderByWithRelationInput | UserProfileImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfileImages
    **/
    _count?: true | UserProfileImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileImageMaxAggregateInputType
  }

  export type GetUserProfileImageAggregateType<T extends UserProfileImageAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfileImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfileImage[P]>
      : GetScalarType<T[P], AggregateUserProfileImage[P]>
  }




  export type UserProfileImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileImageWhereInput
    orderBy?: UserProfileImageOrderByWithAggregationInput | UserProfileImageOrderByWithAggregationInput[]
    by: UserProfileImageScalarFieldEnum[] | UserProfileImageScalarFieldEnum
    having?: UserProfileImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileImageCountAggregateInputType | true
    _avg?: UserProfileImageAvgAggregateInputType
    _sum?: UserProfileImageSumAggregateInputType
    _min?: UserProfileImageMinAggregateInputType
    _max?: UserProfileImageMaxAggregateInputType
  }

  export type UserProfileImageGroupByOutputType = {
    id: number
    path: string
    userId: number
    _count: UserProfileImageCountAggregateOutputType | null
    _avg: UserProfileImageAvgAggregateOutputType | null
    _sum: UserProfileImageSumAggregateOutputType | null
    _min: UserProfileImageMinAggregateOutputType | null
    _max: UserProfileImageMaxAggregateOutputType | null
  }

  type GetUserProfileImageGroupByPayload<T extends UserProfileImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileImageGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileImageGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfileImage"]>

  export type UserProfileImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfileImage"]>

  export type UserProfileImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    path?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfileImage"]>

  export type UserProfileImageSelectScalar = {
    id?: boolean
    path?: boolean
    userId?: boolean
  }

  export type UserProfileImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "path" | "userId", ExtArgs["result"]["userProfileImage"]>
  export type UserProfileImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfileImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfileImage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      path: string
      userId: number
    }, ExtArgs["result"]["userProfileImage"]>
    composites: {}
  }

  type UserProfileImageGetPayload<S extends boolean | null | undefined | UserProfileImageDefaultArgs> = $Result.GetResult<Prisma.$UserProfileImagePayload, S>

  type UserProfileImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileImageCountAggregateInputType | true
    }

  export interface UserProfileImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfileImage'], meta: { name: 'UserProfileImage' } }
    /**
     * Find zero or one UserProfileImage that matches the filter.
     * @param {UserProfileImageFindUniqueArgs} args - Arguments to find a UserProfileImage
     * @example
     * // Get one UserProfileImage
     * const userProfileImage = await prisma.userProfileImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileImageFindUniqueArgs>(args: SelectSubset<T, UserProfileImageFindUniqueArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfileImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileImageFindUniqueOrThrowArgs} args - Arguments to find a UserProfileImage
     * @example
     * // Get one UserProfileImage
     * const userProfileImage = await prisma.userProfileImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileImageFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfileImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileImageFindFirstArgs} args - Arguments to find a UserProfileImage
     * @example
     * // Get one UserProfileImage
     * const userProfileImage = await prisma.userProfileImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileImageFindFirstArgs>(args?: SelectSubset<T, UserProfileImageFindFirstArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfileImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileImageFindFirstOrThrowArgs} args - Arguments to find a UserProfileImage
     * @example
     * // Get one UserProfileImage
     * const userProfileImage = await prisma.userProfileImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileImageFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfileImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfileImages
     * const userProfileImages = await prisma.userProfileImage.findMany()
     * 
     * // Get first 10 UserProfileImages
     * const userProfileImages = await prisma.userProfileImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileImageWithIdOnly = await prisma.userProfileImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileImageFindManyArgs>(args?: SelectSubset<T, UserProfileImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfileImage.
     * @param {UserProfileImageCreateArgs} args - Arguments to create a UserProfileImage.
     * @example
     * // Create one UserProfileImage
     * const UserProfileImage = await prisma.userProfileImage.create({
     *   data: {
     *     // ... data to create a UserProfileImage
     *   }
     * })
     * 
     */
    create<T extends UserProfileImageCreateArgs>(args: SelectSubset<T, UserProfileImageCreateArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfileImages.
     * @param {UserProfileImageCreateManyArgs} args - Arguments to create many UserProfileImages.
     * @example
     * // Create many UserProfileImages
     * const userProfileImage = await prisma.userProfileImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileImageCreateManyArgs>(args?: SelectSubset<T, UserProfileImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfileImages and returns the data saved in the database.
     * @param {UserProfileImageCreateManyAndReturnArgs} args - Arguments to create many UserProfileImages.
     * @example
     * // Create many UserProfileImages
     * const userProfileImage = await prisma.userProfileImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfileImages and only return the `id`
     * const userProfileImageWithIdOnly = await prisma.userProfileImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileImageCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfileImage.
     * @param {UserProfileImageDeleteArgs} args - Arguments to delete one UserProfileImage.
     * @example
     * // Delete one UserProfileImage
     * const UserProfileImage = await prisma.userProfileImage.delete({
     *   where: {
     *     // ... filter to delete one UserProfileImage
     *   }
     * })
     * 
     */
    delete<T extends UserProfileImageDeleteArgs>(args: SelectSubset<T, UserProfileImageDeleteArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfileImage.
     * @param {UserProfileImageUpdateArgs} args - Arguments to update one UserProfileImage.
     * @example
     * // Update one UserProfileImage
     * const userProfileImage = await prisma.userProfileImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileImageUpdateArgs>(args: SelectSubset<T, UserProfileImageUpdateArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfileImages.
     * @param {UserProfileImageDeleteManyArgs} args - Arguments to filter UserProfileImages to delete.
     * @example
     * // Delete a few UserProfileImages
     * const { count } = await prisma.userProfileImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileImageDeleteManyArgs>(args?: SelectSubset<T, UserProfileImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfileImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfileImages
     * const userProfileImage = await prisma.userProfileImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileImageUpdateManyArgs>(args: SelectSubset<T, UserProfileImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfileImages and returns the data updated in the database.
     * @param {UserProfileImageUpdateManyAndReturnArgs} args - Arguments to update many UserProfileImages.
     * @example
     * // Update many UserProfileImages
     * const userProfileImage = await prisma.userProfileImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfileImages and only return the `id`
     * const userProfileImageWithIdOnly = await prisma.userProfileImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileImageUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfileImage.
     * @param {UserProfileImageUpsertArgs} args - Arguments to update or create a UserProfileImage.
     * @example
     * // Update or create a UserProfileImage
     * const userProfileImage = await prisma.userProfileImage.upsert({
     *   create: {
     *     // ... data to create a UserProfileImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfileImage we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileImageUpsertArgs>(args: SelectSubset<T, UserProfileImageUpsertArgs<ExtArgs>>): Prisma__UserProfileImageClient<$Result.GetResult<Prisma.$UserProfileImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfileImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileImageCountArgs} args - Arguments to filter UserProfileImages to count.
     * @example
     * // Count the number of UserProfileImages
     * const count = await prisma.userProfileImage.count({
     *   where: {
     *     // ... the filter for the UserProfileImages we want to count
     *   }
     * })
    **/
    count<T extends UserProfileImageCountArgs>(
      args?: Subset<T, UserProfileImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfileImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileImageAggregateArgs>(args: Subset<T, UserProfileImageAggregateArgs>): Prisma.PrismaPromise<GetUserProfileImageAggregateType<T>>

    /**
     * Group by UserProfileImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileImageGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfileImage model
   */
  readonly fields: UserProfileImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfileImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfileImage model
   */
  interface UserProfileImageFieldRefs {
    readonly id: FieldRef<"UserProfileImage", 'Int'>
    readonly path: FieldRef<"UserProfileImage", 'String'>
    readonly userId: FieldRef<"UserProfileImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserProfileImage findUnique
   */
  export type UserProfileImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * Filter, which UserProfileImage to fetch.
     */
    where: UserProfileImageWhereUniqueInput
  }

  /**
   * UserProfileImage findUniqueOrThrow
   */
  export type UserProfileImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * Filter, which UserProfileImage to fetch.
     */
    where: UserProfileImageWhereUniqueInput
  }

  /**
   * UserProfileImage findFirst
   */
  export type UserProfileImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * Filter, which UserProfileImage to fetch.
     */
    where?: UserProfileImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileImages to fetch.
     */
    orderBy?: UserProfileImageOrderByWithRelationInput | UserProfileImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfileImages.
     */
    cursor?: UserProfileImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfileImages.
     */
    distinct?: UserProfileImageScalarFieldEnum | UserProfileImageScalarFieldEnum[]
  }

  /**
   * UserProfileImage findFirstOrThrow
   */
  export type UserProfileImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * Filter, which UserProfileImage to fetch.
     */
    where?: UserProfileImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileImages to fetch.
     */
    orderBy?: UserProfileImageOrderByWithRelationInput | UserProfileImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfileImages.
     */
    cursor?: UserProfileImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfileImages.
     */
    distinct?: UserProfileImageScalarFieldEnum | UserProfileImageScalarFieldEnum[]
  }

  /**
   * UserProfileImage findMany
   */
  export type UserProfileImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * Filter, which UserProfileImages to fetch.
     */
    where?: UserProfileImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileImages to fetch.
     */
    orderBy?: UserProfileImageOrderByWithRelationInput | UserProfileImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfileImages.
     */
    cursor?: UserProfileImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileImages.
     */
    skip?: number
    distinct?: UserProfileImageScalarFieldEnum | UserProfileImageScalarFieldEnum[]
  }

  /**
   * UserProfileImage create
   */
  export type UserProfileImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfileImage.
     */
    data: XOR<UserProfileImageCreateInput, UserProfileImageUncheckedCreateInput>
  }

  /**
   * UserProfileImage createMany
   */
  export type UserProfileImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfileImages.
     */
    data: UserProfileImageCreateManyInput | UserProfileImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfileImage createManyAndReturn
   */
  export type UserProfileImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfileImages.
     */
    data: UserProfileImageCreateManyInput | UserProfileImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfileImage update
   */
  export type UserProfileImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfileImage.
     */
    data: XOR<UserProfileImageUpdateInput, UserProfileImageUncheckedUpdateInput>
    /**
     * Choose, which UserProfileImage to update.
     */
    where: UserProfileImageWhereUniqueInput
  }

  /**
   * UserProfileImage updateMany
   */
  export type UserProfileImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfileImages.
     */
    data: XOR<UserProfileImageUpdateManyMutationInput, UserProfileImageUncheckedUpdateManyInput>
    /**
     * Filter which UserProfileImages to update
     */
    where?: UserProfileImageWhereInput
    /**
     * Limit how many UserProfileImages to update.
     */
    limit?: number
  }

  /**
   * UserProfileImage updateManyAndReturn
   */
  export type UserProfileImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * The data used to update UserProfileImages.
     */
    data: XOR<UserProfileImageUpdateManyMutationInput, UserProfileImageUncheckedUpdateManyInput>
    /**
     * Filter which UserProfileImages to update
     */
    where?: UserProfileImageWhereInput
    /**
     * Limit how many UserProfileImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfileImage upsert
   */
  export type UserProfileImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfileImage to update in case it exists.
     */
    where: UserProfileImageWhereUniqueInput
    /**
     * In case the UserProfileImage found by the `where` argument doesn't exist, create a new UserProfileImage with this data.
     */
    create: XOR<UserProfileImageCreateInput, UserProfileImageUncheckedCreateInput>
    /**
     * In case the UserProfileImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileImageUpdateInput, UserProfileImageUncheckedUpdateInput>
  }

  /**
   * UserProfileImage delete
   */
  export type UserProfileImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
    /**
     * Filter which UserProfileImage to delete.
     */
    where: UserProfileImageWhereUniqueInput
  }

  /**
   * UserProfileImage deleteMany
   */
  export type UserProfileImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfileImages to delete
     */
    where?: UserProfileImageWhereInput
    /**
     * Limit how many UserProfileImages to delete.
     */
    limit?: number
  }

  /**
   * UserProfileImage without action
   */
  export type UserProfileImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileImage
     */
    select?: UserProfileImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfileImage
     */
    omit?: UserProfileImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileImageInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
    studentsCount: number | null
    rating: number | null
    likes: number | null
    completions: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    creatorId: number | null
    studentsCount: number | null
    rating: number | null
    likes: number | null
    completions: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    creatorId: number | null
    title: string | null
    category: string | null
    level: $Enums.Level | null
    description: string | null
    duration: string | null
    studentsCount: number | null
    rating: number | null
    likes: number | null
    completions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    creatorId: number | null
    title: string | null
    category: string | null
    level: $Enums.Level | null
    description: string | null
    duration: string | null
    studentsCount: number | null
    rating: number | null
    likes: number | null
    completions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    creatorId: number
    title: number
    category: number
    level: number
    description: number
    duration: number
    studentsCount: number
    rating: number
    likes: number
    completions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    creatorId?: true
    studentsCount?: true
    rating?: true
    likes?: true
    completions?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    creatorId?: true
    studentsCount?: true
    rating?: true
    likes?: true
    completions?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    category?: true
    level?: true
    description?: true
    duration?: true
    studentsCount?: true
    rating?: true
    likes?: true
    completions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    category?: true
    level?: true
    description?: true
    duration?: true
    studentsCount?: true
    rating?: true
    likes?: true
    completions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    category?: true
    level?: true
    description?: true
    duration?: true
    studentsCount?: true
    rating?: true
    likes?: true
    completions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration: string
    studentsCount: number
    rating: number
    likes: number
    completions: number
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    category?: boolean
    level?: boolean
    description?: boolean
    duration?: boolean
    studentsCount?: boolean
    rating?: boolean
    likes?: boolean
    completions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    progress?: boolean | Course$progressArgs<ExtArgs>
    ratings?: boolean | Course$ratingsArgs<ExtArgs>
    videos?: boolean | Course$videosArgs<ExtArgs>
    users?: boolean | Course$usersArgs<ExtArgs>
    likedBy?: boolean | Course$likedByArgs<ExtArgs>
    completedChallenges?: boolean | Course$completedChallengesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    category?: boolean
    level?: boolean
    description?: boolean
    duration?: boolean
    studentsCount?: boolean
    rating?: boolean
    likes?: boolean
    completions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    category?: boolean
    level?: boolean
    description?: boolean
    duration?: boolean
    studentsCount?: boolean
    rating?: boolean
    likes?: boolean
    completions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    creatorId?: boolean
    title?: boolean
    category?: boolean
    level?: boolean
    description?: boolean
    duration?: boolean
    studentsCount?: boolean
    rating?: boolean
    likes?: boolean
    completions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorId" | "title" | "category" | "level" | "description" | "duration" | "studentsCount" | "rating" | "likes" | "completions" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    modules?: boolean | Course$modulesArgs<ExtArgs>
    progress?: boolean | Course$progressArgs<ExtArgs>
    ratings?: boolean | Course$ratingsArgs<ExtArgs>
    videos?: boolean | Course$videosArgs<ExtArgs>
    users?: boolean | Course$usersArgs<ExtArgs>
    likedBy?: boolean | Course$likedByArgs<ExtArgs>
    completedChallenges?: boolean | Course$completedChallengesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      modules: Prisma.$CourseModulePayload<ExtArgs>[]
      progress: Prisma.$UserCourseProgressPayload<ExtArgs>[]
      ratings: Prisma.$CourseRatingPayload<ExtArgs>[]
      videos: Prisma.$VideoPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      likedBy: Prisma.$CourseLikePayload<ExtArgs>[]
      completedChallenges: Prisma.$CompletedChallengesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      creatorId: number
      title: string
      category: string
      level: $Enums.Level
      description: string
      duration: string
      studentsCount: number
      rating: number
      likes: number
      completions: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends Course$progressArgs<ExtArgs> = {}>(args?: Subset<T, Course$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ratings<T extends Course$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Course$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videos<T extends Course$videosArgs<ExtArgs> = {}>(args?: Subset<T, Course$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Course$usersArgs<ExtArgs> = {}>(args?: Subset<T, Course$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likedBy<T extends Course$likedByArgs<ExtArgs> = {}>(args?: Subset<T, Course$likedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    completedChallenges<T extends Course$completedChallengesArgs<ExtArgs> = {}>(args?: Subset<T, Course$completedChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'Int'>
    readonly creatorId: FieldRef<"Course", 'Int'>
    readonly title: FieldRef<"Course", 'String'>
    readonly category: FieldRef<"Course", 'String'>
    readonly level: FieldRef<"Course", 'Level'>
    readonly description: FieldRef<"Course", 'String'>
    readonly duration: FieldRef<"Course", 'String'>
    readonly studentsCount: FieldRef<"Course", 'Int'>
    readonly rating: FieldRef<"Course", 'Float'>
    readonly likes: FieldRef<"Course", 'Int'>
    readonly completions: FieldRef<"Course", 'Int'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    cursor?: CourseModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * Course.progress
   */
  export type Course$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    where?: UserCourseProgressWhereInput
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    cursor?: UserCourseProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * Course.ratings
   */
  export type Course$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    where?: CourseRatingWhereInput
    orderBy?: CourseRatingOrderByWithRelationInput | CourseRatingOrderByWithRelationInput[]
    cursor?: CourseRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseRatingScalarFieldEnum | CourseRatingScalarFieldEnum[]
  }

  /**
   * Course.videos
   */
  export type Course$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Course.users
   */
  export type Course$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Course.likedBy
   */
  export type Course$likedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    where?: CourseLikeWhereInput
    orderBy?: CourseLikeOrderByWithRelationInput | CourseLikeOrderByWithRelationInput[]
    cursor?: CourseLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLikeScalarFieldEnum | CourseLikeScalarFieldEnum[]
  }

  /**
   * Course.completedChallenges
   */
  export type Course$completedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    where?: CompletedChallengesWhereInput
    orderBy?: CompletedChallengesOrderByWithRelationInput | CompletedChallengesOrderByWithRelationInput[]
    cursor?: CompletedChallengesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompletedChallengesScalarFieldEnum | CompletedChallengesScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseLike
   */

  export type AggregateCourseLike = {
    _count: CourseLikeCountAggregateOutputType | null
    _avg: CourseLikeAvgAggregateOutputType | null
    _sum: CourseLikeSumAggregateOutputType | null
    _min: CourseLikeMinAggregateOutputType | null
    _max: CourseLikeMaxAggregateOutputType | null
  }

  export type CourseLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type CourseLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type CourseLikeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    createdAt: Date | null
  }

  export type CourseLikeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    createdAt: Date | null
  }

  export type CourseLikeCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    createdAt: number
    _all: number
  }


  export type CourseLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type CourseLikeSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type CourseLikeMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    createdAt?: true
  }

  export type CourseLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    createdAt?: true
  }

  export type CourseLikeCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    createdAt?: true
    _all?: true
  }

  export type CourseLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLike to aggregate.
     */
    where?: CourseLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLikes to fetch.
     */
    orderBy?: CourseLikeOrderByWithRelationInput | CourseLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseLikes
    **/
    _count?: true | CourseLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseLikeMaxAggregateInputType
  }

  export type GetCourseLikeAggregateType<T extends CourseLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseLike[P]>
      : GetScalarType<T[P], AggregateCourseLike[P]>
  }




  export type CourseLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLikeWhereInput
    orderBy?: CourseLikeOrderByWithAggregationInput | CourseLikeOrderByWithAggregationInput[]
    by: CourseLikeScalarFieldEnum[] | CourseLikeScalarFieldEnum
    having?: CourseLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseLikeCountAggregateInputType | true
    _avg?: CourseLikeAvgAggregateInputType
    _sum?: CourseLikeSumAggregateInputType
    _min?: CourseLikeMinAggregateInputType
    _max?: CourseLikeMaxAggregateInputType
  }

  export type CourseLikeGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    createdAt: Date
    _count: CourseLikeCountAggregateOutputType | null
    _avg: CourseLikeAvgAggregateOutputType | null
    _sum: CourseLikeSumAggregateOutputType | null
    _min: CourseLikeMinAggregateOutputType | null
    _max: CourseLikeMaxAggregateOutputType | null
  }

  type GetCourseLikeGroupByPayload<T extends CourseLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseLikeGroupByOutputType[P]>
            : GetScalarType<T[P], CourseLikeGroupByOutputType[P]>
        }
      >
    >


  export type CourseLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLike"]>

  export type CourseLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLike"]>

  export type CourseLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLike"]>

  export type CourseLikeSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
  }

  export type CourseLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "createdAt", ExtArgs["result"]["courseLike"]>
  export type CourseLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseLike"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      createdAt: Date
    }, ExtArgs["result"]["courseLike"]>
    composites: {}
  }

  type CourseLikeGetPayload<S extends boolean | null | undefined | CourseLikeDefaultArgs> = $Result.GetResult<Prisma.$CourseLikePayload, S>

  type CourseLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseLikeCountAggregateInputType | true
    }

  export interface CourseLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseLike'], meta: { name: 'CourseLike' } }
    /**
     * Find zero or one CourseLike that matches the filter.
     * @param {CourseLikeFindUniqueArgs} args - Arguments to find a CourseLike
     * @example
     * // Get one CourseLike
     * const courseLike = await prisma.courseLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseLikeFindUniqueArgs>(args: SelectSubset<T, CourseLikeFindUniqueArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseLikeFindUniqueOrThrowArgs} args - Arguments to find a CourseLike
     * @example
     * // Get one CourseLike
     * const courseLike = await prisma.courseLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLikeFindFirstArgs} args - Arguments to find a CourseLike
     * @example
     * // Get one CourseLike
     * const courseLike = await prisma.courseLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseLikeFindFirstArgs>(args?: SelectSubset<T, CourseLikeFindFirstArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLikeFindFirstOrThrowArgs} args - Arguments to find a CourseLike
     * @example
     * // Get one CourseLike
     * const courseLike = await prisma.courseLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseLikes
     * const courseLikes = await prisma.courseLike.findMany()
     * 
     * // Get first 10 CourseLikes
     * const courseLikes = await prisma.courseLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseLikeWithIdOnly = await prisma.courseLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseLikeFindManyArgs>(args?: SelectSubset<T, CourseLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseLike.
     * @param {CourseLikeCreateArgs} args - Arguments to create a CourseLike.
     * @example
     * // Create one CourseLike
     * const CourseLike = await prisma.courseLike.create({
     *   data: {
     *     // ... data to create a CourseLike
     *   }
     * })
     * 
     */
    create<T extends CourseLikeCreateArgs>(args: SelectSubset<T, CourseLikeCreateArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseLikes.
     * @param {CourseLikeCreateManyArgs} args - Arguments to create many CourseLikes.
     * @example
     * // Create many CourseLikes
     * const courseLike = await prisma.courseLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseLikeCreateManyArgs>(args?: SelectSubset<T, CourseLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseLikes and returns the data saved in the database.
     * @param {CourseLikeCreateManyAndReturnArgs} args - Arguments to create many CourseLikes.
     * @example
     * // Create many CourseLikes
     * const courseLike = await prisma.courseLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseLikes and only return the `id`
     * const courseLikeWithIdOnly = await prisma.courseLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseLike.
     * @param {CourseLikeDeleteArgs} args - Arguments to delete one CourseLike.
     * @example
     * // Delete one CourseLike
     * const CourseLike = await prisma.courseLike.delete({
     *   where: {
     *     // ... filter to delete one CourseLike
     *   }
     * })
     * 
     */
    delete<T extends CourseLikeDeleteArgs>(args: SelectSubset<T, CourseLikeDeleteArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseLike.
     * @param {CourseLikeUpdateArgs} args - Arguments to update one CourseLike.
     * @example
     * // Update one CourseLike
     * const courseLike = await prisma.courseLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseLikeUpdateArgs>(args: SelectSubset<T, CourseLikeUpdateArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseLikes.
     * @param {CourseLikeDeleteManyArgs} args - Arguments to filter CourseLikes to delete.
     * @example
     * // Delete a few CourseLikes
     * const { count } = await prisma.courseLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseLikeDeleteManyArgs>(args?: SelectSubset<T, CourseLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseLikes
     * const courseLike = await prisma.courseLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseLikeUpdateManyArgs>(args: SelectSubset<T, CourseLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseLikes and returns the data updated in the database.
     * @param {CourseLikeUpdateManyAndReturnArgs} args - Arguments to update many CourseLikes.
     * @example
     * // Update many CourseLikes
     * const courseLike = await prisma.courseLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseLikes and only return the `id`
     * const courseLikeWithIdOnly = await prisma.courseLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseLike.
     * @param {CourseLikeUpsertArgs} args - Arguments to update or create a CourseLike.
     * @example
     * // Update or create a CourseLike
     * const courseLike = await prisma.courseLike.upsert({
     *   create: {
     *     // ... data to create a CourseLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseLike we want to update
     *   }
     * })
     */
    upsert<T extends CourseLikeUpsertArgs>(args: SelectSubset<T, CourseLikeUpsertArgs<ExtArgs>>): Prisma__CourseLikeClient<$Result.GetResult<Prisma.$CourseLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLikeCountArgs} args - Arguments to filter CourseLikes to count.
     * @example
     * // Count the number of CourseLikes
     * const count = await prisma.courseLike.count({
     *   where: {
     *     // ... the filter for the CourseLikes we want to count
     *   }
     * })
    **/
    count<T extends CourseLikeCountArgs>(
      args?: Subset<T, CourseLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseLikeAggregateArgs>(args: Subset<T, CourseLikeAggregateArgs>): Prisma.PrismaPromise<GetCourseLikeAggregateType<T>>

    /**
     * Group by CourseLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseLikeGroupByArgs['orderBy'] }
        : { orderBy?: CourseLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseLike model
   */
  readonly fields: CourseLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseLike model
   */
  interface CourseLikeFieldRefs {
    readonly id: FieldRef<"CourseLike", 'Int'>
    readonly userId: FieldRef<"CourseLike", 'Int'>
    readonly courseId: FieldRef<"CourseLike", 'Int'>
    readonly createdAt: FieldRef<"CourseLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseLike findUnique
   */
  export type CourseLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * Filter, which CourseLike to fetch.
     */
    where: CourseLikeWhereUniqueInput
  }

  /**
   * CourseLike findUniqueOrThrow
   */
  export type CourseLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * Filter, which CourseLike to fetch.
     */
    where: CourseLikeWhereUniqueInput
  }

  /**
   * CourseLike findFirst
   */
  export type CourseLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * Filter, which CourseLike to fetch.
     */
    where?: CourseLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLikes to fetch.
     */
    orderBy?: CourseLikeOrderByWithRelationInput | CourseLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLikes.
     */
    cursor?: CourseLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLikes.
     */
    distinct?: CourseLikeScalarFieldEnum | CourseLikeScalarFieldEnum[]
  }

  /**
   * CourseLike findFirstOrThrow
   */
  export type CourseLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * Filter, which CourseLike to fetch.
     */
    where?: CourseLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLikes to fetch.
     */
    orderBy?: CourseLikeOrderByWithRelationInput | CourseLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLikes.
     */
    cursor?: CourseLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLikes.
     */
    distinct?: CourseLikeScalarFieldEnum | CourseLikeScalarFieldEnum[]
  }

  /**
   * CourseLike findMany
   */
  export type CourseLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * Filter, which CourseLikes to fetch.
     */
    where?: CourseLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLikes to fetch.
     */
    orderBy?: CourseLikeOrderByWithRelationInput | CourseLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseLikes.
     */
    cursor?: CourseLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLikes.
     */
    skip?: number
    distinct?: CourseLikeScalarFieldEnum | CourseLikeScalarFieldEnum[]
  }

  /**
   * CourseLike create
   */
  export type CourseLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseLike.
     */
    data: XOR<CourseLikeCreateInput, CourseLikeUncheckedCreateInput>
  }

  /**
   * CourseLike createMany
   */
  export type CourseLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseLikes.
     */
    data: CourseLikeCreateManyInput | CourseLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseLike createManyAndReturn
   */
  export type CourseLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * The data used to create many CourseLikes.
     */
    data: CourseLikeCreateManyInput | CourseLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseLike update
   */
  export type CourseLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseLike.
     */
    data: XOR<CourseLikeUpdateInput, CourseLikeUncheckedUpdateInput>
    /**
     * Choose, which CourseLike to update.
     */
    where: CourseLikeWhereUniqueInput
  }

  /**
   * CourseLike updateMany
   */
  export type CourseLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseLikes.
     */
    data: XOR<CourseLikeUpdateManyMutationInput, CourseLikeUncheckedUpdateManyInput>
    /**
     * Filter which CourseLikes to update
     */
    where?: CourseLikeWhereInput
    /**
     * Limit how many CourseLikes to update.
     */
    limit?: number
  }

  /**
   * CourseLike updateManyAndReturn
   */
  export type CourseLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * The data used to update CourseLikes.
     */
    data: XOR<CourseLikeUpdateManyMutationInput, CourseLikeUncheckedUpdateManyInput>
    /**
     * Filter which CourseLikes to update
     */
    where?: CourseLikeWhereInput
    /**
     * Limit how many CourseLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseLike upsert
   */
  export type CourseLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseLike to update in case it exists.
     */
    where: CourseLikeWhereUniqueInput
    /**
     * In case the CourseLike found by the `where` argument doesn't exist, create a new CourseLike with this data.
     */
    create: XOR<CourseLikeCreateInput, CourseLikeUncheckedCreateInput>
    /**
     * In case the CourseLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseLikeUpdateInput, CourseLikeUncheckedUpdateInput>
  }

  /**
   * CourseLike delete
   */
  export type CourseLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
    /**
     * Filter which CourseLike to delete.
     */
    where: CourseLikeWhereUniqueInput
  }

  /**
   * CourseLike deleteMany
   */
  export type CourseLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLikes to delete
     */
    where?: CourseLikeWhereInput
    /**
     * Limit how many CourseLikes to delete.
     */
    limit?: number
  }

  /**
   * CourseLike without action
   */
  export type CourseLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLike
     */
    select?: CourseLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseLike
     */
    omit?: CourseLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLikeInclude<ExtArgs> | null
  }


  /**
   * Model UserCourseProgress
   */

  export type AggregateUserCourseProgress = {
    _count: UserCourseProgressCountAggregateOutputType | null
    _avg: UserCourseProgressAvgAggregateOutputType | null
    _sum: UserCourseProgressSumAggregateOutputType | null
    _min: UserCourseProgressMinAggregateOutputType | null
    _max: UserCourseProgressMaxAggregateOutputType | null
  }

  export type UserCourseProgressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    currentStep: number | null
    rating: number | null
  }

  export type UserCourseProgressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    currentStep: number | null
    rating: number | null
  }

  export type UserCourseProgressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
    rating: number | null
  }

  export type UserCourseProgressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
    rating: number | null
  }

  export type UserCourseProgressCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    currentStep: number
    completed: number
    startedAt: number
    updatedAt: number
    rating: number
    _all: number
  }


  export type UserCourseProgressAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    currentStep?: true
    rating?: true
  }

  export type UserCourseProgressSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    currentStep?: true
    rating?: true
  }

  export type UserCourseProgressMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    rating?: true
  }

  export type UserCourseProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    rating?: true
  }

  export type UserCourseProgressCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    rating?: true
    _all?: true
  }

  export type UserCourseProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseProgress to aggregate.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCourseProgresses
    **/
    _count?: true | UserCourseProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCourseProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCourseProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCourseProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCourseProgressMaxAggregateInputType
  }

  export type GetUserCourseProgressAggregateType<T extends UserCourseProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCourseProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCourseProgress[P]>
      : GetScalarType<T[P], AggregateUserCourseProgress[P]>
  }




  export type UserCourseProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseProgressWhereInput
    orderBy?: UserCourseProgressOrderByWithAggregationInput | UserCourseProgressOrderByWithAggregationInput[]
    by: UserCourseProgressScalarFieldEnum[] | UserCourseProgressScalarFieldEnum
    having?: UserCourseProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCourseProgressCountAggregateInputType | true
    _avg?: UserCourseProgressAvgAggregateInputType
    _sum?: UserCourseProgressSumAggregateInputType
    _min?: UserCourseProgressMinAggregateInputType
    _max?: UserCourseProgressMaxAggregateInputType
  }

  export type UserCourseProgressGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    currentStep: number
    completed: boolean
    startedAt: Date
    updatedAt: Date
    rating: number | null
    _count: UserCourseProgressCountAggregateOutputType | null
    _avg: UserCourseProgressAvgAggregateOutputType | null
    _sum: UserCourseProgressSumAggregateOutputType | null
    _min: UserCourseProgressMinAggregateOutputType | null
    _max: UserCourseProgressMaxAggregateOutputType | null
  }

  type GetUserCourseProgressGroupByPayload<T extends UserCourseProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCourseProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCourseProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCourseProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserCourseProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserCourseProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    rating?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseProgress"]>

  export type UserCourseProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    rating?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseProgress"]>

  export type UserCourseProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    rating?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourseProgress"]>

  export type UserCourseProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    rating?: boolean
  }

  export type UserCourseProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "currentStep" | "completed" | "startedAt" | "updatedAt" | "rating", ExtArgs["result"]["userCourseProgress"]>
  export type UserCourseProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type UserCourseProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type UserCourseProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $UserCourseProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCourseProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      currentStep: number
      completed: boolean
      startedAt: Date
      updatedAt: Date
      rating: number | null
    }, ExtArgs["result"]["userCourseProgress"]>
    composites: {}
  }

  type UserCourseProgressGetPayload<S extends boolean | null | undefined | UserCourseProgressDefaultArgs> = $Result.GetResult<Prisma.$UserCourseProgressPayload, S>

  type UserCourseProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCourseProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCourseProgressCountAggregateInputType | true
    }

  export interface UserCourseProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCourseProgress'], meta: { name: 'UserCourseProgress' } }
    /**
     * Find zero or one UserCourseProgress that matches the filter.
     * @param {UserCourseProgressFindUniqueArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCourseProgressFindUniqueArgs>(args: SelectSubset<T, UserCourseProgressFindUniqueArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCourseProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCourseProgressFindUniqueOrThrowArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCourseProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCourseProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourseProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressFindFirstArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCourseProgressFindFirstArgs>(args?: SelectSubset<T, UserCourseProgressFindFirstArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourseProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressFindFirstOrThrowArgs} args - Arguments to find a UserCourseProgress
     * @example
     * // Get one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCourseProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCourseProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCourseProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCourseProgresses
     * const userCourseProgresses = await prisma.userCourseProgress.findMany()
     * 
     * // Get first 10 UserCourseProgresses
     * const userCourseProgresses = await prisma.userCourseProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCourseProgressWithIdOnly = await prisma.userCourseProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCourseProgressFindManyArgs>(args?: SelectSubset<T, UserCourseProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCourseProgress.
     * @param {UserCourseProgressCreateArgs} args - Arguments to create a UserCourseProgress.
     * @example
     * // Create one UserCourseProgress
     * const UserCourseProgress = await prisma.userCourseProgress.create({
     *   data: {
     *     // ... data to create a UserCourseProgress
     *   }
     * })
     * 
     */
    create<T extends UserCourseProgressCreateArgs>(args: SelectSubset<T, UserCourseProgressCreateArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCourseProgresses.
     * @param {UserCourseProgressCreateManyArgs} args - Arguments to create many UserCourseProgresses.
     * @example
     * // Create many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCourseProgressCreateManyArgs>(args?: SelectSubset<T, UserCourseProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCourseProgresses and returns the data saved in the database.
     * @param {UserCourseProgressCreateManyAndReturnArgs} args - Arguments to create many UserCourseProgresses.
     * @example
     * // Create many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCourseProgresses and only return the `id`
     * const userCourseProgressWithIdOnly = await prisma.userCourseProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCourseProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCourseProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCourseProgress.
     * @param {UserCourseProgressDeleteArgs} args - Arguments to delete one UserCourseProgress.
     * @example
     * // Delete one UserCourseProgress
     * const UserCourseProgress = await prisma.userCourseProgress.delete({
     *   where: {
     *     // ... filter to delete one UserCourseProgress
     *   }
     * })
     * 
     */
    delete<T extends UserCourseProgressDeleteArgs>(args: SelectSubset<T, UserCourseProgressDeleteArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCourseProgress.
     * @param {UserCourseProgressUpdateArgs} args - Arguments to update one UserCourseProgress.
     * @example
     * // Update one UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCourseProgressUpdateArgs>(args: SelectSubset<T, UserCourseProgressUpdateArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCourseProgresses.
     * @param {UserCourseProgressDeleteManyArgs} args - Arguments to filter UserCourseProgresses to delete.
     * @example
     * // Delete a few UserCourseProgresses
     * const { count } = await prisma.userCourseProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCourseProgressDeleteManyArgs>(args?: SelectSubset<T, UserCourseProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCourseProgressUpdateManyArgs>(args: SelectSubset<T, UserCourseProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourseProgresses and returns the data updated in the database.
     * @param {UserCourseProgressUpdateManyAndReturnArgs} args - Arguments to update many UserCourseProgresses.
     * @example
     * // Update many UserCourseProgresses
     * const userCourseProgress = await prisma.userCourseProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCourseProgresses and only return the `id`
     * const userCourseProgressWithIdOnly = await prisma.userCourseProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCourseProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCourseProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCourseProgress.
     * @param {UserCourseProgressUpsertArgs} args - Arguments to update or create a UserCourseProgress.
     * @example
     * // Update or create a UserCourseProgress
     * const userCourseProgress = await prisma.userCourseProgress.upsert({
     *   create: {
     *     // ... data to create a UserCourseProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCourseProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserCourseProgressUpsertArgs>(args: SelectSubset<T, UserCourseProgressUpsertArgs<ExtArgs>>): Prisma__UserCourseProgressClient<$Result.GetResult<Prisma.$UserCourseProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCourseProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressCountArgs} args - Arguments to filter UserCourseProgresses to count.
     * @example
     * // Count the number of UserCourseProgresses
     * const count = await prisma.userCourseProgress.count({
     *   where: {
     *     // ... the filter for the UserCourseProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserCourseProgressCountArgs>(
      args?: Subset<T, UserCourseProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCourseProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCourseProgressAggregateArgs>(args: Subset<T, UserCourseProgressAggregateArgs>): Prisma.PrismaPromise<GetUserCourseProgressAggregateType<T>>

    /**
     * Group by UserCourseProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCourseProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCourseProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserCourseProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCourseProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCourseProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCourseProgress model
   */
  readonly fields: UserCourseProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCourseProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCourseProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCourseProgress model
   */
  interface UserCourseProgressFieldRefs {
    readonly id: FieldRef<"UserCourseProgress", 'Int'>
    readonly userId: FieldRef<"UserCourseProgress", 'Int'>
    readonly courseId: FieldRef<"UserCourseProgress", 'Int'>
    readonly currentStep: FieldRef<"UserCourseProgress", 'Int'>
    readonly completed: FieldRef<"UserCourseProgress", 'Boolean'>
    readonly startedAt: FieldRef<"UserCourseProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserCourseProgress", 'DateTime'>
    readonly rating: FieldRef<"UserCourseProgress", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserCourseProgress findUnique
   */
  export type UserCourseProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress findUniqueOrThrow
   */
  export type UserCourseProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress findFirst
   */
  export type UserCourseProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseProgresses.
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseProgresses.
     */
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * UserCourseProgress findFirstOrThrow
   */
  export type UserCourseProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgress to fetch.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourseProgresses.
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourseProgresses.
     */
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * UserCourseProgress findMany
   */
  export type UserCourseProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserCourseProgresses to fetch.
     */
    where?: UserCourseProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourseProgresses to fetch.
     */
    orderBy?: UserCourseProgressOrderByWithRelationInput | UserCourseProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCourseProgresses.
     */
    cursor?: UserCourseProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourseProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourseProgresses.
     */
    skip?: number
    distinct?: UserCourseProgressScalarFieldEnum | UserCourseProgressScalarFieldEnum[]
  }

  /**
   * UserCourseProgress create
   */
  export type UserCourseProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCourseProgress.
     */
    data: XOR<UserCourseProgressCreateInput, UserCourseProgressUncheckedCreateInput>
  }

  /**
   * UserCourseProgress createMany
   */
  export type UserCourseProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCourseProgresses.
     */
    data: UserCourseProgressCreateManyInput | UserCourseProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCourseProgress createManyAndReturn
   */
  export type UserCourseProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserCourseProgresses.
     */
    data: UserCourseProgressCreateManyInput | UserCourseProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourseProgress update
   */
  export type UserCourseProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCourseProgress.
     */
    data: XOR<UserCourseProgressUpdateInput, UserCourseProgressUncheckedUpdateInput>
    /**
     * Choose, which UserCourseProgress to update.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress updateMany
   */
  export type UserCourseProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCourseProgresses.
     */
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserCourseProgresses to update
     */
    where?: UserCourseProgressWhereInput
    /**
     * Limit how many UserCourseProgresses to update.
     */
    limit?: number
  }

  /**
   * UserCourseProgress updateManyAndReturn
   */
  export type UserCourseProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserCourseProgresses.
     */
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserCourseProgresses to update
     */
    where?: UserCourseProgressWhereInput
    /**
     * Limit how many UserCourseProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourseProgress upsert
   */
  export type UserCourseProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCourseProgress to update in case it exists.
     */
    where: UserCourseProgressWhereUniqueInput
    /**
     * In case the UserCourseProgress found by the `where` argument doesn't exist, create a new UserCourseProgress with this data.
     */
    create: XOR<UserCourseProgressCreateInput, UserCourseProgressUncheckedCreateInput>
    /**
     * In case the UserCourseProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCourseProgressUpdateInput, UserCourseProgressUncheckedUpdateInput>
  }

  /**
   * UserCourseProgress delete
   */
  export type UserCourseProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
    /**
     * Filter which UserCourseProgress to delete.
     */
    where: UserCourseProgressWhereUniqueInput
  }

  /**
   * UserCourseProgress deleteMany
   */
  export type UserCourseProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourseProgresses to delete
     */
    where?: UserCourseProgressWhereInput
    /**
     * Limit how many UserCourseProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserCourseProgress without action
   */
  export type UserCourseProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseProgress
     */
    select?: UserCourseProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourseProgress
     */
    omit?: UserCourseProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseProgressInclude<ExtArgs> | null
  }


  /**
   * Model CourseModule
   */

  export type AggregateCourseModule = {
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  export type CourseModuleAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    number: number | null
  }

  export type CourseModuleSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    number: number | null
  }

  export type CourseModuleMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    number: number | null
  }

  export type CourseModuleMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    number: number | null
  }

  export type CourseModuleCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    number: number
    _all: number
  }


  export type CourseModuleAvgAggregateInputType = {
    id?: true
    courseId?: true
    number?: true
  }

  export type CourseModuleSumAggregateInputType = {
    id?: true
    courseId?: true
    number?: true
  }

  export type CourseModuleMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    number?: true
  }

  export type CourseModuleMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    number?: true
  }

  export type CourseModuleCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    number?: true
    _all?: true
  }

  export type CourseModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModule to aggregate.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseModules
    **/
    _count?: true | CourseModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseModuleMaxAggregateInputType
  }

  export type GetCourseModuleAggregateType<T extends CourseModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseModule[P]>
      : GetScalarType<T[P], AggregateCourseModule[P]>
  }




  export type CourseModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseModuleWhereInput
    orderBy?: CourseModuleOrderByWithAggregationInput | CourseModuleOrderByWithAggregationInput[]
    by: CourseModuleScalarFieldEnum[] | CourseModuleScalarFieldEnum
    having?: CourseModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseModuleCountAggregateInputType | true
    _avg?: CourseModuleAvgAggregateInputType
    _sum?: CourseModuleSumAggregateInputType
    _min?: CourseModuleMinAggregateInputType
    _max?: CourseModuleMaxAggregateInputType
  }

  export type CourseModuleGroupByOutputType = {
    id: number
    courseId: number
    title: string
    number: number
    _count: CourseModuleCountAggregateOutputType | null
    _avg: CourseModuleAvgAggregateOutputType | null
    _sum: CourseModuleSumAggregateOutputType | null
    _min: CourseModuleMinAggregateOutputType | null
    _max: CourseModuleMaxAggregateOutputType | null
  }

  type GetCourseModuleGroupByPayload<T extends CourseModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
            : GetScalarType<T[P], CourseModuleGroupByOutputType[P]>
        }
      >
    >


  export type CourseModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    miniModules?: boolean | CourseModule$miniModulesArgs<ExtArgs>
    progress?: boolean | CourseModule$progressArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseModule"]>

  export type CourseModuleSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
  }

  export type CourseModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "number", ExtArgs["result"]["courseModule"]>
  export type CourseModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    miniModules?: boolean | CourseModule$miniModulesArgs<ExtArgs>
    progress?: boolean | CourseModule$progressArgs<ExtArgs>
    _count?: boolean | CourseModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseModule"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      miniModules: Prisma.$MiniModulePayload<ExtArgs>[]
      progress: Prisma.$userModuleProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      number: number
    }, ExtArgs["result"]["courseModule"]>
    composites: {}
  }

  type CourseModuleGetPayload<S extends boolean | null | undefined | CourseModuleDefaultArgs> = $Result.GetResult<Prisma.$CourseModulePayload, S>

  type CourseModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseModuleCountAggregateInputType | true
    }

  export interface CourseModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseModule'], meta: { name: 'CourseModule' } }
    /**
     * Find zero or one CourseModule that matches the filter.
     * @param {CourseModuleFindUniqueArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseModuleFindUniqueArgs>(args: SelectSubset<T, CourseModuleFindUniqueArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseModuleFindUniqueOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseModuleFindFirstArgs>(args?: SelectSubset<T, CourseModuleFindFirstArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindFirstOrThrowArgs} args - Arguments to find a CourseModule
     * @example
     * // Get one CourseModule
     * const courseModule = await prisma.courseModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseModules
     * const courseModules = await prisma.courseModule.findMany()
     * 
     * // Get first 10 CourseModules
     * const courseModules = await prisma.courseModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseModuleFindManyArgs>(args?: SelectSubset<T, CourseModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseModule.
     * @param {CourseModuleCreateArgs} args - Arguments to create a CourseModule.
     * @example
     * // Create one CourseModule
     * const CourseModule = await prisma.courseModule.create({
     *   data: {
     *     // ... data to create a CourseModule
     *   }
     * })
     * 
     */
    create<T extends CourseModuleCreateArgs>(args: SelectSubset<T, CourseModuleCreateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseModules.
     * @param {CourseModuleCreateManyArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseModuleCreateManyArgs>(args?: SelectSubset<T, CourseModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseModules and returns the data saved in the database.
     * @param {CourseModuleCreateManyAndReturnArgs} args - Arguments to create many CourseModules.
     * @example
     * // Create many CourseModules
     * const courseModule = await prisma.courseModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseModule.
     * @param {CourseModuleDeleteArgs} args - Arguments to delete one CourseModule.
     * @example
     * // Delete one CourseModule
     * const CourseModule = await prisma.courseModule.delete({
     *   where: {
     *     // ... filter to delete one CourseModule
     *   }
     * })
     * 
     */
    delete<T extends CourseModuleDeleteArgs>(args: SelectSubset<T, CourseModuleDeleteArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseModule.
     * @param {CourseModuleUpdateArgs} args - Arguments to update one CourseModule.
     * @example
     * // Update one CourseModule
     * const courseModule = await prisma.courseModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseModuleUpdateArgs>(args: SelectSubset<T, CourseModuleUpdateArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseModules.
     * @param {CourseModuleDeleteManyArgs} args - Arguments to filter CourseModules to delete.
     * @example
     * // Delete a few CourseModules
     * const { count } = await prisma.courseModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseModuleDeleteManyArgs>(args?: SelectSubset<T, CourseModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseModuleUpdateManyArgs>(args: SelectSubset<T, CourseModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseModules and returns the data updated in the database.
     * @param {CourseModuleUpdateManyAndReturnArgs} args - Arguments to update many CourseModules.
     * @example
     * // Update many CourseModules
     * const courseModule = await prisma.courseModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseModules and only return the `id`
     * const courseModuleWithIdOnly = await prisma.courseModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseModule.
     * @param {CourseModuleUpsertArgs} args - Arguments to update or create a CourseModule.
     * @example
     * // Update or create a CourseModule
     * const courseModule = await prisma.courseModule.upsert({
     *   create: {
     *     // ... data to create a CourseModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseModule we want to update
     *   }
     * })
     */
    upsert<T extends CourseModuleUpsertArgs>(args: SelectSubset<T, CourseModuleUpsertArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleCountArgs} args - Arguments to filter CourseModules to count.
     * @example
     * // Count the number of CourseModules
     * const count = await prisma.courseModule.count({
     *   where: {
     *     // ... the filter for the CourseModules we want to count
     *   }
     * })
    **/
    count<T extends CourseModuleCountArgs>(
      args?: Subset<T, CourseModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseModuleAggregateArgs>(args: Subset<T, CourseModuleAggregateArgs>): Prisma.PrismaPromise<GetCourseModuleAggregateType<T>>

    /**
     * Group by CourseModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseModuleGroupByArgs['orderBy'] }
        : { orderBy?: CourseModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseModule model
   */
  readonly fields: CourseModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    miniModules<T extends CourseModule$miniModulesArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$miniModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends CourseModule$progressArgs<ExtArgs> = {}>(args?: Subset<T, CourseModule$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseModule model
   */
  interface CourseModuleFieldRefs {
    readonly id: FieldRef<"CourseModule", 'Int'>
    readonly courseId: FieldRef<"CourseModule", 'Int'>
    readonly title: FieldRef<"CourseModule", 'String'>
    readonly number: FieldRef<"CourseModule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseModule findUnique
   */
  export type CourseModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findUniqueOrThrow
   */
  export type CourseModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule findFirst
   */
  export type CourseModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findFirstOrThrow
   */
  export type CourseModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModule to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseModules.
     */
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule findMany
   */
  export type CourseModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter, which CourseModules to fetch.
     */
    where?: CourseModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseModules to fetch.
     */
    orderBy?: CourseModuleOrderByWithRelationInput | CourseModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseModules.
     */
    cursor?: CourseModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseModules.
     */
    skip?: number
    distinct?: CourseModuleScalarFieldEnum | CourseModuleScalarFieldEnum[]
  }

  /**
   * CourseModule create
   */
  export type CourseModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseModule.
     */
    data: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
  }

  /**
   * CourseModule createMany
   */
  export type CourseModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseModule createManyAndReturn
   */
  export type CourseModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to create many CourseModules.
     */
    data: CourseModuleCreateManyInput | CourseModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule update
   */
  export type CourseModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseModule.
     */
    data: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
    /**
     * Choose, which CourseModule to update.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule updateMany
   */
  export type CourseModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
  }

  /**
   * CourseModule updateManyAndReturn
   */
  export type CourseModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * The data used to update CourseModules.
     */
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyInput>
    /**
     * Filter which CourseModules to update
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseModule upsert
   */
  export type CourseModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseModule to update in case it exists.
     */
    where: CourseModuleWhereUniqueInput
    /**
     * In case the CourseModule found by the `where` argument doesn't exist, create a new CourseModule with this data.
     */
    create: XOR<CourseModuleCreateInput, CourseModuleUncheckedCreateInput>
    /**
     * In case the CourseModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseModuleUpdateInput, CourseModuleUncheckedUpdateInput>
  }

  /**
   * CourseModule delete
   */
  export type CourseModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
    /**
     * Filter which CourseModule to delete.
     */
    where: CourseModuleWhereUniqueInput
  }

  /**
   * CourseModule deleteMany
   */
  export type CourseModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseModules to delete
     */
    where?: CourseModuleWhereInput
    /**
     * Limit how many CourseModules to delete.
     */
    limit?: number
  }

  /**
   * CourseModule.miniModules
   */
  export type CourseModule$miniModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    where?: MiniModuleWhereInput
    orderBy?: MiniModuleOrderByWithRelationInput | MiniModuleOrderByWithRelationInput[]
    cursor?: MiniModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MiniModuleScalarFieldEnum | MiniModuleScalarFieldEnum[]
  }

  /**
   * CourseModule.progress
   */
  export type CourseModule$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    where?: userModuleProgressWhereInput
    orderBy?: userModuleProgressOrderByWithRelationInput | userModuleProgressOrderByWithRelationInput[]
    cursor?: userModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserModuleProgressScalarFieldEnum | UserModuleProgressScalarFieldEnum[]
  }

  /**
   * CourseModule without action
   */
  export type CourseModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseModule
     */
    select?: CourseModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseModule
     */
    omit?: CourseModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseModuleInclude<ExtArgs> | null
  }


  /**
   * Model userModuleProgress
   */

  export type AggregateUserModuleProgress = {
    _count: UserModuleProgressCountAggregateOutputType | null
    _avg: UserModuleProgressAvgAggregateOutputType | null
    _sum: UserModuleProgressSumAggregateOutputType | null
    _min: UserModuleProgressMinAggregateOutputType | null
    _max: UserModuleProgressMaxAggregateOutputType | null
  }

  export type UserModuleProgressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseModuleId: number | null
    currentStep: number | null
    courseId: number | null
  }

  export type UserModuleProgressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseModuleId: number | null
    currentStep: number | null
    courseId: number | null
  }

  export type UserModuleProgressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseModuleId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
    courseId: number | null
  }

  export type UserModuleProgressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseModuleId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
    courseId: number | null
  }

  export type UserModuleProgressCountAggregateOutputType = {
    id: number
    userId: number
    courseModuleId: number
    currentStep: number
    completed: number
    startedAt: number
    updatedAt: number
    courseId: number
    _all: number
  }


  export type UserModuleProgressAvgAggregateInputType = {
    id?: true
    userId?: true
    courseModuleId?: true
    currentStep?: true
    courseId?: true
  }

  export type UserModuleProgressSumAggregateInputType = {
    id?: true
    userId?: true
    courseModuleId?: true
    currentStep?: true
    courseId?: true
  }

  export type UserModuleProgressMinAggregateInputType = {
    id?: true
    userId?: true
    courseModuleId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    courseId?: true
  }

  export type UserModuleProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    courseModuleId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    courseId?: true
  }

  export type UserModuleProgressCountAggregateInputType = {
    id?: true
    userId?: true
    courseModuleId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    courseId?: true
    _all?: true
  }

  export type UserModuleProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userModuleProgress to aggregate.
     */
    where?: userModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userModuleProgresses to fetch.
     */
    orderBy?: userModuleProgressOrderByWithRelationInput | userModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userModuleProgresses
    **/
    _count?: true | UserModuleProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserModuleProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserModuleProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserModuleProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserModuleProgressMaxAggregateInputType
  }

  export type GetUserModuleProgressAggregateType<T extends UserModuleProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserModuleProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserModuleProgress[P]>
      : GetScalarType<T[P], AggregateUserModuleProgress[P]>
  }




  export type userModuleProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userModuleProgressWhereInput
    orderBy?: userModuleProgressOrderByWithAggregationInput | userModuleProgressOrderByWithAggregationInput[]
    by: UserModuleProgressScalarFieldEnum[] | UserModuleProgressScalarFieldEnum
    having?: userModuleProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserModuleProgressCountAggregateInputType | true
    _avg?: UserModuleProgressAvgAggregateInputType
    _sum?: UserModuleProgressSumAggregateInputType
    _min?: UserModuleProgressMinAggregateInputType
    _max?: UserModuleProgressMaxAggregateInputType
  }

  export type UserModuleProgressGroupByOutputType = {
    id: number
    userId: number
    courseModuleId: number
    currentStep: number
    completed: boolean
    startedAt: Date
    updatedAt: Date
    courseId: number | null
    _count: UserModuleProgressCountAggregateOutputType | null
    _avg: UserModuleProgressAvgAggregateOutputType | null
    _sum: UserModuleProgressSumAggregateOutputType | null
    _min: UserModuleProgressMinAggregateOutputType | null
    _max: UserModuleProgressMaxAggregateOutputType | null
  }

  type GetUserModuleProgressGroupByPayload<T extends userModuleProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserModuleProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserModuleProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserModuleProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserModuleProgressGroupByOutputType[P]>
        }
      >
    >


  export type userModuleProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userModuleProgress"]>

  export type userModuleProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userModuleProgress"]>

  export type userModuleProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userModuleProgress"]>

  export type userModuleProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    courseModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
  }

  export type userModuleProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseModuleId" | "currentStep" | "completed" | "startedAt" | "updatedAt" | "courseId", ExtArgs["result"]["userModuleProgress"]>
  export type userModuleProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type userModuleProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type userModuleProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $userModuleProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userModuleProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      courseModule: Prisma.$CourseModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseModuleId: number
      currentStep: number
      completed: boolean
      startedAt: Date
      updatedAt: Date
      courseId: number | null
    }, ExtArgs["result"]["userModuleProgress"]>
    composites: {}
  }

  type userModuleProgressGetPayload<S extends boolean | null | undefined | userModuleProgressDefaultArgs> = $Result.GetResult<Prisma.$userModuleProgressPayload, S>

  type userModuleProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userModuleProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserModuleProgressCountAggregateInputType | true
    }

  export interface userModuleProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userModuleProgress'], meta: { name: 'userModuleProgress' } }
    /**
     * Find zero or one UserModuleProgress that matches the filter.
     * @param {userModuleProgressFindUniqueArgs} args - Arguments to find a UserModuleProgress
     * @example
     * // Get one UserModuleProgress
     * const userModuleProgress = await prisma.userModuleProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userModuleProgressFindUniqueArgs>(args: SelectSubset<T, userModuleProgressFindUniqueArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserModuleProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userModuleProgressFindUniqueOrThrowArgs} args - Arguments to find a UserModuleProgress
     * @example
     * // Get one UserModuleProgress
     * const userModuleProgress = await prisma.userModuleProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userModuleProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, userModuleProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserModuleProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userModuleProgressFindFirstArgs} args - Arguments to find a UserModuleProgress
     * @example
     * // Get one UserModuleProgress
     * const userModuleProgress = await prisma.userModuleProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userModuleProgressFindFirstArgs>(args?: SelectSubset<T, userModuleProgressFindFirstArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserModuleProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userModuleProgressFindFirstOrThrowArgs} args - Arguments to find a UserModuleProgress
     * @example
     * // Get one UserModuleProgress
     * const userModuleProgress = await prisma.userModuleProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userModuleProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, userModuleProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserModuleProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userModuleProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserModuleProgresses
     * const userModuleProgresses = await prisma.userModuleProgress.findMany()
     * 
     * // Get first 10 UserModuleProgresses
     * const userModuleProgresses = await prisma.userModuleProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userModuleProgressWithIdOnly = await prisma.userModuleProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userModuleProgressFindManyArgs>(args?: SelectSubset<T, userModuleProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserModuleProgress.
     * @param {userModuleProgressCreateArgs} args - Arguments to create a UserModuleProgress.
     * @example
     * // Create one UserModuleProgress
     * const UserModuleProgress = await prisma.userModuleProgress.create({
     *   data: {
     *     // ... data to create a UserModuleProgress
     *   }
     * })
     * 
     */
    create<T extends userModuleProgressCreateArgs>(args: SelectSubset<T, userModuleProgressCreateArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserModuleProgresses.
     * @param {userModuleProgressCreateManyArgs} args - Arguments to create many UserModuleProgresses.
     * @example
     * // Create many UserModuleProgresses
     * const userModuleProgress = await prisma.userModuleProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userModuleProgressCreateManyArgs>(args?: SelectSubset<T, userModuleProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserModuleProgresses and returns the data saved in the database.
     * @param {userModuleProgressCreateManyAndReturnArgs} args - Arguments to create many UserModuleProgresses.
     * @example
     * // Create many UserModuleProgresses
     * const userModuleProgress = await prisma.userModuleProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserModuleProgresses and only return the `id`
     * const userModuleProgressWithIdOnly = await prisma.userModuleProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userModuleProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, userModuleProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserModuleProgress.
     * @param {userModuleProgressDeleteArgs} args - Arguments to delete one UserModuleProgress.
     * @example
     * // Delete one UserModuleProgress
     * const UserModuleProgress = await prisma.userModuleProgress.delete({
     *   where: {
     *     // ... filter to delete one UserModuleProgress
     *   }
     * })
     * 
     */
    delete<T extends userModuleProgressDeleteArgs>(args: SelectSubset<T, userModuleProgressDeleteArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserModuleProgress.
     * @param {userModuleProgressUpdateArgs} args - Arguments to update one UserModuleProgress.
     * @example
     * // Update one UserModuleProgress
     * const userModuleProgress = await prisma.userModuleProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userModuleProgressUpdateArgs>(args: SelectSubset<T, userModuleProgressUpdateArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserModuleProgresses.
     * @param {userModuleProgressDeleteManyArgs} args - Arguments to filter UserModuleProgresses to delete.
     * @example
     * // Delete a few UserModuleProgresses
     * const { count } = await prisma.userModuleProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userModuleProgressDeleteManyArgs>(args?: SelectSubset<T, userModuleProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userModuleProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserModuleProgresses
     * const userModuleProgress = await prisma.userModuleProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userModuleProgressUpdateManyArgs>(args: SelectSubset<T, userModuleProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModuleProgresses and returns the data updated in the database.
     * @param {userModuleProgressUpdateManyAndReturnArgs} args - Arguments to update many UserModuleProgresses.
     * @example
     * // Update many UserModuleProgresses
     * const userModuleProgress = await prisma.userModuleProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserModuleProgresses and only return the `id`
     * const userModuleProgressWithIdOnly = await prisma.userModuleProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userModuleProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, userModuleProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserModuleProgress.
     * @param {userModuleProgressUpsertArgs} args - Arguments to update or create a UserModuleProgress.
     * @example
     * // Update or create a UserModuleProgress
     * const userModuleProgress = await prisma.userModuleProgress.upsert({
     *   create: {
     *     // ... data to create a UserModuleProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserModuleProgress we want to update
     *   }
     * })
     */
    upsert<T extends userModuleProgressUpsertArgs>(args: SelectSubset<T, userModuleProgressUpsertArgs<ExtArgs>>): Prisma__userModuleProgressClient<$Result.GetResult<Prisma.$userModuleProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userModuleProgressCountArgs} args - Arguments to filter UserModuleProgresses to count.
     * @example
     * // Count the number of UserModuleProgresses
     * const count = await prisma.userModuleProgress.count({
     *   where: {
     *     // ... the filter for the UserModuleProgresses we want to count
     *   }
     * })
    **/
    count<T extends userModuleProgressCountArgs>(
      args?: Subset<T, userModuleProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserModuleProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserModuleProgressAggregateArgs>(args: Subset<T, UserModuleProgressAggregateArgs>): Prisma.PrismaPromise<GetUserModuleProgressAggregateType<T>>

    /**
     * Group by UserModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userModuleProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userModuleProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userModuleProgressGroupByArgs['orderBy'] }
        : { orderBy?: userModuleProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userModuleProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserModuleProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userModuleProgress model
   */
  readonly fields: userModuleProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userModuleProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userModuleProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courseModule<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userModuleProgress model
   */
  interface userModuleProgressFieldRefs {
    readonly id: FieldRef<"userModuleProgress", 'Int'>
    readonly userId: FieldRef<"userModuleProgress", 'Int'>
    readonly courseModuleId: FieldRef<"userModuleProgress", 'Int'>
    readonly currentStep: FieldRef<"userModuleProgress", 'Int'>
    readonly completed: FieldRef<"userModuleProgress", 'Boolean'>
    readonly startedAt: FieldRef<"userModuleProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"userModuleProgress", 'DateTime'>
    readonly courseId: FieldRef<"userModuleProgress", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * userModuleProgress findUnique
   */
  export type userModuleProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which userModuleProgress to fetch.
     */
    where: userModuleProgressWhereUniqueInput
  }

  /**
   * userModuleProgress findUniqueOrThrow
   */
  export type userModuleProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which userModuleProgress to fetch.
     */
    where: userModuleProgressWhereUniqueInput
  }

  /**
   * userModuleProgress findFirst
   */
  export type userModuleProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which userModuleProgress to fetch.
     */
    where?: userModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userModuleProgresses to fetch.
     */
    orderBy?: userModuleProgressOrderByWithRelationInput | userModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userModuleProgresses.
     */
    cursor?: userModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userModuleProgresses.
     */
    distinct?: UserModuleProgressScalarFieldEnum | UserModuleProgressScalarFieldEnum[]
  }

  /**
   * userModuleProgress findFirstOrThrow
   */
  export type userModuleProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which userModuleProgress to fetch.
     */
    where?: userModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userModuleProgresses to fetch.
     */
    orderBy?: userModuleProgressOrderByWithRelationInput | userModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userModuleProgresses.
     */
    cursor?: userModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userModuleProgresses.
     */
    distinct?: UserModuleProgressScalarFieldEnum | UserModuleProgressScalarFieldEnum[]
  }

  /**
   * userModuleProgress findMany
   */
  export type userModuleProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which userModuleProgresses to fetch.
     */
    where?: userModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userModuleProgresses to fetch.
     */
    orderBy?: userModuleProgressOrderByWithRelationInput | userModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userModuleProgresses.
     */
    cursor?: userModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userModuleProgresses.
     */
    skip?: number
    distinct?: UserModuleProgressScalarFieldEnum | UserModuleProgressScalarFieldEnum[]
  }

  /**
   * userModuleProgress create
   */
  export type userModuleProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a userModuleProgress.
     */
    data: XOR<userModuleProgressCreateInput, userModuleProgressUncheckedCreateInput>
  }

  /**
   * userModuleProgress createMany
   */
  export type userModuleProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userModuleProgresses.
     */
    data: userModuleProgressCreateManyInput | userModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userModuleProgress createManyAndReturn
   */
  export type userModuleProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * The data used to create many userModuleProgresses.
     */
    data: userModuleProgressCreateManyInput | userModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userModuleProgress update
   */
  export type userModuleProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a userModuleProgress.
     */
    data: XOR<userModuleProgressUpdateInput, userModuleProgressUncheckedUpdateInput>
    /**
     * Choose, which userModuleProgress to update.
     */
    where: userModuleProgressWhereUniqueInput
  }

  /**
   * userModuleProgress updateMany
   */
  export type userModuleProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userModuleProgresses.
     */
    data: XOR<userModuleProgressUpdateManyMutationInput, userModuleProgressUncheckedUpdateManyInput>
    /**
     * Filter which userModuleProgresses to update
     */
    where?: userModuleProgressWhereInput
    /**
     * Limit how many userModuleProgresses to update.
     */
    limit?: number
  }

  /**
   * userModuleProgress updateManyAndReturn
   */
  export type userModuleProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * The data used to update userModuleProgresses.
     */
    data: XOR<userModuleProgressUpdateManyMutationInput, userModuleProgressUncheckedUpdateManyInput>
    /**
     * Filter which userModuleProgresses to update
     */
    where?: userModuleProgressWhereInput
    /**
     * Limit how many userModuleProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userModuleProgress upsert
   */
  export type userModuleProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the userModuleProgress to update in case it exists.
     */
    where: userModuleProgressWhereUniqueInput
    /**
     * In case the userModuleProgress found by the `where` argument doesn't exist, create a new userModuleProgress with this data.
     */
    create: XOR<userModuleProgressCreateInput, userModuleProgressUncheckedCreateInput>
    /**
     * In case the userModuleProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userModuleProgressUpdateInput, userModuleProgressUncheckedUpdateInput>
  }

  /**
   * userModuleProgress delete
   */
  export type userModuleProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
    /**
     * Filter which userModuleProgress to delete.
     */
    where: userModuleProgressWhereUniqueInput
  }

  /**
   * userModuleProgress deleteMany
   */
  export type userModuleProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userModuleProgresses to delete
     */
    where?: userModuleProgressWhereInput
    /**
     * Limit how many userModuleProgresses to delete.
     */
    limit?: number
  }

  /**
   * userModuleProgress without action
   */
  export type userModuleProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userModuleProgress
     */
    select?: userModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userModuleProgress
     */
    omit?: userModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userModuleProgressInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    number: number | null
  }

  export type VideoSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    number: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    number: number | null
    url: string | null
  }

  export type VideoMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    number: number | null
    url: string | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    number: number
    url: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    id?: true
    courseId?: true
    number?: true
  }

  export type VideoSumAggregateInputType = {
    id?: true
    courseId?: true
    number?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    number?: true
    url?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    number?: true
    url?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    number?: true
    url?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: number
    courseId: number
    title: string
    number: number
    url: string
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
  }

  export type VideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "number" | "url", ExtArgs["result"]["video"]>
  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type VideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type VideoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      number: number
      url: string
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideoCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos and returns the data updated in the database.
     * @param {VideoUpdateManyAndReturnArgs} args - Arguments to update many Videos.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'Int'>
    readonly courseId: FieldRef<"Video", 'Int'>
    readonly title: FieldRef<"Video", 'String'>
    readonly number: FieldRef<"Video", 'Int'>
    readonly url: FieldRef<"Video", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video createManyAndReturn
   */
  export type VideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video updateManyAndReturn
   */
  export type VideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
  }


  /**
   * Model MiniModule
   */

  export type AggregateMiniModule = {
    _count: MiniModuleCountAggregateOutputType | null
    _avg: MiniModuleAvgAggregateOutputType | null
    _sum: MiniModuleSumAggregateOutputType | null
    _min: MiniModuleMinAggregateOutputType | null
    _max: MiniModuleMaxAggregateOutputType | null
  }

  export type MiniModuleAvgAggregateOutputType = {
    id: number | null
    courseModuleId: number | null
    number: number | null
  }

  export type MiniModuleSumAggregateOutputType = {
    id: number | null
    courseModuleId: number | null
    number: number | null
  }

  export type MiniModuleMinAggregateOutputType = {
    id: number | null
    courseModuleId: number | null
    title: string | null
    number: number | null
  }

  export type MiniModuleMaxAggregateOutputType = {
    id: number | null
    courseModuleId: number | null
    title: string | null
    number: number | null
  }

  export type MiniModuleCountAggregateOutputType = {
    id: number
    courseModuleId: number
    title: number
    number: number
    _all: number
  }


  export type MiniModuleAvgAggregateInputType = {
    id?: true
    courseModuleId?: true
    number?: true
  }

  export type MiniModuleSumAggregateInputType = {
    id?: true
    courseModuleId?: true
    number?: true
  }

  export type MiniModuleMinAggregateInputType = {
    id?: true
    courseModuleId?: true
    title?: true
    number?: true
  }

  export type MiniModuleMaxAggregateInputType = {
    id?: true
    courseModuleId?: true
    title?: true
    number?: true
  }

  export type MiniModuleCountAggregateInputType = {
    id?: true
    courseModuleId?: true
    title?: true
    number?: true
    _all?: true
  }

  export type MiniModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MiniModule to aggregate.
     */
    where?: MiniModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModules to fetch.
     */
    orderBy?: MiniModuleOrderByWithRelationInput | MiniModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MiniModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MiniModules
    **/
    _count?: true | MiniModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MiniModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MiniModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MiniModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MiniModuleMaxAggregateInputType
  }

  export type GetMiniModuleAggregateType<T extends MiniModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateMiniModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiniModule[P]>
      : GetScalarType<T[P], AggregateMiniModule[P]>
  }




  export type MiniModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MiniModuleWhereInput
    orderBy?: MiniModuleOrderByWithAggregationInput | MiniModuleOrderByWithAggregationInput[]
    by: MiniModuleScalarFieldEnum[] | MiniModuleScalarFieldEnum
    having?: MiniModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MiniModuleCountAggregateInputType | true
    _avg?: MiniModuleAvgAggregateInputType
    _sum?: MiniModuleSumAggregateInputType
    _min?: MiniModuleMinAggregateInputType
    _max?: MiniModuleMaxAggregateInputType
  }

  export type MiniModuleGroupByOutputType = {
    id: number
    courseModuleId: number
    title: string
    number: number
    _count: MiniModuleCountAggregateOutputType | null
    _avg: MiniModuleAvgAggregateOutputType | null
    _sum: MiniModuleSumAggregateOutputType | null
    _min: MiniModuleMinAggregateOutputType | null
    _max: MiniModuleMaxAggregateOutputType | null
  }

  type GetMiniModuleGroupByPayload<T extends MiniModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MiniModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MiniModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MiniModuleGroupByOutputType[P]>
            : GetScalarType<T[P], MiniModuleGroupByOutputType[P]>
        }
      >
    >


  export type MiniModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseModuleId?: boolean
    title?: boolean
    number?: boolean
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
    lessons?: boolean | MiniModule$lessonsArgs<ExtArgs>
    lessonVideos?: boolean | MiniModule$lessonVideosArgs<ExtArgs>
    progress?: boolean | MiniModule$progressArgs<ExtArgs>
    _count?: boolean | MiniModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniModule"]>

  export type MiniModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseModuleId?: boolean
    title?: boolean
    number?: boolean
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniModule"]>

  export type MiniModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseModuleId?: boolean
    title?: boolean
    number?: boolean
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniModule"]>

  export type MiniModuleSelectScalar = {
    id?: boolean
    courseModuleId?: boolean
    title?: boolean
    number?: boolean
  }

  export type MiniModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseModuleId" | "title" | "number", ExtArgs["result"]["miniModule"]>
  export type MiniModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
    lessons?: boolean | MiniModule$lessonsArgs<ExtArgs>
    lessonVideos?: boolean | MiniModule$lessonVideosArgs<ExtArgs>
    progress?: boolean | MiniModule$progressArgs<ExtArgs>
    _count?: boolean | MiniModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MiniModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }
  export type MiniModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseModule?: boolean | CourseModuleDefaultArgs<ExtArgs>
  }

  export type $MiniModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MiniModule"
    objects: {
      courseModule: Prisma.$CourseModulePayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      lessonVideos: Prisma.$LessonVideoPayload<ExtArgs>[]
      progress: Prisma.$MiniModuleProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseModuleId: number
      title: string
      number: number
    }, ExtArgs["result"]["miniModule"]>
    composites: {}
  }

  type MiniModuleGetPayload<S extends boolean | null | undefined | MiniModuleDefaultArgs> = $Result.GetResult<Prisma.$MiniModulePayload, S>

  type MiniModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MiniModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MiniModuleCountAggregateInputType | true
    }

  export interface MiniModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MiniModule'], meta: { name: 'MiniModule' } }
    /**
     * Find zero or one MiniModule that matches the filter.
     * @param {MiniModuleFindUniqueArgs} args - Arguments to find a MiniModule
     * @example
     * // Get one MiniModule
     * const miniModule = await prisma.miniModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MiniModuleFindUniqueArgs>(args: SelectSubset<T, MiniModuleFindUniqueArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MiniModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MiniModuleFindUniqueOrThrowArgs} args - Arguments to find a MiniModule
     * @example
     * // Get one MiniModule
     * const miniModule = await prisma.miniModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MiniModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, MiniModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MiniModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleFindFirstArgs} args - Arguments to find a MiniModule
     * @example
     * // Get one MiniModule
     * const miniModule = await prisma.miniModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MiniModuleFindFirstArgs>(args?: SelectSubset<T, MiniModuleFindFirstArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MiniModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleFindFirstOrThrowArgs} args - Arguments to find a MiniModule
     * @example
     * // Get one MiniModule
     * const miniModule = await prisma.miniModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MiniModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, MiniModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MiniModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MiniModules
     * const miniModules = await prisma.miniModule.findMany()
     * 
     * // Get first 10 MiniModules
     * const miniModules = await prisma.miniModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miniModuleWithIdOnly = await prisma.miniModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MiniModuleFindManyArgs>(args?: SelectSubset<T, MiniModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MiniModule.
     * @param {MiniModuleCreateArgs} args - Arguments to create a MiniModule.
     * @example
     * // Create one MiniModule
     * const MiniModule = await prisma.miniModule.create({
     *   data: {
     *     // ... data to create a MiniModule
     *   }
     * })
     * 
     */
    create<T extends MiniModuleCreateArgs>(args: SelectSubset<T, MiniModuleCreateArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MiniModules.
     * @param {MiniModuleCreateManyArgs} args - Arguments to create many MiniModules.
     * @example
     * // Create many MiniModules
     * const miniModule = await prisma.miniModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MiniModuleCreateManyArgs>(args?: SelectSubset<T, MiniModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MiniModules and returns the data saved in the database.
     * @param {MiniModuleCreateManyAndReturnArgs} args - Arguments to create many MiniModules.
     * @example
     * // Create many MiniModules
     * const miniModule = await prisma.miniModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MiniModules and only return the `id`
     * const miniModuleWithIdOnly = await prisma.miniModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MiniModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, MiniModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MiniModule.
     * @param {MiniModuleDeleteArgs} args - Arguments to delete one MiniModule.
     * @example
     * // Delete one MiniModule
     * const MiniModule = await prisma.miniModule.delete({
     *   where: {
     *     // ... filter to delete one MiniModule
     *   }
     * })
     * 
     */
    delete<T extends MiniModuleDeleteArgs>(args: SelectSubset<T, MiniModuleDeleteArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MiniModule.
     * @param {MiniModuleUpdateArgs} args - Arguments to update one MiniModule.
     * @example
     * // Update one MiniModule
     * const miniModule = await prisma.miniModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MiniModuleUpdateArgs>(args: SelectSubset<T, MiniModuleUpdateArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MiniModules.
     * @param {MiniModuleDeleteManyArgs} args - Arguments to filter MiniModules to delete.
     * @example
     * // Delete a few MiniModules
     * const { count } = await prisma.miniModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MiniModuleDeleteManyArgs>(args?: SelectSubset<T, MiniModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MiniModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MiniModules
     * const miniModule = await prisma.miniModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MiniModuleUpdateManyArgs>(args: SelectSubset<T, MiniModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MiniModules and returns the data updated in the database.
     * @param {MiniModuleUpdateManyAndReturnArgs} args - Arguments to update many MiniModules.
     * @example
     * // Update many MiniModules
     * const miniModule = await prisma.miniModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MiniModules and only return the `id`
     * const miniModuleWithIdOnly = await prisma.miniModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MiniModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, MiniModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MiniModule.
     * @param {MiniModuleUpsertArgs} args - Arguments to update or create a MiniModule.
     * @example
     * // Update or create a MiniModule
     * const miniModule = await prisma.miniModule.upsert({
     *   create: {
     *     // ... data to create a MiniModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MiniModule we want to update
     *   }
     * })
     */
    upsert<T extends MiniModuleUpsertArgs>(args: SelectSubset<T, MiniModuleUpsertArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MiniModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleCountArgs} args - Arguments to filter MiniModules to count.
     * @example
     * // Count the number of MiniModules
     * const count = await prisma.miniModule.count({
     *   where: {
     *     // ... the filter for the MiniModules we want to count
     *   }
     * })
    **/
    count<T extends MiniModuleCountArgs>(
      args?: Subset<T, MiniModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MiniModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MiniModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MiniModuleAggregateArgs>(args: Subset<T, MiniModuleAggregateArgs>): Prisma.PrismaPromise<GetMiniModuleAggregateType<T>>

    /**
     * Group by MiniModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MiniModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MiniModuleGroupByArgs['orderBy'] }
        : { orderBy?: MiniModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MiniModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiniModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MiniModule model
   */
  readonly fields: MiniModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MiniModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MiniModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseModule<T extends CourseModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseModuleDefaultArgs<ExtArgs>>): Prisma__CourseModuleClient<$Result.GetResult<Prisma.$CourseModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessons<T extends MiniModule$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, MiniModule$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonVideos<T extends MiniModule$lessonVideosArgs<ExtArgs> = {}>(args?: Subset<T, MiniModule$lessonVideosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends MiniModule$progressArgs<ExtArgs> = {}>(args?: Subset<T, MiniModule$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MiniModule model
   */
  interface MiniModuleFieldRefs {
    readonly id: FieldRef<"MiniModule", 'Int'>
    readonly courseModuleId: FieldRef<"MiniModule", 'Int'>
    readonly title: FieldRef<"MiniModule", 'String'>
    readonly number: FieldRef<"MiniModule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MiniModule findUnique
   */
  export type MiniModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * Filter, which MiniModule to fetch.
     */
    where: MiniModuleWhereUniqueInput
  }

  /**
   * MiniModule findUniqueOrThrow
   */
  export type MiniModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * Filter, which MiniModule to fetch.
     */
    where: MiniModuleWhereUniqueInput
  }

  /**
   * MiniModule findFirst
   */
  export type MiniModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * Filter, which MiniModule to fetch.
     */
    where?: MiniModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModules to fetch.
     */
    orderBy?: MiniModuleOrderByWithRelationInput | MiniModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MiniModules.
     */
    cursor?: MiniModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MiniModules.
     */
    distinct?: MiniModuleScalarFieldEnum | MiniModuleScalarFieldEnum[]
  }

  /**
   * MiniModule findFirstOrThrow
   */
  export type MiniModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * Filter, which MiniModule to fetch.
     */
    where?: MiniModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModules to fetch.
     */
    orderBy?: MiniModuleOrderByWithRelationInput | MiniModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MiniModules.
     */
    cursor?: MiniModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MiniModules.
     */
    distinct?: MiniModuleScalarFieldEnum | MiniModuleScalarFieldEnum[]
  }

  /**
   * MiniModule findMany
   */
  export type MiniModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * Filter, which MiniModules to fetch.
     */
    where?: MiniModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModules to fetch.
     */
    orderBy?: MiniModuleOrderByWithRelationInput | MiniModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MiniModules.
     */
    cursor?: MiniModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModules.
     */
    skip?: number
    distinct?: MiniModuleScalarFieldEnum | MiniModuleScalarFieldEnum[]
  }

  /**
   * MiniModule create
   */
  export type MiniModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a MiniModule.
     */
    data: XOR<MiniModuleCreateInput, MiniModuleUncheckedCreateInput>
  }

  /**
   * MiniModule createMany
   */
  export type MiniModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MiniModules.
     */
    data: MiniModuleCreateManyInput | MiniModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MiniModule createManyAndReturn
   */
  export type MiniModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * The data used to create many MiniModules.
     */
    data: MiniModuleCreateManyInput | MiniModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MiniModule update
   */
  export type MiniModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a MiniModule.
     */
    data: XOR<MiniModuleUpdateInput, MiniModuleUncheckedUpdateInput>
    /**
     * Choose, which MiniModule to update.
     */
    where: MiniModuleWhereUniqueInput
  }

  /**
   * MiniModule updateMany
   */
  export type MiniModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MiniModules.
     */
    data: XOR<MiniModuleUpdateManyMutationInput, MiniModuleUncheckedUpdateManyInput>
    /**
     * Filter which MiniModules to update
     */
    where?: MiniModuleWhereInput
    /**
     * Limit how many MiniModules to update.
     */
    limit?: number
  }

  /**
   * MiniModule updateManyAndReturn
   */
  export type MiniModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * The data used to update MiniModules.
     */
    data: XOR<MiniModuleUpdateManyMutationInput, MiniModuleUncheckedUpdateManyInput>
    /**
     * Filter which MiniModules to update
     */
    where?: MiniModuleWhereInput
    /**
     * Limit how many MiniModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MiniModule upsert
   */
  export type MiniModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the MiniModule to update in case it exists.
     */
    where: MiniModuleWhereUniqueInput
    /**
     * In case the MiniModule found by the `where` argument doesn't exist, create a new MiniModule with this data.
     */
    create: XOR<MiniModuleCreateInput, MiniModuleUncheckedCreateInput>
    /**
     * In case the MiniModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MiniModuleUpdateInput, MiniModuleUncheckedUpdateInput>
  }

  /**
   * MiniModule delete
   */
  export type MiniModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
    /**
     * Filter which MiniModule to delete.
     */
    where: MiniModuleWhereUniqueInput
  }

  /**
   * MiniModule deleteMany
   */
  export type MiniModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MiniModules to delete
     */
    where?: MiniModuleWhereInput
    /**
     * Limit how many MiniModules to delete.
     */
    limit?: number
  }

  /**
   * MiniModule.lessons
   */
  export type MiniModule$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * MiniModule.lessonVideos
   */
  export type MiniModule$lessonVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    where?: LessonVideoWhereInput
    orderBy?: LessonVideoOrderByWithRelationInput | LessonVideoOrderByWithRelationInput[]
    cursor?: LessonVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonVideoScalarFieldEnum | LessonVideoScalarFieldEnum[]
  }

  /**
   * MiniModule.progress
   */
  export type MiniModule$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    where?: MiniModuleProgressWhereInput
    orderBy?: MiniModuleProgressOrderByWithRelationInput | MiniModuleProgressOrderByWithRelationInput[]
    cursor?: MiniModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MiniModuleProgressScalarFieldEnum | MiniModuleProgressScalarFieldEnum[]
  }

  /**
   * MiniModule without action
   */
  export type MiniModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModule
     */
    select?: MiniModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModule
     */
    omit?: MiniModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleInclude<ExtArgs> | null
  }


  /**
   * Model MiniModuleProgress
   */

  export type AggregateMiniModuleProgress = {
    _count: MiniModuleProgressCountAggregateOutputType | null
    _avg: MiniModuleProgressAvgAggregateOutputType | null
    _sum: MiniModuleProgressSumAggregateOutputType | null
    _min: MiniModuleProgressMinAggregateOutputType | null
    _max: MiniModuleProgressMaxAggregateOutputType | null
  }

  export type MiniModuleProgressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    miniModuleId: number | null
    currentStep: number | null
  }

  export type MiniModuleProgressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    miniModuleId: number | null
    currentStep: number | null
  }

  export type MiniModuleProgressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    miniModuleId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
  }

  export type MiniModuleProgressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    miniModuleId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
  }

  export type MiniModuleProgressCountAggregateOutputType = {
    id: number
    userId: number
    miniModuleId: number
    currentStep: number
    completed: number
    startedAt: number
    updatedAt: number
    _all: number
  }


  export type MiniModuleProgressAvgAggregateInputType = {
    id?: true
    userId?: true
    miniModuleId?: true
    currentStep?: true
  }

  export type MiniModuleProgressSumAggregateInputType = {
    id?: true
    userId?: true
    miniModuleId?: true
    currentStep?: true
  }

  export type MiniModuleProgressMinAggregateInputType = {
    id?: true
    userId?: true
    miniModuleId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
  }

  export type MiniModuleProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    miniModuleId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
  }

  export type MiniModuleProgressCountAggregateInputType = {
    id?: true
    userId?: true
    miniModuleId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MiniModuleProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MiniModuleProgress to aggregate.
     */
    where?: MiniModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModuleProgresses to fetch.
     */
    orderBy?: MiniModuleProgressOrderByWithRelationInput | MiniModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MiniModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MiniModuleProgresses
    **/
    _count?: true | MiniModuleProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MiniModuleProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MiniModuleProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MiniModuleProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MiniModuleProgressMaxAggregateInputType
  }

  export type GetMiniModuleProgressAggregateType<T extends MiniModuleProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateMiniModuleProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiniModuleProgress[P]>
      : GetScalarType<T[P], AggregateMiniModuleProgress[P]>
  }




  export type MiniModuleProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MiniModuleProgressWhereInput
    orderBy?: MiniModuleProgressOrderByWithAggregationInput | MiniModuleProgressOrderByWithAggregationInput[]
    by: MiniModuleProgressScalarFieldEnum[] | MiniModuleProgressScalarFieldEnum
    having?: MiniModuleProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MiniModuleProgressCountAggregateInputType | true
    _avg?: MiniModuleProgressAvgAggregateInputType
    _sum?: MiniModuleProgressSumAggregateInputType
    _min?: MiniModuleProgressMinAggregateInputType
    _max?: MiniModuleProgressMaxAggregateInputType
  }

  export type MiniModuleProgressGroupByOutputType = {
    id: number
    userId: number
    miniModuleId: number
    currentStep: number
    completed: boolean
    startedAt: Date
    updatedAt: Date
    _count: MiniModuleProgressCountAggregateOutputType | null
    _avg: MiniModuleProgressAvgAggregateOutputType | null
    _sum: MiniModuleProgressSumAggregateOutputType | null
    _min: MiniModuleProgressMinAggregateOutputType | null
    _max: MiniModuleProgressMaxAggregateOutputType | null
  }

  type GetMiniModuleProgressGroupByPayload<T extends MiniModuleProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MiniModuleProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MiniModuleProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MiniModuleProgressGroupByOutputType[P]>
            : GetScalarType<T[P], MiniModuleProgressGroupByOutputType[P]>
        }
      >
    >


  export type MiniModuleProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    miniModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniModuleProgress"]>

  export type MiniModuleProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    miniModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniModuleProgress"]>

  export type MiniModuleProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    miniModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miniModuleProgress"]>

  export type MiniModuleProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    miniModuleId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
  }

  export type MiniModuleProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "miniModuleId" | "currentStep" | "completed" | "startedAt" | "updatedAt", ExtArgs["result"]["miniModuleProgress"]>
  export type MiniModuleProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }
  export type MiniModuleProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }
  export type MiniModuleProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }

  export type $MiniModuleProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MiniModuleProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      miniModule: Prisma.$MiniModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      miniModuleId: number
      currentStep: number
      completed: boolean
      startedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["miniModuleProgress"]>
    composites: {}
  }

  type MiniModuleProgressGetPayload<S extends boolean | null | undefined | MiniModuleProgressDefaultArgs> = $Result.GetResult<Prisma.$MiniModuleProgressPayload, S>

  type MiniModuleProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MiniModuleProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MiniModuleProgressCountAggregateInputType | true
    }

  export interface MiniModuleProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MiniModuleProgress'], meta: { name: 'MiniModuleProgress' } }
    /**
     * Find zero or one MiniModuleProgress that matches the filter.
     * @param {MiniModuleProgressFindUniqueArgs} args - Arguments to find a MiniModuleProgress
     * @example
     * // Get one MiniModuleProgress
     * const miniModuleProgress = await prisma.miniModuleProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MiniModuleProgressFindUniqueArgs>(args: SelectSubset<T, MiniModuleProgressFindUniqueArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MiniModuleProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MiniModuleProgressFindUniqueOrThrowArgs} args - Arguments to find a MiniModuleProgress
     * @example
     * // Get one MiniModuleProgress
     * const miniModuleProgress = await prisma.miniModuleProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MiniModuleProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, MiniModuleProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MiniModuleProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleProgressFindFirstArgs} args - Arguments to find a MiniModuleProgress
     * @example
     * // Get one MiniModuleProgress
     * const miniModuleProgress = await prisma.miniModuleProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MiniModuleProgressFindFirstArgs>(args?: SelectSubset<T, MiniModuleProgressFindFirstArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MiniModuleProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleProgressFindFirstOrThrowArgs} args - Arguments to find a MiniModuleProgress
     * @example
     * // Get one MiniModuleProgress
     * const miniModuleProgress = await prisma.miniModuleProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MiniModuleProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, MiniModuleProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MiniModuleProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MiniModuleProgresses
     * const miniModuleProgresses = await prisma.miniModuleProgress.findMany()
     * 
     * // Get first 10 MiniModuleProgresses
     * const miniModuleProgresses = await prisma.miniModuleProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miniModuleProgressWithIdOnly = await prisma.miniModuleProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MiniModuleProgressFindManyArgs>(args?: SelectSubset<T, MiniModuleProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MiniModuleProgress.
     * @param {MiniModuleProgressCreateArgs} args - Arguments to create a MiniModuleProgress.
     * @example
     * // Create one MiniModuleProgress
     * const MiniModuleProgress = await prisma.miniModuleProgress.create({
     *   data: {
     *     // ... data to create a MiniModuleProgress
     *   }
     * })
     * 
     */
    create<T extends MiniModuleProgressCreateArgs>(args: SelectSubset<T, MiniModuleProgressCreateArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MiniModuleProgresses.
     * @param {MiniModuleProgressCreateManyArgs} args - Arguments to create many MiniModuleProgresses.
     * @example
     * // Create many MiniModuleProgresses
     * const miniModuleProgress = await prisma.miniModuleProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MiniModuleProgressCreateManyArgs>(args?: SelectSubset<T, MiniModuleProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MiniModuleProgresses and returns the data saved in the database.
     * @param {MiniModuleProgressCreateManyAndReturnArgs} args - Arguments to create many MiniModuleProgresses.
     * @example
     * // Create many MiniModuleProgresses
     * const miniModuleProgress = await prisma.miniModuleProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MiniModuleProgresses and only return the `id`
     * const miniModuleProgressWithIdOnly = await prisma.miniModuleProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MiniModuleProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, MiniModuleProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MiniModuleProgress.
     * @param {MiniModuleProgressDeleteArgs} args - Arguments to delete one MiniModuleProgress.
     * @example
     * // Delete one MiniModuleProgress
     * const MiniModuleProgress = await prisma.miniModuleProgress.delete({
     *   where: {
     *     // ... filter to delete one MiniModuleProgress
     *   }
     * })
     * 
     */
    delete<T extends MiniModuleProgressDeleteArgs>(args: SelectSubset<T, MiniModuleProgressDeleteArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MiniModuleProgress.
     * @param {MiniModuleProgressUpdateArgs} args - Arguments to update one MiniModuleProgress.
     * @example
     * // Update one MiniModuleProgress
     * const miniModuleProgress = await prisma.miniModuleProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MiniModuleProgressUpdateArgs>(args: SelectSubset<T, MiniModuleProgressUpdateArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MiniModuleProgresses.
     * @param {MiniModuleProgressDeleteManyArgs} args - Arguments to filter MiniModuleProgresses to delete.
     * @example
     * // Delete a few MiniModuleProgresses
     * const { count } = await prisma.miniModuleProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MiniModuleProgressDeleteManyArgs>(args?: SelectSubset<T, MiniModuleProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MiniModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MiniModuleProgresses
     * const miniModuleProgress = await prisma.miniModuleProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MiniModuleProgressUpdateManyArgs>(args: SelectSubset<T, MiniModuleProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MiniModuleProgresses and returns the data updated in the database.
     * @param {MiniModuleProgressUpdateManyAndReturnArgs} args - Arguments to update many MiniModuleProgresses.
     * @example
     * // Update many MiniModuleProgresses
     * const miniModuleProgress = await prisma.miniModuleProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MiniModuleProgresses and only return the `id`
     * const miniModuleProgressWithIdOnly = await prisma.miniModuleProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MiniModuleProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, MiniModuleProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MiniModuleProgress.
     * @param {MiniModuleProgressUpsertArgs} args - Arguments to update or create a MiniModuleProgress.
     * @example
     * // Update or create a MiniModuleProgress
     * const miniModuleProgress = await prisma.miniModuleProgress.upsert({
     *   create: {
     *     // ... data to create a MiniModuleProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MiniModuleProgress we want to update
     *   }
     * })
     */
    upsert<T extends MiniModuleProgressUpsertArgs>(args: SelectSubset<T, MiniModuleProgressUpsertArgs<ExtArgs>>): Prisma__MiniModuleProgressClient<$Result.GetResult<Prisma.$MiniModuleProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MiniModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleProgressCountArgs} args - Arguments to filter MiniModuleProgresses to count.
     * @example
     * // Count the number of MiniModuleProgresses
     * const count = await prisma.miniModuleProgress.count({
     *   where: {
     *     // ... the filter for the MiniModuleProgresses we want to count
     *   }
     * })
    **/
    count<T extends MiniModuleProgressCountArgs>(
      args?: Subset<T, MiniModuleProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MiniModuleProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MiniModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MiniModuleProgressAggregateArgs>(args: Subset<T, MiniModuleProgressAggregateArgs>): Prisma.PrismaPromise<GetMiniModuleProgressAggregateType<T>>

    /**
     * Group by MiniModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiniModuleProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MiniModuleProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MiniModuleProgressGroupByArgs['orderBy'] }
        : { orderBy?: MiniModuleProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MiniModuleProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiniModuleProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MiniModuleProgress model
   */
  readonly fields: MiniModuleProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MiniModuleProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MiniModuleProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    miniModule<T extends MiniModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MiniModuleDefaultArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MiniModuleProgress model
   */
  interface MiniModuleProgressFieldRefs {
    readonly id: FieldRef<"MiniModuleProgress", 'Int'>
    readonly userId: FieldRef<"MiniModuleProgress", 'Int'>
    readonly miniModuleId: FieldRef<"MiniModuleProgress", 'Int'>
    readonly currentStep: FieldRef<"MiniModuleProgress", 'Int'>
    readonly completed: FieldRef<"MiniModuleProgress", 'Boolean'>
    readonly startedAt: FieldRef<"MiniModuleProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"MiniModuleProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MiniModuleProgress findUnique
   */
  export type MiniModuleProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which MiniModuleProgress to fetch.
     */
    where: MiniModuleProgressWhereUniqueInput
  }

  /**
   * MiniModuleProgress findUniqueOrThrow
   */
  export type MiniModuleProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which MiniModuleProgress to fetch.
     */
    where: MiniModuleProgressWhereUniqueInput
  }

  /**
   * MiniModuleProgress findFirst
   */
  export type MiniModuleProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which MiniModuleProgress to fetch.
     */
    where?: MiniModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModuleProgresses to fetch.
     */
    orderBy?: MiniModuleProgressOrderByWithRelationInput | MiniModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MiniModuleProgresses.
     */
    cursor?: MiniModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MiniModuleProgresses.
     */
    distinct?: MiniModuleProgressScalarFieldEnum | MiniModuleProgressScalarFieldEnum[]
  }

  /**
   * MiniModuleProgress findFirstOrThrow
   */
  export type MiniModuleProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which MiniModuleProgress to fetch.
     */
    where?: MiniModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModuleProgresses to fetch.
     */
    orderBy?: MiniModuleProgressOrderByWithRelationInput | MiniModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MiniModuleProgresses.
     */
    cursor?: MiniModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MiniModuleProgresses.
     */
    distinct?: MiniModuleProgressScalarFieldEnum | MiniModuleProgressScalarFieldEnum[]
  }

  /**
   * MiniModuleProgress findMany
   */
  export type MiniModuleProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which MiniModuleProgresses to fetch.
     */
    where?: MiniModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiniModuleProgresses to fetch.
     */
    orderBy?: MiniModuleProgressOrderByWithRelationInput | MiniModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MiniModuleProgresses.
     */
    cursor?: MiniModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiniModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiniModuleProgresses.
     */
    skip?: number
    distinct?: MiniModuleProgressScalarFieldEnum | MiniModuleProgressScalarFieldEnum[]
  }

  /**
   * MiniModuleProgress create
   */
  export type MiniModuleProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a MiniModuleProgress.
     */
    data: XOR<MiniModuleProgressCreateInput, MiniModuleProgressUncheckedCreateInput>
  }

  /**
   * MiniModuleProgress createMany
   */
  export type MiniModuleProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MiniModuleProgresses.
     */
    data: MiniModuleProgressCreateManyInput | MiniModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MiniModuleProgress createManyAndReturn
   */
  export type MiniModuleProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * The data used to create many MiniModuleProgresses.
     */
    data: MiniModuleProgressCreateManyInput | MiniModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MiniModuleProgress update
   */
  export type MiniModuleProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a MiniModuleProgress.
     */
    data: XOR<MiniModuleProgressUpdateInput, MiniModuleProgressUncheckedUpdateInput>
    /**
     * Choose, which MiniModuleProgress to update.
     */
    where: MiniModuleProgressWhereUniqueInput
  }

  /**
   * MiniModuleProgress updateMany
   */
  export type MiniModuleProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MiniModuleProgresses.
     */
    data: XOR<MiniModuleProgressUpdateManyMutationInput, MiniModuleProgressUncheckedUpdateManyInput>
    /**
     * Filter which MiniModuleProgresses to update
     */
    where?: MiniModuleProgressWhereInput
    /**
     * Limit how many MiniModuleProgresses to update.
     */
    limit?: number
  }

  /**
   * MiniModuleProgress updateManyAndReturn
   */
  export type MiniModuleProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * The data used to update MiniModuleProgresses.
     */
    data: XOR<MiniModuleProgressUpdateManyMutationInput, MiniModuleProgressUncheckedUpdateManyInput>
    /**
     * Filter which MiniModuleProgresses to update
     */
    where?: MiniModuleProgressWhereInput
    /**
     * Limit how many MiniModuleProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MiniModuleProgress upsert
   */
  export type MiniModuleProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the MiniModuleProgress to update in case it exists.
     */
    where: MiniModuleProgressWhereUniqueInput
    /**
     * In case the MiniModuleProgress found by the `where` argument doesn't exist, create a new MiniModuleProgress with this data.
     */
    create: XOR<MiniModuleProgressCreateInput, MiniModuleProgressUncheckedCreateInput>
    /**
     * In case the MiniModuleProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MiniModuleProgressUpdateInput, MiniModuleProgressUncheckedUpdateInput>
  }

  /**
   * MiniModuleProgress delete
   */
  export type MiniModuleProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
    /**
     * Filter which MiniModuleProgress to delete.
     */
    where: MiniModuleProgressWhereUniqueInput
  }

  /**
   * MiniModuleProgress deleteMany
   */
  export type MiniModuleProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MiniModuleProgresses to delete
     */
    where?: MiniModuleProgressWhereInput
    /**
     * Limit how many MiniModuleProgresses to delete.
     */
    limit?: number
  }

  /**
   * MiniModuleProgress without action
   */
  export type MiniModuleProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiniModuleProgress
     */
    select?: MiniModuleProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiniModuleProgress
     */
    omit?: MiniModuleProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiniModuleProgressInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    id: number | null
    number: number | null
    miniModuleId: number | null
  }

  export type LessonSumAggregateOutputType = {
    id: number | null
    number: number | null
    miniModuleId: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: number | null
    title: string | null
    explanation: string | null
    more: string | null
    example: string | null
    note: string | null
    assignment: string | null
    number: number | null
    miniModuleId: number | null
  }

  export type LessonMaxAggregateOutputType = {
    id: number | null
    title: string | null
    explanation: string | null
    more: string | null
    example: string | null
    note: string | null
    assignment: string | null
    number: number | null
    miniModuleId: number | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    explanation: number
    more: number
    example: number
    note: number
    assignment: number
    number: number
    miniModuleId: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    id?: true
    number?: true
    miniModuleId?: true
  }

  export type LessonSumAggregateInputType = {
    id?: true
    number?: true
    miniModuleId?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    explanation?: true
    more?: true
    example?: true
    note?: true
    assignment?: true
    number?: true
    miniModuleId?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    explanation?: true
    more?: true
    example?: true
    note?: true
    assignment?: true
    number?: true
    miniModuleId?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    explanation?: true
    more?: true
    example?: true
    note?: true
    assignment?: true
    number?: true
    miniModuleId?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: number
    title: string
    explanation: string
    more: string | null
    example: string | null
    note: string | null
    assignment: string
    number: number
    miniModuleId: number
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    explanation?: boolean
    more?: boolean
    example?: boolean
    note?: boolean
    assignment?: boolean
    number?: boolean
    miniModuleId?: boolean
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
    solutions?: boolean | Lesson$solutionsArgs<ExtArgs>
    progress?: boolean | Lesson$progressArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    explanation?: boolean
    more?: boolean
    example?: boolean
    note?: boolean
    assignment?: boolean
    number?: boolean
    miniModuleId?: boolean
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    explanation?: boolean
    more?: boolean
    example?: boolean
    note?: boolean
    assignment?: boolean
    number?: boolean
    miniModuleId?: boolean
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    title?: boolean
    explanation?: boolean
    more?: boolean
    example?: boolean
    note?: boolean
    assignment?: boolean
    number?: boolean
    miniModuleId?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "explanation" | "more" | "example" | "note" | "assignment" | "number" | "miniModuleId", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
    solutions?: boolean | Lesson$solutionsArgs<ExtArgs>
    progress?: boolean | Lesson$progressArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      miniModule: Prisma.$MiniModulePayload<ExtArgs>
      solutions: Prisma.$LessonSolutionPayload<ExtArgs>[]
      progress: Prisma.$UserLessonProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      explanation: string
      more: string | null
      example: string | null
      note: string | null
      assignment: string
      number: number
      miniModuleId: number
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    miniModule<T extends MiniModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MiniModuleDefaultArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    solutions<T extends Lesson$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends Lesson$progressArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'Int'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly explanation: FieldRef<"Lesson", 'String'>
    readonly more: FieldRef<"Lesson", 'String'>
    readonly example: FieldRef<"Lesson", 'String'>
    readonly note: FieldRef<"Lesson", 'String'>
    readonly assignment: FieldRef<"Lesson", 'String'>
    readonly number: FieldRef<"Lesson", 'Int'>
    readonly miniModuleId: FieldRef<"Lesson", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.solutions
   */
  export type Lesson$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    where?: LessonSolutionWhereInput
    orderBy?: LessonSolutionOrderByWithRelationInput | LessonSolutionOrderByWithRelationInput[]
    cursor?: LessonSolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonSolutionScalarFieldEnum | LessonSolutionScalarFieldEnum[]
  }

  /**
   * Lesson.progress
   */
  export type Lesson$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    where?: UserLessonProgressWhereInput
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    cursor?: UserLessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model LessonVideo
   */

  export type AggregateLessonVideo = {
    _count: LessonVideoCountAggregateOutputType | null
    _avg: LessonVideoAvgAggregateOutputType | null
    _sum: LessonVideoSumAggregateOutputType | null
    _min: LessonVideoMinAggregateOutputType | null
    _max: LessonVideoMaxAggregateOutputType | null
  }

  export type LessonVideoAvgAggregateOutputType = {
    id: number | null
    number: number | null
    miniModuleId: number | null
  }

  export type LessonVideoSumAggregateOutputType = {
    id: number | null
    number: number | null
    miniModuleId: number | null
  }

  export type LessonVideoMinAggregateOutputType = {
    id: number | null
    title: string | null
    number: number | null
    url: string | null
    miniModuleId: number | null
  }

  export type LessonVideoMaxAggregateOutputType = {
    id: number | null
    title: string | null
    number: number | null
    url: string | null
    miniModuleId: number | null
  }

  export type LessonVideoCountAggregateOutputType = {
    id: number
    title: number
    number: number
    url: number
    miniModuleId: number
    _all: number
  }


  export type LessonVideoAvgAggregateInputType = {
    id?: true
    number?: true
    miniModuleId?: true
  }

  export type LessonVideoSumAggregateInputType = {
    id?: true
    number?: true
    miniModuleId?: true
  }

  export type LessonVideoMinAggregateInputType = {
    id?: true
    title?: true
    number?: true
    url?: true
    miniModuleId?: true
  }

  export type LessonVideoMaxAggregateInputType = {
    id?: true
    title?: true
    number?: true
    url?: true
    miniModuleId?: true
  }

  export type LessonVideoCountAggregateInputType = {
    id?: true
    title?: true
    number?: true
    url?: true
    miniModuleId?: true
    _all?: true
  }

  export type LessonVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonVideo to aggregate.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: LessonVideoOrderByWithRelationInput | LessonVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonVideos
    **/
    _count?: true | LessonVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonVideoMaxAggregateInputType
  }

  export type GetLessonVideoAggregateType<T extends LessonVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonVideo[P]>
      : GetScalarType<T[P], AggregateLessonVideo[P]>
  }




  export type LessonVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonVideoWhereInput
    orderBy?: LessonVideoOrderByWithAggregationInput | LessonVideoOrderByWithAggregationInput[]
    by: LessonVideoScalarFieldEnum[] | LessonVideoScalarFieldEnum
    having?: LessonVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonVideoCountAggregateInputType | true
    _avg?: LessonVideoAvgAggregateInputType
    _sum?: LessonVideoSumAggregateInputType
    _min?: LessonVideoMinAggregateInputType
    _max?: LessonVideoMaxAggregateInputType
  }

  export type LessonVideoGroupByOutputType = {
    id: number
    title: string
    number: number
    url: string
    miniModuleId: number
    _count: LessonVideoCountAggregateOutputType | null
    _avg: LessonVideoAvgAggregateOutputType | null
    _sum: LessonVideoSumAggregateOutputType | null
    _min: LessonVideoMinAggregateOutputType | null
    _max: LessonVideoMaxAggregateOutputType | null
  }

  type GetLessonVideoGroupByPayload<T extends LessonVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonVideoGroupByOutputType[P]>
            : GetScalarType<T[P], LessonVideoGroupByOutputType[P]>
        }
      >
    >


  export type LessonVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
    miniModuleId?: boolean
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonVideo"]>

  export type LessonVideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
    miniModuleId?: boolean
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonVideo"]>

  export type LessonVideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
    miniModuleId?: boolean
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonVideo"]>

  export type LessonVideoSelectScalar = {
    id?: boolean
    title?: boolean
    number?: boolean
    url?: boolean
    miniModuleId?: boolean
  }

  export type LessonVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "number" | "url" | "miniModuleId", ExtArgs["result"]["lessonVideo"]>
  export type LessonVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }
  export type LessonVideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }
  export type LessonVideoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miniModule?: boolean | MiniModuleDefaultArgs<ExtArgs>
  }

  export type $LessonVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonVideo"
    objects: {
      miniModule: Prisma.$MiniModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      number: number
      url: string
      miniModuleId: number
    }, ExtArgs["result"]["lessonVideo"]>
    composites: {}
  }

  type LessonVideoGetPayload<S extends boolean | null | undefined | LessonVideoDefaultArgs> = $Result.GetResult<Prisma.$LessonVideoPayload, S>

  type LessonVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonVideoCountAggregateInputType | true
    }

  export interface LessonVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonVideo'], meta: { name: 'LessonVideo' } }
    /**
     * Find zero or one LessonVideo that matches the filter.
     * @param {LessonVideoFindUniqueArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonVideoFindUniqueArgs>(args: SelectSubset<T, LessonVideoFindUniqueArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonVideoFindUniqueOrThrowArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoFindFirstArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonVideoFindFirstArgs>(args?: SelectSubset<T, LessonVideoFindFirstArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoFindFirstOrThrowArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonVideos
     * const lessonVideos = await prisma.lessonVideo.findMany()
     * 
     * // Get first 10 LessonVideos
     * const lessonVideos = await prisma.lessonVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonVideoWithIdOnly = await prisma.lessonVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonVideoFindManyArgs>(args?: SelectSubset<T, LessonVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonVideo.
     * @param {LessonVideoCreateArgs} args - Arguments to create a LessonVideo.
     * @example
     * // Create one LessonVideo
     * const LessonVideo = await prisma.lessonVideo.create({
     *   data: {
     *     // ... data to create a LessonVideo
     *   }
     * })
     * 
     */
    create<T extends LessonVideoCreateArgs>(args: SelectSubset<T, LessonVideoCreateArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonVideos.
     * @param {LessonVideoCreateManyArgs} args - Arguments to create many LessonVideos.
     * @example
     * // Create many LessonVideos
     * const lessonVideo = await prisma.lessonVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonVideoCreateManyArgs>(args?: SelectSubset<T, LessonVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonVideos and returns the data saved in the database.
     * @param {LessonVideoCreateManyAndReturnArgs} args - Arguments to create many LessonVideos.
     * @example
     * // Create many LessonVideos
     * const lessonVideo = await prisma.lessonVideo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonVideos and only return the `id`
     * const lessonVideoWithIdOnly = await prisma.lessonVideo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonVideoCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonVideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonVideo.
     * @param {LessonVideoDeleteArgs} args - Arguments to delete one LessonVideo.
     * @example
     * // Delete one LessonVideo
     * const LessonVideo = await prisma.lessonVideo.delete({
     *   where: {
     *     // ... filter to delete one LessonVideo
     *   }
     * })
     * 
     */
    delete<T extends LessonVideoDeleteArgs>(args: SelectSubset<T, LessonVideoDeleteArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonVideo.
     * @param {LessonVideoUpdateArgs} args - Arguments to update one LessonVideo.
     * @example
     * // Update one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonVideoUpdateArgs>(args: SelectSubset<T, LessonVideoUpdateArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonVideos.
     * @param {LessonVideoDeleteManyArgs} args - Arguments to filter LessonVideos to delete.
     * @example
     * // Delete a few LessonVideos
     * const { count } = await prisma.lessonVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonVideoDeleteManyArgs>(args?: SelectSubset<T, LessonVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonVideos
     * const lessonVideo = await prisma.lessonVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonVideoUpdateManyArgs>(args: SelectSubset<T, LessonVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonVideos and returns the data updated in the database.
     * @param {LessonVideoUpdateManyAndReturnArgs} args - Arguments to update many LessonVideos.
     * @example
     * // Update many LessonVideos
     * const lessonVideo = await prisma.lessonVideo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonVideos and only return the `id`
     * const lessonVideoWithIdOnly = await prisma.lessonVideo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonVideoUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonVideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonVideo.
     * @param {LessonVideoUpsertArgs} args - Arguments to update or create a LessonVideo.
     * @example
     * // Update or create a LessonVideo
     * const lessonVideo = await prisma.lessonVideo.upsert({
     *   create: {
     *     // ... data to create a LessonVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonVideo we want to update
     *   }
     * })
     */
    upsert<T extends LessonVideoUpsertArgs>(args: SelectSubset<T, LessonVideoUpsertArgs<ExtArgs>>): Prisma__LessonVideoClient<$Result.GetResult<Prisma.$LessonVideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoCountArgs} args - Arguments to filter LessonVideos to count.
     * @example
     * // Count the number of LessonVideos
     * const count = await prisma.lessonVideo.count({
     *   where: {
     *     // ... the filter for the LessonVideos we want to count
     *   }
     * })
    **/
    count<T extends LessonVideoCountArgs>(
      args?: Subset<T, LessonVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonVideoAggregateArgs>(args: Subset<T, LessonVideoAggregateArgs>): Prisma.PrismaPromise<GetLessonVideoAggregateType<T>>

    /**
     * Group by LessonVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonVideoGroupByArgs['orderBy'] }
        : { orderBy?: LessonVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonVideo model
   */
  readonly fields: LessonVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    miniModule<T extends MiniModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MiniModuleDefaultArgs<ExtArgs>>): Prisma__MiniModuleClient<$Result.GetResult<Prisma.$MiniModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonVideo model
   */
  interface LessonVideoFieldRefs {
    readonly id: FieldRef<"LessonVideo", 'Int'>
    readonly title: FieldRef<"LessonVideo", 'String'>
    readonly number: FieldRef<"LessonVideo", 'Int'>
    readonly url: FieldRef<"LessonVideo", 'String'>
    readonly miniModuleId: FieldRef<"LessonVideo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LessonVideo findUnique
   */
  export type LessonVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where: LessonVideoWhereUniqueInput
  }

  /**
   * LessonVideo findUniqueOrThrow
   */
  export type LessonVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where: LessonVideoWhereUniqueInput
  }

  /**
   * LessonVideo findFirst
   */
  export type LessonVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: LessonVideoOrderByWithRelationInput | LessonVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonVideos.
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonVideos.
     */
    distinct?: LessonVideoScalarFieldEnum | LessonVideoScalarFieldEnum[]
  }

  /**
   * LessonVideo findFirstOrThrow
   */
  export type LessonVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: LessonVideoOrderByWithRelationInput | LessonVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonVideos.
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonVideos.
     */
    distinct?: LessonVideoScalarFieldEnum | LessonVideoScalarFieldEnum[]
  }

  /**
   * LessonVideo findMany
   */
  export type LessonVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideos to fetch.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: LessonVideoOrderByWithRelationInput | LessonVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonVideos.
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    distinct?: LessonVideoScalarFieldEnum | LessonVideoScalarFieldEnum[]
  }

  /**
   * LessonVideo create
   */
  export type LessonVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonVideo.
     */
    data: XOR<LessonVideoCreateInput, LessonVideoUncheckedCreateInput>
  }

  /**
   * LessonVideo createMany
   */
  export type LessonVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonVideos.
     */
    data: LessonVideoCreateManyInput | LessonVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonVideo createManyAndReturn
   */
  export type LessonVideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * The data used to create many LessonVideos.
     */
    data: LessonVideoCreateManyInput | LessonVideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonVideo update
   */
  export type LessonVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonVideo.
     */
    data: XOR<LessonVideoUpdateInput, LessonVideoUncheckedUpdateInput>
    /**
     * Choose, which LessonVideo to update.
     */
    where: LessonVideoWhereUniqueInput
  }

  /**
   * LessonVideo updateMany
   */
  export type LessonVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonVideos.
     */
    data: XOR<LessonVideoUpdateManyMutationInput, LessonVideoUncheckedUpdateManyInput>
    /**
     * Filter which LessonVideos to update
     */
    where?: LessonVideoWhereInput
    /**
     * Limit how many LessonVideos to update.
     */
    limit?: number
  }

  /**
   * LessonVideo updateManyAndReturn
   */
  export type LessonVideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * The data used to update LessonVideos.
     */
    data: XOR<LessonVideoUpdateManyMutationInput, LessonVideoUncheckedUpdateManyInput>
    /**
     * Filter which LessonVideos to update
     */
    where?: LessonVideoWhereInput
    /**
     * Limit how many LessonVideos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonVideo upsert
   */
  export type LessonVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonVideo to update in case it exists.
     */
    where: LessonVideoWhereUniqueInput
    /**
     * In case the LessonVideo found by the `where` argument doesn't exist, create a new LessonVideo with this data.
     */
    create: XOR<LessonVideoCreateInput, LessonVideoUncheckedCreateInput>
    /**
     * In case the LessonVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonVideoUpdateInput, LessonVideoUncheckedUpdateInput>
  }

  /**
   * LessonVideo delete
   */
  export type LessonVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter which LessonVideo to delete.
     */
    where: LessonVideoWhereUniqueInput
  }

  /**
   * LessonVideo deleteMany
   */
  export type LessonVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonVideos to delete
     */
    where?: LessonVideoWhereInput
    /**
     * Limit how many LessonVideos to delete.
     */
    limit?: number
  }

  /**
   * LessonVideo without action
   */
  export type LessonVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonVideo
     */
    omit?: LessonVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonVideoInclude<ExtArgs> | null
  }


  /**
   * Model LessonSolution
   */

  export type AggregateLessonSolution = {
    _count: LessonSolutionCountAggregateOutputType | null
    _avg: LessonSolutionAvgAggregateOutputType | null
    _sum: LessonSolutionSumAggregateOutputType | null
    _min: LessonSolutionMinAggregateOutputType | null
    _max: LessonSolutionMaxAggregateOutputType | null
  }

  export type LessonSolutionAvgAggregateOutputType = {
    id: number | null
    lessonId: number | null
  }

  export type LessonSolutionSumAggregateOutputType = {
    id: number | null
    lessonId: number | null
  }

  export type LessonSolutionMinAggregateOutputType = {
    id: number | null
    solution: string | null
    lessonId: number | null
  }

  export type LessonSolutionMaxAggregateOutputType = {
    id: number | null
    solution: string | null
    lessonId: number | null
  }

  export type LessonSolutionCountAggregateOutputType = {
    id: number
    solution: number
    lessonId: number
    _all: number
  }


  export type LessonSolutionAvgAggregateInputType = {
    id?: true
    lessonId?: true
  }

  export type LessonSolutionSumAggregateInputType = {
    id?: true
    lessonId?: true
  }

  export type LessonSolutionMinAggregateInputType = {
    id?: true
    solution?: true
    lessonId?: true
  }

  export type LessonSolutionMaxAggregateInputType = {
    id?: true
    solution?: true
    lessonId?: true
  }

  export type LessonSolutionCountAggregateInputType = {
    id?: true
    solution?: true
    lessonId?: true
    _all?: true
  }

  export type LessonSolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonSolution to aggregate.
     */
    where?: LessonSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSolutions to fetch.
     */
    orderBy?: LessonSolutionOrderByWithRelationInput | LessonSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonSolutions
    **/
    _count?: true | LessonSolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonSolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonSolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonSolutionMaxAggregateInputType
  }

  export type GetLessonSolutionAggregateType<T extends LessonSolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonSolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonSolution[P]>
      : GetScalarType<T[P], AggregateLessonSolution[P]>
  }




  export type LessonSolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonSolutionWhereInput
    orderBy?: LessonSolutionOrderByWithAggregationInput | LessonSolutionOrderByWithAggregationInput[]
    by: LessonSolutionScalarFieldEnum[] | LessonSolutionScalarFieldEnum
    having?: LessonSolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonSolutionCountAggregateInputType | true
    _avg?: LessonSolutionAvgAggregateInputType
    _sum?: LessonSolutionSumAggregateInputType
    _min?: LessonSolutionMinAggregateInputType
    _max?: LessonSolutionMaxAggregateInputType
  }

  export type LessonSolutionGroupByOutputType = {
    id: number
    solution: string
    lessonId: number
    _count: LessonSolutionCountAggregateOutputType | null
    _avg: LessonSolutionAvgAggregateOutputType | null
    _sum: LessonSolutionSumAggregateOutputType | null
    _min: LessonSolutionMinAggregateOutputType | null
    _max: LessonSolutionMaxAggregateOutputType | null
  }

  type GetLessonSolutionGroupByPayload<T extends LessonSolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonSolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonSolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonSolutionGroupByOutputType[P]>
            : GetScalarType<T[P], LessonSolutionGroupByOutputType[P]>
        }
      >
    >


  export type LessonSolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solution?: boolean
    lessonId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonSolution"]>

  export type LessonSolutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solution?: boolean
    lessonId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonSolution"]>

  export type LessonSolutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    solution?: boolean
    lessonId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonSolution"]>

  export type LessonSolutionSelectScalar = {
    id?: boolean
    solution?: boolean
    lessonId?: boolean
  }

  export type LessonSolutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "solution" | "lessonId", ExtArgs["result"]["lessonSolution"]>
  export type LessonSolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonSolutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonSolutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $LessonSolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonSolution"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      solution: string
      lessonId: number
    }, ExtArgs["result"]["lessonSolution"]>
    composites: {}
  }

  type LessonSolutionGetPayload<S extends boolean | null | undefined | LessonSolutionDefaultArgs> = $Result.GetResult<Prisma.$LessonSolutionPayload, S>

  type LessonSolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonSolutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonSolutionCountAggregateInputType | true
    }

  export interface LessonSolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonSolution'], meta: { name: 'LessonSolution' } }
    /**
     * Find zero or one LessonSolution that matches the filter.
     * @param {LessonSolutionFindUniqueArgs} args - Arguments to find a LessonSolution
     * @example
     * // Get one LessonSolution
     * const lessonSolution = await prisma.lessonSolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonSolutionFindUniqueArgs>(args: SelectSubset<T, LessonSolutionFindUniqueArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonSolution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonSolutionFindUniqueOrThrowArgs} args - Arguments to find a LessonSolution
     * @example
     * // Get one LessonSolution
     * const lessonSolution = await prisma.lessonSolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonSolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonSolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonSolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonSolutionFindFirstArgs} args - Arguments to find a LessonSolution
     * @example
     * // Get one LessonSolution
     * const lessonSolution = await prisma.lessonSolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonSolutionFindFirstArgs>(args?: SelectSubset<T, LessonSolutionFindFirstArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonSolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonSolutionFindFirstOrThrowArgs} args - Arguments to find a LessonSolution
     * @example
     * // Get one LessonSolution
     * const lessonSolution = await prisma.lessonSolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonSolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonSolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonSolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonSolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonSolutions
     * const lessonSolutions = await prisma.lessonSolution.findMany()
     * 
     * // Get first 10 LessonSolutions
     * const lessonSolutions = await prisma.lessonSolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonSolutionWithIdOnly = await prisma.lessonSolution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonSolutionFindManyArgs>(args?: SelectSubset<T, LessonSolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonSolution.
     * @param {LessonSolutionCreateArgs} args - Arguments to create a LessonSolution.
     * @example
     * // Create one LessonSolution
     * const LessonSolution = await prisma.lessonSolution.create({
     *   data: {
     *     // ... data to create a LessonSolution
     *   }
     * })
     * 
     */
    create<T extends LessonSolutionCreateArgs>(args: SelectSubset<T, LessonSolutionCreateArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonSolutions.
     * @param {LessonSolutionCreateManyArgs} args - Arguments to create many LessonSolutions.
     * @example
     * // Create many LessonSolutions
     * const lessonSolution = await prisma.lessonSolution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonSolutionCreateManyArgs>(args?: SelectSubset<T, LessonSolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonSolutions and returns the data saved in the database.
     * @param {LessonSolutionCreateManyAndReturnArgs} args - Arguments to create many LessonSolutions.
     * @example
     * // Create many LessonSolutions
     * const lessonSolution = await prisma.lessonSolution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonSolutions and only return the `id`
     * const lessonSolutionWithIdOnly = await prisma.lessonSolution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonSolutionCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonSolutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonSolution.
     * @param {LessonSolutionDeleteArgs} args - Arguments to delete one LessonSolution.
     * @example
     * // Delete one LessonSolution
     * const LessonSolution = await prisma.lessonSolution.delete({
     *   where: {
     *     // ... filter to delete one LessonSolution
     *   }
     * })
     * 
     */
    delete<T extends LessonSolutionDeleteArgs>(args: SelectSubset<T, LessonSolutionDeleteArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonSolution.
     * @param {LessonSolutionUpdateArgs} args - Arguments to update one LessonSolution.
     * @example
     * // Update one LessonSolution
     * const lessonSolution = await prisma.lessonSolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonSolutionUpdateArgs>(args: SelectSubset<T, LessonSolutionUpdateArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonSolutions.
     * @param {LessonSolutionDeleteManyArgs} args - Arguments to filter LessonSolutions to delete.
     * @example
     * // Delete a few LessonSolutions
     * const { count } = await prisma.lessonSolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonSolutionDeleteManyArgs>(args?: SelectSubset<T, LessonSolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonSolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonSolutions
     * const lessonSolution = await prisma.lessonSolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonSolutionUpdateManyArgs>(args: SelectSubset<T, LessonSolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonSolutions and returns the data updated in the database.
     * @param {LessonSolutionUpdateManyAndReturnArgs} args - Arguments to update many LessonSolutions.
     * @example
     * // Update many LessonSolutions
     * const lessonSolution = await prisma.lessonSolution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonSolutions and only return the `id`
     * const lessonSolutionWithIdOnly = await prisma.lessonSolution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonSolutionUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonSolutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonSolution.
     * @param {LessonSolutionUpsertArgs} args - Arguments to update or create a LessonSolution.
     * @example
     * // Update or create a LessonSolution
     * const lessonSolution = await prisma.lessonSolution.upsert({
     *   create: {
     *     // ... data to create a LessonSolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonSolution we want to update
     *   }
     * })
     */
    upsert<T extends LessonSolutionUpsertArgs>(args: SelectSubset<T, LessonSolutionUpsertArgs<ExtArgs>>): Prisma__LessonSolutionClient<$Result.GetResult<Prisma.$LessonSolutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonSolutionCountArgs} args - Arguments to filter LessonSolutions to count.
     * @example
     * // Count the number of LessonSolutions
     * const count = await prisma.lessonSolution.count({
     *   where: {
     *     // ... the filter for the LessonSolutions we want to count
     *   }
     * })
    **/
    count<T extends LessonSolutionCountArgs>(
      args?: Subset<T, LessonSolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonSolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonSolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonSolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonSolutionAggregateArgs>(args: Subset<T, LessonSolutionAggregateArgs>): Prisma.PrismaPromise<GetLessonSolutionAggregateType<T>>

    /**
     * Group by LessonSolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonSolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonSolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonSolutionGroupByArgs['orderBy'] }
        : { orderBy?: LessonSolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonSolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonSolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonSolution model
   */
  readonly fields: LessonSolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonSolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonSolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonSolution model
   */
  interface LessonSolutionFieldRefs {
    readonly id: FieldRef<"LessonSolution", 'Int'>
    readonly solution: FieldRef<"LessonSolution", 'String'>
    readonly lessonId: FieldRef<"LessonSolution", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LessonSolution findUnique
   */
  export type LessonSolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * Filter, which LessonSolution to fetch.
     */
    where: LessonSolutionWhereUniqueInput
  }

  /**
   * LessonSolution findUniqueOrThrow
   */
  export type LessonSolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * Filter, which LessonSolution to fetch.
     */
    where: LessonSolutionWhereUniqueInput
  }

  /**
   * LessonSolution findFirst
   */
  export type LessonSolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * Filter, which LessonSolution to fetch.
     */
    where?: LessonSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSolutions to fetch.
     */
    orderBy?: LessonSolutionOrderByWithRelationInput | LessonSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonSolutions.
     */
    cursor?: LessonSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonSolutions.
     */
    distinct?: LessonSolutionScalarFieldEnum | LessonSolutionScalarFieldEnum[]
  }

  /**
   * LessonSolution findFirstOrThrow
   */
  export type LessonSolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * Filter, which LessonSolution to fetch.
     */
    where?: LessonSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSolutions to fetch.
     */
    orderBy?: LessonSolutionOrderByWithRelationInput | LessonSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonSolutions.
     */
    cursor?: LessonSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonSolutions.
     */
    distinct?: LessonSolutionScalarFieldEnum | LessonSolutionScalarFieldEnum[]
  }

  /**
   * LessonSolution findMany
   */
  export type LessonSolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * Filter, which LessonSolutions to fetch.
     */
    where?: LessonSolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonSolutions to fetch.
     */
    orderBy?: LessonSolutionOrderByWithRelationInput | LessonSolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonSolutions.
     */
    cursor?: LessonSolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonSolutions.
     */
    skip?: number
    distinct?: LessonSolutionScalarFieldEnum | LessonSolutionScalarFieldEnum[]
  }

  /**
   * LessonSolution create
   */
  export type LessonSolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonSolution.
     */
    data: XOR<LessonSolutionCreateInput, LessonSolutionUncheckedCreateInput>
  }

  /**
   * LessonSolution createMany
   */
  export type LessonSolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonSolutions.
     */
    data: LessonSolutionCreateManyInput | LessonSolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonSolution createManyAndReturn
   */
  export type LessonSolutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * The data used to create many LessonSolutions.
     */
    data: LessonSolutionCreateManyInput | LessonSolutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonSolution update
   */
  export type LessonSolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonSolution.
     */
    data: XOR<LessonSolutionUpdateInput, LessonSolutionUncheckedUpdateInput>
    /**
     * Choose, which LessonSolution to update.
     */
    where: LessonSolutionWhereUniqueInput
  }

  /**
   * LessonSolution updateMany
   */
  export type LessonSolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonSolutions.
     */
    data: XOR<LessonSolutionUpdateManyMutationInput, LessonSolutionUncheckedUpdateManyInput>
    /**
     * Filter which LessonSolutions to update
     */
    where?: LessonSolutionWhereInput
    /**
     * Limit how many LessonSolutions to update.
     */
    limit?: number
  }

  /**
   * LessonSolution updateManyAndReturn
   */
  export type LessonSolutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * The data used to update LessonSolutions.
     */
    data: XOR<LessonSolutionUpdateManyMutationInput, LessonSolutionUncheckedUpdateManyInput>
    /**
     * Filter which LessonSolutions to update
     */
    where?: LessonSolutionWhereInput
    /**
     * Limit how many LessonSolutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonSolution upsert
   */
  export type LessonSolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonSolution to update in case it exists.
     */
    where: LessonSolutionWhereUniqueInput
    /**
     * In case the LessonSolution found by the `where` argument doesn't exist, create a new LessonSolution with this data.
     */
    create: XOR<LessonSolutionCreateInput, LessonSolutionUncheckedCreateInput>
    /**
     * In case the LessonSolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonSolutionUpdateInput, LessonSolutionUncheckedUpdateInput>
  }

  /**
   * LessonSolution delete
   */
  export type LessonSolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
    /**
     * Filter which LessonSolution to delete.
     */
    where: LessonSolutionWhereUniqueInput
  }

  /**
   * LessonSolution deleteMany
   */
  export type LessonSolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonSolutions to delete
     */
    where?: LessonSolutionWhereInput
    /**
     * Limit how many LessonSolutions to delete.
     */
    limit?: number
  }

  /**
   * LessonSolution without action
   */
  export type LessonSolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonSolution
     */
    select?: LessonSolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonSolution
     */
    omit?: LessonSolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonSolutionInclude<ExtArgs> | null
  }


  /**
   * Model UserLessonProgress
   */

  export type AggregateUserLessonProgress = {
    _count: UserLessonProgressCountAggregateOutputType | null
    _avg: UserLessonProgressAvgAggregateOutputType | null
    _sum: UserLessonProgressSumAggregateOutputType | null
    _min: UserLessonProgressMinAggregateOutputType | null
    _max: UserLessonProgressMaxAggregateOutputType | null
  }

  export type UserLessonProgressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
    currentStep: number | null
  }

  export type UserLessonProgressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
    currentStep: number | null
  }

  export type UserLessonProgressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
  }

  export type UserLessonProgressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
    currentStep: number | null
    completed: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
  }

  export type UserLessonProgressCountAggregateOutputType = {
    id: number
    userId: number
    lessonId: number
    currentStep: number
    completed: number
    startedAt: number
    updatedAt: number
    _all: number
  }


  export type UserLessonProgressAvgAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    currentStep?: true
  }

  export type UserLessonProgressSumAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    currentStep?: true
  }

  export type UserLessonProgressMinAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
  }

  export type UserLessonProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
  }

  export type UserLessonProgressCountAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    currentStep?: true
    completed?: true
    startedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserLessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLessonProgress to aggregate.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLessonProgresses
    **/
    _count?: true | UserLessonProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLessonProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLessonProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLessonProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLessonProgressMaxAggregateInputType
  }

  export type GetUserLessonProgressAggregateType<T extends UserLessonProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLessonProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLessonProgress[P]>
      : GetScalarType<T[P], AggregateUserLessonProgress[P]>
  }




  export type UserLessonProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLessonProgressWhereInput
    orderBy?: UserLessonProgressOrderByWithAggregationInput | UserLessonProgressOrderByWithAggregationInput[]
    by: UserLessonProgressScalarFieldEnum[] | UserLessonProgressScalarFieldEnum
    having?: UserLessonProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLessonProgressCountAggregateInputType | true
    _avg?: UserLessonProgressAvgAggregateInputType
    _sum?: UserLessonProgressSumAggregateInputType
    _min?: UserLessonProgressMinAggregateInputType
    _max?: UserLessonProgressMaxAggregateInputType
  }

  export type UserLessonProgressGroupByOutputType = {
    id: number
    userId: number
    lessonId: number
    currentStep: number
    completed: boolean
    startedAt: Date
    updatedAt: Date
    _count: UserLessonProgressCountAggregateOutputType | null
    _avg: UserLessonProgressAvgAggregateOutputType | null
    _sum: UserLessonProgressSumAggregateOutputType | null
    _min: UserLessonProgressMinAggregateOutputType | null
    _max: UserLessonProgressMaxAggregateOutputType | null
  }

  type GetUserLessonProgressGroupByPayload<T extends UserLessonProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLessonProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLessonProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLessonProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserLessonProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserLessonProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonProgress"]>

  export type UserLessonProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonProgress"]>

  export type UserLessonProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLessonProgress"]>

  export type UserLessonProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    currentStep?: boolean
    completed?: boolean
    startedAt?: boolean
    updatedAt?: boolean
  }

  export type UserLessonProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "lessonId" | "currentStep" | "completed" | "startedAt" | "updatedAt", ExtArgs["result"]["userLessonProgress"]>
  export type UserLessonProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type UserLessonProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type UserLessonProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $UserLessonProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLessonProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      lessonId: number
      currentStep: number
      completed: boolean
      startedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userLessonProgress"]>
    composites: {}
  }

  type UserLessonProgressGetPayload<S extends boolean | null | undefined | UserLessonProgressDefaultArgs> = $Result.GetResult<Prisma.$UserLessonProgressPayload, S>

  type UserLessonProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLessonProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLessonProgressCountAggregateInputType | true
    }

  export interface UserLessonProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLessonProgress'], meta: { name: 'UserLessonProgress' } }
    /**
     * Find zero or one UserLessonProgress that matches the filter.
     * @param {UserLessonProgressFindUniqueArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLessonProgressFindUniqueArgs>(args: SelectSubset<T, UserLessonProgressFindUniqueArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLessonProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLessonProgressFindUniqueOrThrowArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLessonProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLessonProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLessonProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressFindFirstArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLessonProgressFindFirstArgs>(args?: SelectSubset<T, UserLessonProgressFindFirstArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLessonProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressFindFirstOrThrowArgs} args - Arguments to find a UserLessonProgress
     * @example
     * // Get one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLessonProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLessonProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLessonProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLessonProgresses
     * const userLessonProgresses = await prisma.userLessonProgress.findMany()
     * 
     * // Get first 10 UserLessonProgresses
     * const userLessonProgresses = await prisma.userLessonProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLessonProgressWithIdOnly = await prisma.userLessonProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLessonProgressFindManyArgs>(args?: SelectSubset<T, UserLessonProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLessonProgress.
     * @param {UserLessonProgressCreateArgs} args - Arguments to create a UserLessonProgress.
     * @example
     * // Create one UserLessonProgress
     * const UserLessonProgress = await prisma.userLessonProgress.create({
     *   data: {
     *     // ... data to create a UserLessonProgress
     *   }
     * })
     * 
     */
    create<T extends UserLessonProgressCreateArgs>(args: SelectSubset<T, UserLessonProgressCreateArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLessonProgresses.
     * @param {UserLessonProgressCreateManyArgs} args - Arguments to create many UserLessonProgresses.
     * @example
     * // Create many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLessonProgressCreateManyArgs>(args?: SelectSubset<T, UserLessonProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLessonProgresses and returns the data saved in the database.
     * @param {UserLessonProgressCreateManyAndReturnArgs} args - Arguments to create many UserLessonProgresses.
     * @example
     * // Create many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLessonProgresses and only return the `id`
     * const userLessonProgressWithIdOnly = await prisma.userLessonProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLessonProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLessonProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLessonProgress.
     * @param {UserLessonProgressDeleteArgs} args - Arguments to delete one UserLessonProgress.
     * @example
     * // Delete one UserLessonProgress
     * const UserLessonProgress = await prisma.userLessonProgress.delete({
     *   where: {
     *     // ... filter to delete one UserLessonProgress
     *   }
     * })
     * 
     */
    delete<T extends UserLessonProgressDeleteArgs>(args: SelectSubset<T, UserLessonProgressDeleteArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLessonProgress.
     * @param {UserLessonProgressUpdateArgs} args - Arguments to update one UserLessonProgress.
     * @example
     * // Update one UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLessonProgressUpdateArgs>(args: SelectSubset<T, UserLessonProgressUpdateArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLessonProgresses.
     * @param {UserLessonProgressDeleteManyArgs} args - Arguments to filter UserLessonProgresses to delete.
     * @example
     * // Delete a few UserLessonProgresses
     * const { count } = await prisma.userLessonProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLessonProgressDeleteManyArgs>(args?: SelectSubset<T, UserLessonProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLessonProgressUpdateManyArgs>(args: SelectSubset<T, UserLessonProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLessonProgresses and returns the data updated in the database.
     * @param {UserLessonProgressUpdateManyAndReturnArgs} args - Arguments to update many UserLessonProgresses.
     * @example
     * // Update many UserLessonProgresses
     * const userLessonProgress = await prisma.userLessonProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLessonProgresses and only return the `id`
     * const userLessonProgressWithIdOnly = await prisma.userLessonProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLessonProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLessonProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLessonProgress.
     * @param {UserLessonProgressUpsertArgs} args - Arguments to update or create a UserLessonProgress.
     * @example
     * // Update or create a UserLessonProgress
     * const userLessonProgress = await prisma.userLessonProgress.upsert({
     *   create: {
     *     // ... data to create a UserLessonProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLessonProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserLessonProgressUpsertArgs>(args: SelectSubset<T, UserLessonProgressUpsertArgs<ExtArgs>>): Prisma__UserLessonProgressClient<$Result.GetResult<Prisma.$UserLessonProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressCountArgs} args - Arguments to filter UserLessonProgresses to count.
     * @example
     * // Count the number of UserLessonProgresses
     * const count = await prisma.userLessonProgress.count({
     *   where: {
     *     // ... the filter for the UserLessonProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserLessonProgressCountArgs>(
      args?: Subset<T, UserLessonProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLessonProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLessonProgressAggregateArgs>(args: Subset<T, UserLessonProgressAggregateArgs>): Prisma.PrismaPromise<GetUserLessonProgressAggregateType<T>>

    /**
     * Group by UserLessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLessonProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLessonProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLessonProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserLessonProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLessonProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLessonProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLessonProgress model
   */
  readonly fields: UserLessonProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLessonProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLessonProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLessonProgress model
   */
  interface UserLessonProgressFieldRefs {
    readonly id: FieldRef<"UserLessonProgress", 'Int'>
    readonly userId: FieldRef<"UserLessonProgress", 'Int'>
    readonly lessonId: FieldRef<"UserLessonProgress", 'Int'>
    readonly currentStep: FieldRef<"UserLessonProgress", 'Int'>
    readonly completed: FieldRef<"UserLessonProgress", 'Boolean'>
    readonly startedAt: FieldRef<"UserLessonProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLessonProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLessonProgress findUnique
   */
  export type UserLessonProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress findUniqueOrThrow
   */
  export type UserLessonProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress findFirst
   */
  export type UserLessonProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLessonProgresses.
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLessonProgresses.
     */
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * UserLessonProgress findFirstOrThrow
   */
  export type UserLessonProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgress to fetch.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLessonProgresses.
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLessonProgresses.
     */
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * UserLessonProgress findMany
   */
  export type UserLessonProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserLessonProgresses to fetch.
     */
    where?: UserLessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLessonProgresses to fetch.
     */
    orderBy?: UserLessonProgressOrderByWithRelationInput | UserLessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLessonProgresses.
     */
    cursor?: UserLessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLessonProgresses.
     */
    skip?: number
    distinct?: UserLessonProgressScalarFieldEnum | UserLessonProgressScalarFieldEnum[]
  }

  /**
   * UserLessonProgress create
   */
  export type UserLessonProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLessonProgress.
     */
    data: XOR<UserLessonProgressCreateInput, UserLessonProgressUncheckedCreateInput>
  }

  /**
   * UserLessonProgress createMany
   */
  export type UserLessonProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLessonProgresses.
     */
    data: UserLessonProgressCreateManyInput | UserLessonProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLessonProgress createManyAndReturn
   */
  export type UserLessonProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserLessonProgresses.
     */
    data: UserLessonProgressCreateManyInput | UserLessonProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLessonProgress update
   */
  export type UserLessonProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLessonProgress.
     */
    data: XOR<UserLessonProgressUpdateInput, UserLessonProgressUncheckedUpdateInput>
    /**
     * Choose, which UserLessonProgress to update.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress updateMany
   */
  export type UserLessonProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLessonProgresses.
     */
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserLessonProgresses to update
     */
    where?: UserLessonProgressWhereInput
    /**
     * Limit how many UserLessonProgresses to update.
     */
    limit?: number
  }

  /**
   * UserLessonProgress updateManyAndReturn
   */
  export type UserLessonProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserLessonProgresses.
     */
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserLessonProgresses to update
     */
    where?: UserLessonProgressWhereInput
    /**
     * Limit how many UserLessonProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLessonProgress upsert
   */
  export type UserLessonProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLessonProgress to update in case it exists.
     */
    where: UserLessonProgressWhereUniqueInput
    /**
     * In case the UserLessonProgress found by the `where` argument doesn't exist, create a new UserLessonProgress with this data.
     */
    create: XOR<UserLessonProgressCreateInput, UserLessonProgressUncheckedCreateInput>
    /**
     * In case the UserLessonProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLessonProgressUpdateInput, UserLessonProgressUncheckedUpdateInput>
  }

  /**
   * UserLessonProgress delete
   */
  export type UserLessonProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
    /**
     * Filter which UserLessonProgress to delete.
     */
    where: UserLessonProgressWhereUniqueInput
  }

  /**
   * UserLessonProgress deleteMany
   */
  export type UserLessonProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLessonProgresses to delete
     */
    where?: UserLessonProgressWhereInput
    /**
     * Limit how many UserLessonProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserLessonProgress without action
   */
  export type UserLessonProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLessonProgress
     */
    select?: UserLessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLessonProgress
     */
    omit?: UserLessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLessonProgressInclude<ExtArgs> | null
  }


  /**
   * Model CourseRating
   */

  export type AggregateCourseRating = {
    _count: CourseRatingCountAggregateOutputType | null
    _avg: CourseRatingAvgAggregateOutputType | null
    _sum: CourseRatingSumAggregateOutputType | null
    _min: CourseRatingMinAggregateOutputType | null
    _max: CourseRatingMaxAggregateOutputType | null
  }

  export type CourseRatingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    rating: number | null
  }

  export type CourseRatingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    rating: number | null
  }

  export type CourseRatingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type CourseRatingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type CourseRatingCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type CourseRatingAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
  }

  export type CourseRatingSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
  }

  export type CourseRatingMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type CourseRatingMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type CourseRatingCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type CourseRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseRating to aggregate.
     */
    where?: CourseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRatings to fetch.
     */
    orderBy?: CourseRatingOrderByWithRelationInput | CourseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseRatings
    **/
    _count?: true | CourseRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseRatingMaxAggregateInputType
  }

  export type GetCourseRatingAggregateType<T extends CourseRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseRating[P]>
      : GetScalarType<T[P], AggregateCourseRating[P]>
  }




  export type CourseRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseRatingWhereInput
    orderBy?: CourseRatingOrderByWithAggregationInput | CourseRatingOrderByWithAggregationInput[]
    by: CourseRatingScalarFieldEnum[] | CourseRatingScalarFieldEnum
    having?: CourseRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseRatingCountAggregateInputType | true
    _avg?: CourseRatingAvgAggregateInputType
    _sum?: CourseRatingSumAggregateInputType
    _min?: CourseRatingMinAggregateInputType
    _max?: CourseRatingMaxAggregateInputType
  }

  export type CourseRatingGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    rating: number
    comment: string | null
    createdAt: Date
    _count: CourseRatingCountAggregateOutputType | null
    _avg: CourseRatingAvgAggregateOutputType | null
    _sum: CourseRatingSumAggregateOutputType | null
    _min: CourseRatingMinAggregateOutputType | null
    _max: CourseRatingMaxAggregateOutputType | null
  }

  type GetCourseRatingGroupByPayload<T extends CourseRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseRatingGroupByOutputType[P]>
            : GetScalarType<T[P], CourseRatingGroupByOutputType[P]>
        }
      >
    >


  export type CourseRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRating"]>

  export type CourseRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRating"]>

  export type CourseRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseRating"]>

  export type CourseRatingSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type CourseRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "rating" | "comment" | "createdAt", ExtArgs["result"]["courseRating"]>
  export type CourseRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseRatingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseRating"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["courseRating"]>
    composites: {}
  }

  type CourseRatingGetPayload<S extends boolean | null | undefined | CourseRatingDefaultArgs> = $Result.GetResult<Prisma.$CourseRatingPayload, S>

  type CourseRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseRatingCountAggregateInputType | true
    }

  export interface CourseRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseRating'], meta: { name: 'CourseRating' } }
    /**
     * Find zero or one CourseRating that matches the filter.
     * @param {CourseRatingFindUniqueArgs} args - Arguments to find a CourseRating
     * @example
     * // Get one CourseRating
     * const courseRating = await prisma.courseRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseRatingFindUniqueArgs>(args: SelectSubset<T, CourseRatingFindUniqueArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseRatingFindUniqueOrThrowArgs} args - Arguments to find a CourseRating
     * @example
     * // Get one CourseRating
     * const courseRating = await prisma.courseRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRatingFindFirstArgs} args - Arguments to find a CourseRating
     * @example
     * // Get one CourseRating
     * const courseRating = await prisma.courseRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseRatingFindFirstArgs>(args?: SelectSubset<T, CourseRatingFindFirstArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRatingFindFirstOrThrowArgs} args - Arguments to find a CourseRating
     * @example
     * // Get one CourseRating
     * const courseRating = await prisma.courseRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseRatings
     * const courseRatings = await prisma.courseRating.findMany()
     * 
     * // Get first 10 CourseRatings
     * const courseRatings = await prisma.courseRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseRatingWithIdOnly = await prisma.courseRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseRatingFindManyArgs>(args?: SelectSubset<T, CourseRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseRating.
     * @param {CourseRatingCreateArgs} args - Arguments to create a CourseRating.
     * @example
     * // Create one CourseRating
     * const CourseRating = await prisma.courseRating.create({
     *   data: {
     *     // ... data to create a CourseRating
     *   }
     * })
     * 
     */
    create<T extends CourseRatingCreateArgs>(args: SelectSubset<T, CourseRatingCreateArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseRatings.
     * @param {CourseRatingCreateManyArgs} args - Arguments to create many CourseRatings.
     * @example
     * // Create many CourseRatings
     * const courseRating = await prisma.courseRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseRatingCreateManyArgs>(args?: SelectSubset<T, CourseRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseRatings and returns the data saved in the database.
     * @param {CourseRatingCreateManyAndReturnArgs} args - Arguments to create many CourseRatings.
     * @example
     * // Create many CourseRatings
     * const courseRating = await prisma.courseRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseRatings and only return the `id`
     * const courseRatingWithIdOnly = await prisma.courseRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseRating.
     * @param {CourseRatingDeleteArgs} args - Arguments to delete one CourseRating.
     * @example
     * // Delete one CourseRating
     * const CourseRating = await prisma.courseRating.delete({
     *   where: {
     *     // ... filter to delete one CourseRating
     *   }
     * })
     * 
     */
    delete<T extends CourseRatingDeleteArgs>(args: SelectSubset<T, CourseRatingDeleteArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseRating.
     * @param {CourseRatingUpdateArgs} args - Arguments to update one CourseRating.
     * @example
     * // Update one CourseRating
     * const courseRating = await prisma.courseRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseRatingUpdateArgs>(args: SelectSubset<T, CourseRatingUpdateArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseRatings.
     * @param {CourseRatingDeleteManyArgs} args - Arguments to filter CourseRatings to delete.
     * @example
     * // Delete a few CourseRatings
     * const { count } = await prisma.courseRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseRatingDeleteManyArgs>(args?: SelectSubset<T, CourseRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseRatings
     * const courseRating = await prisma.courseRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseRatingUpdateManyArgs>(args: SelectSubset<T, CourseRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseRatings and returns the data updated in the database.
     * @param {CourseRatingUpdateManyAndReturnArgs} args - Arguments to update many CourseRatings.
     * @example
     * // Update many CourseRatings
     * const courseRating = await prisma.courseRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseRatings and only return the `id`
     * const courseRatingWithIdOnly = await prisma.courseRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseRating.
     * @param {CourseRatingUpsertArgs} args - Arguments to update or create a CourseRating.
     * @example
     * // Update or create a CourseRating
     * const courseRating = await prisma.courseRating.upsert({
     *   create: {
     *     // ... data to create a CourseRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseRating we want to update
     *   }
     * })
     */
    upsert<T extends CourseRatingUpsertArgs>(args: SelectSubset<T, CourseRatingUpsertArgs<ExtArgs>>): Prisma__CourseRatingClient<$Result.GetResult<Prisma.$CourseRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRatingCountArgs} args - Arguments to filter CourseRatings to count.
     * @example
     * // Count the number of CourseRatings
     * const count = await prisma.courseRating.count({
     *   where: {
     *     // ... the filter for the CourseRatings we want to count
     *   }
     * })
    **/
    count<T extends CourseRatingCountArgs>(
      args?: Subset<T, CourseRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseRatingAggregateArgs>(args: Subset<T, CourseRatingAggregateArgs>): Prisma.PrismaPromise<GetCourseRatingAggregateType<T>>

    /**
     * Group by CourseRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseRatingGroupByArgs['orderBy'] }
        : { orderBy?: CourseRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseRating model
   */
  readonly fields: CourseRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseRating model
   */
  interface CourseRatingFieldRefs {
    readonly id: FieldRef<"CourseRating", 'Int'>
    readonly userId: FieldRef<"CourseRating", 'Int'>
    readonly courseId: FieldRef<"CourseRating", 'Int'>
    readonly rating: FieldRef<"CourseRating", 'Int'>
    readonly comment: FieldRef<"CourseRating", 'String'>
    readonly createdAt: FieldRef<"CourseRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseRating findUnique
   */
  export type CourseRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * Filter, which CourseRating to fetch.
     */
    where: CourseRatingWhereUniqueInput
  }

  /**
   * CourseRating findUniqueOrThrow
   */
  export type CourseRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * Filter, which CourseRating to fetch.
     */
    where: CourseRatingWhereUniqueInput
  }

  /**
   * CourseRating findFirst
   */
  export type CourseRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * Filter, which CourseRating to fetch.
     */
    where?: CourseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRatings to fetch.
     */
    orderBy?: CourseRatingOrderByWithRelationInput | CourseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseRatings.
     */
    cursor?: CourseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseRatings.
     */
    distinct?: CourseRatingScalarFieldEnum | CourseRatingScalarFieldEnum[]
  }

  /**
   * CourseRating findFirstOrThrow
   */
  export type CourseRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * Filter, which CourseRating to fetch.
     */
    where?: CourseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRatings to fetch.
     */
    orderBy?: CourseRatingOrderByWithRelationInput | CourseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseRatings.
     */
    cursor?: CourseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseRatings.
     */
    distinct?: CourseRatingScalarFieldEnum | CourseRatingScalarFieldEnum[]
  }

  /**
   * CourseRating findMany
   */
  export type CourseRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * Filter, which CourseRatings to fetch.
     */
    where?: CourseRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseRatings to fetch.
     */
    orderBy?: CourseRatingOrderByWithRelationInput | CourseRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseRatings.
     */
    cursor?: CourseRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseRatings.
     */
    skip?: number
    distinct?: CourseRatingScalarFieldEnum | CourseRatingScalarFieldEnum[]
  }

  /**
   * CourseRating create
   */
  export type CourseRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseRating.
     */
    data: XOR<CourseRatingCreateInput, CourseRatingUncheckedCreateInput>
  }

  /**
   * CourseRating createMany
   */
  export type CourseRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseRatings.
     */
    data: CourseRatingCreateManyInput | CourseRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseRating createManyAndReturn
   */
  export type CourseRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * The data used to create many CourseRatings.
     */
    data: CourseRatingCreateManyInput | CourseRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseRating update
   */
  export type CourseRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseRating.
     */
    data: XOR<CourseRatingUpdateInput, CourseRatingUncheckedUpdateInput>
    /**
     * Choose, which CourseRating to update.
     */
    where: CourseRatingWhereUniqueInput
  }

  /**
   * CourseRating updateMany
   */
  export type CourseRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseRatings.
     */
    data: XOR<CourseRatingUpdateManyMutationInput, CourseRatingUncheckedUpdateManyInput>
    /**
     * Filter which CourseRatings to update
     */
    where?: CourseRatingWhereInput
    /**
     * Limit how many CourseRatings to update.
     */
    limit?: number
  }

  /**
   * CourseRating updateManyAndReturn
   */
  export type CourseRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * The data used to update CourseRatings.
     */
    data: XOR<CourseRatingUpdateManyMutationInput, CourseRatingUncheckedUpdateManyInput>
    /**
     * Filter which CourseRatings to update
     */
    where?: CourseRatingWhereInput
    /**
     * Limit how many CourseRatings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseRating upsert
   */
  export type CourseRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseRating to update in case it exists.
     */
    where: CourseRatingWhereUniqueInput
    /**
     * In case the CourseRating found by the `where` argument doesn't exist, create a new CourseRating with this data.
     */
    create: XOR<CourseRatingCreateInput, CourseRatingUncheckedCreateInput>
    /**
     * In case the CourseRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseRatingUpdateInput, CourseRatingUncheckedUpdateInput>
  }

  /**
   * CourseRating delete
   */
  export type CourseRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
    /**
     * Filter which CourseRating to delete.
     */
    where: CourseRatingWhereUniqueInput
  }

  /**
   * CourseRating deleteMany
   */
  export type CourseRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseRatings to delete
     */
    where?: CourseRatingWhereInput
    /**
     * Limit how many CourseRatings to delete.
     */
    limit?: number
  }

  /**
   * CourseRating without action
   */
  export type CourseRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseRating
     */
    select?: CourseRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseRating
     */
    omit?: CourseRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseRatingInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    id: number | null
    likes: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    id: number | null
    likes: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: number | null
    difficulty: string | null
    title: string | null
    description: string | null
    relation: string | null
    duration: string | null
    useEditor: boolean | null
    likes: number | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: number | null
    difficulty: string | null
    title: string | null
    description: string | null
    relation: string | null
    duration: string | null
    useEditor: boolean | null
    likes: number | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    difficulty: number
    title: number
    description: number
    relation: number
    duration: number
    useEditor: number
    likes: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    id?: true
    likes?: true
  }

  export type ChallengeSumAggregateInputType = {
    id?: true
    likes?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    difficulty?: true
    title?: true
    description?: true
    relation?: true
    duration?: true
    useEditor?: true
    likes?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    difficulty?: true
    title?: true
    description?: true
    relation?: true
    duration?: true
    useEditor?: true
    likes?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    difficulty?: true
    title?: true
    description?: true
    relation?: true
    duration?: true
    useEditor?: true
    likes?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: number
    difficulty: string
    title: string
    description: string
    relation: string | null
    duration: string
    useEditor: boolean
    likes: number
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    difficulty?: boolean
    title?: boolean
    description?: boolean
    relation?: boolean
    duration?: boolean
    useEditor?: boolean
    likes?: boolean
    instructions?: boolean | Challenge$instructionsArgs<ExtArgs>
    likesList?: boolean | Challenge$likesListArgs<ExtArgs>
    solutions?: boolean | Challenge$solutionsArgs<ExtArgs>
    completions?: boolean | Challenge$completionsArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    difficulty?: boolean
    title?: boolean
    description?: boolean
    relation?: boolean
    duration?: boolean
    useEditor?: boolean
    likes?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    difficulty?: boolean
    title?: boolean
    description?: boolean
    relation?: boolean
    duration?: boolean
    useEditor?: boolean
    likes?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    difficulty?: boolean
    title?: boolean
    description?: boolean
    relation?: boolean
    duration?: boolean
    useEditor?: boolean
    likes?: boolean
  }

  export type ChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "difficulty" | "title" | "description" | "relation" | "duration" | "useEditor" | "likes", ExtArgs["result"]["challenge"]>
  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructions?: boolean | Challenge$instructionsArgs<ExtArgs>
    likesList?: boolean | Challenge$likesListArgs<ExtArgs>
    solutions?: boolean | Challenge$solutionsArgs<ExtArgs>
    completions?: boolean | Challenge$completionsArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      instructions: Prisma.$ChallengeInstructionsPayload<ExtArgs>[]
      likesList: Prisma.$ChallengeLikePayload<ExtArgs>[]
      solutions: Prisma.$ChallengeSolutionsPayload<ExtArgs>[]
      completions: Prisma.$CompletedChallengesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      difficulty: string
      title: string
      description: string
      relation: string | null
      duration: string
      useEditor: boolean
      likes: number
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges and returns the data updated in the database.
     * @param {ChallengeUpdateManyAndReturnArgs} args - Arguments to update many Challenges.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instructions<T extends Challenge$instructionsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$instructionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likesList<T extends Challenge$likesListArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$likesListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    solutions<T extends Challenge$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    completions<T extends Challenge$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'Int'>
    readonly difficulty: FieldRef<"Challenge", 'String'>
    readonly title: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly relation: FieldRef<"Challenge", 'String'>
    readonly duration: FieldRef<"Challenge", 'String'>
    readonly useEditor: FieldRef<"Challenge", 'Boolean'>
    readonly likes: FieldRef<"Challenge", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge updateManyAndReturn
   */
  export type ChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to delete.
     */
    limit?: number
  }

  /**
   * Challenge.instructions
   */
  export type Challenge$instructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    where?: ChallengeInstructionsWhereInput
    orderBy?: ChallengeInstructionsOrderByWithRelationInput | ChallengeInstructionsOrderByWithRelationInput[]
    cursor?: ChallengeInstructionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeInstructionsScalarFieldEnum | ChallengeInstructionsScalarFieldEnum[]
  }

  /**
   * Challenge.likesList
   */
  export type Challenge$likesListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    where?: ChallengeLikeWhereInput
    orderBy?: ChallengeLikeOrderByWithRelationInput | ChallengeLikeOrderByWithRelationInput[]
    cursor?: ChallengeLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeLikeScalarFieldEnum | ChallengeLikeScalarFieldEnum[]
  }

  /**
   * Challenge.solutions
   */
  export type Challenge$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    where?: ChallengeSolutionsWhereInput
    orderBy?: ChallengeSolutionsOrderByWithRelationInput | ChallengeSolutionsOrderByWithRelationInput[]
    cursor?: ChallengeSolutionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeSolutionsScalarFieldEnum | ChallengeSolutionsScalarFieldEnum[]
  }

  /**
   * Challenge.completions
   */
  export type Challenge$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    where?: CompletedChallengesWhereInput
    orderBy?: CompletedChallengesOrderByWithRelationInput | CompletedChallengesOrderByWithRelationInput[]
    cursor?: CompletedChallengesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompletedChallengesScalarFieldEnum | CompletedChallengesScalarFieldEnum[]
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    type: string | null
    createdAt: Date | null
    read: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    senderId: number | null
    receiverId: number | null
    content: string | null
    type: string | null
    createdAt: Date | null
    read: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: number
    type: number
    createdAt: number
    read: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    type?: true
    createdAt?: true
    read?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    type?: true
    createdAt?: true
    read?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    content?: true
    type?: true
    createdAt?: true
    read?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    senderId: number
    receiverId: number
    content: string
    type: string
    createdAt: Date
    read: boolean
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    read?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    read?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    read?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    read?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "content" | "type" | "createdAt" | "read", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      senderId: number
      receiverId: number
      content: string
      type: string
      createdAt: Date
      read: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly senderId: FieldRef<"Message", 'Int'>
    readonly receiverId: FieldRef<"Message", 'Int'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly read: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeLike
   */

  export type AggregateChallengeLike = {
    _count: ChallengeLikeCountAggregateOutputType | null
    _avg: ChallengeLikeAvgAggregateOutputType | null
    _sum: ChallengeLikeSumAggregateOutputType | null
    _min: ChallengeLikeMinAggregateOutputType | null
    _max: ChallengeLikeMaxAggregateOutputType | null
  }

  export type ChallengeLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
  }

  export type ChallengeLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
  }

  export type ChallengeLikeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
  }

  export type ChallengeLikeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
  }

  export type ChallengeLikeCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    _all: number
  }


  export type ChallengeLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
  }

  export type ChallengeLikeSumAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
  }

  export type ChallengeLikeMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
  }

  export type ChallengeLikeMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
  }

  export type ChallengeLikeCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    _all?: true
  }

  export type ChallengeLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeLike to aggregate.
     */
    where?: ChallengeLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLikes to fetch.
     */
    orderBy?: ChallengeLikeOrderByWithRelationInput | ChallengeLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeLikes
    **/
    _count?: true | ChallengeLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeLikeMaxAggregateInputType
  }

  export type GetChallengeLikeAggregateType<T extends ChallengeLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeLike[P]>
      : GetScalarType<T[P], AggregateChallengeLike[P]>
  }




  export type ChallengeLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeLikeWhereInput
    orderBy?: ChallengeLikeOrderByWithAggregationInput | ChallengeLikeOrderByWithAggregationInput[]
    by: ChallengeLikeScalarFieldEnum[] | ChallengeLikeScalarFieldEnum
    having?: ChallengeLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeLikeCountAggregateInputType | true
    _avg?: ChallengeLikeAvgAggregateInputType
    _sum?: ChallengeLikeSumAggregateInputType
    _min?: ChallengeLikeMinAggregateInputType
    _max?: ChallengeLikeMaxAggregateInputType
  }

  export type ChallengeLikeGroupByOutputType = {
    id: number
    userId: number
    challengeId: number
    _count: ChallengeLikeCountAggregateOutputType | null
    _avg: ChallengeLikeAvgAggregateOutputType | null
    _sum: ChallengeLikeSumAggregateOutputType | null
    _min: ChallengeLikeMinAggregateOutputType | null
    _max: ChallengeLikeMaxAggregateOutputType | null
  }

  type GetChallengeLikeGroupByPayload<T extends ChallengeLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeLikeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeLikeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeLike"]>

  export type ChallengeLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeLike"]>

  export type ChallengeLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeLike"]>

  export type ChallengeLikeSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
  }

  export type ChallengeLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "challengeId", ExtArgs["result"]["challengeLike"]>
  export type ChallengeLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeLike"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      challengeId: number
    }, ExtArgs["result"]["challengeLike"]>
    composites: {}
  }

  type ChallengeLikeGetPayload<S extends boolean | null | undefined | ChallengeLikeDefaultArgs> = $Result.GetResult<Prisma.$ChallengeLikePayload, S>

  type ChallengeLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeLikeCountAggregateInputType | true
    }

  export interface ChallengeLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeLike'], meta: { name: 'ChallengeLike' } }
    /**
     * Find zero or one ChallengeLike that matches the filter.
     * @param {ChallengeLikeFindUniqueArgs} args - Arguments to find a ChallengeLike
     * @example
     * // Get one ChallengeLike
     * const challengeLike = await prisma.challengeLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeLikeFindUniqueArgs>(args: SelectSubset<T, ChallengeLikeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeLikeFindUniqueOrThrowArgs} args - Arguments to find a ChallengeLike
     * @example
     * // Get one ChallengeLike
     * const challengeLike = await prisma.challengeLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLikeFindFirstArgs} args - Arguments to find a ChallengeLike
     * @example
     * // Get one ChallengeLike
     * const challengeLike = await prisma.challengeLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeLikeFindFirstArgs>(args?: SelectSubset<T, ChallengeLikeFindFirstArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLikeFindFirstOrThrowArgs} args - Arguments to find a ChallengeLike
     * @example
     * // Get one ChallengeLike
     * const challengeLike = await prisma.challengeLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeLikes
     * const challengeLikes = await prisma.challengeLike.findMany()
     * 
     * // Get first 10 ChallengeLikes
     * const challengeLikes = await prisma.challengeLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeLikeWithIdOnly = await prisma.challengeLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeLikeFindManyArgs>(args?: SelectSubset<T, ChallengeLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeLike.
     * @param {ChallengeLikeCreateArgs} args - Arguments to create a ChallengeLike.
     * @example
     * // Create one ChallengeLike
     * const ChallengeLike = await prisma.challengeLike.create({
     *   data: {
     *     // ... data to create a ChallengeLike
     *   }
     * })
     * 
     */
    create<T extends ChallengeLikeCreateArgs>(args: SelectSubset<T, ChallengeLikeCreateArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeLikes.
     * @param {ChallengeLikeCreateManyArgs} args - Arguments to create many ChallengeLikes.
     * @example
     * // Create many ChallengeLikes
     * const challengeLike = await prisma.challengeLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeLikeCreateManyArgs>(args?: SelectSubset<T, ChallengeLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeLikes and returns the data saved in the database.
     * @param {ChallengeLikeCreateManyAndReturnArgs} args - Arguments to create many ChallengeLikes.
     * @example
     * // Create many ChallengeLikes
     * const challengeLike = await prisma.challengeLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeLikes and only return the `id`
     * const challengeLikeWithIdOnly = await prisma.challengeLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeLike.
     * @param {ChallengeLikeDeleteArgs} args - Arguments to delete one ChallengeLike.
     * @example
     * // Delete one ChallengeLike
     * const ChallengeLike = await prisma.challengeLike.delete({
     *   where: {
     *     // ... filter to delete one ChallengeLike
     *   }
     * })
     * 
     */
    delete<T extends ChallengeLikeDeleteArgs>(args: SelectSubset<T, ChallengeLikeDeleteArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeLike.
     * @param {ChallengeLikeUpdateArgs} args - Arguments to update one ChallengeLike.
     * @example
     * // Update one ChallengeLike
     * const challengeLike = await prisma.challengeLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeLikeUpdateArgs>(args: SelectSubset<T, ChallengeLikeUpdateArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeLikes.
     * @param {ChallengeLikeDeleteManyArgs} args - Arguments to filter ChallengeLikes to delete.
     * @example
     * // Delete a few ChallengeLikes
     * const { count } = await prisma.challengeLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeLikeDeleteManyArgs>(args?: SelectSubset<T, ChallengeLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeLikes
     * const challengeLike = await prisma.challengeLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeLikeUpdateManyArgs>(args: SelectSubset<T, ChallengeLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeLikes and returns the data updated in the database.
     * @param {ChallengeLikeUpdateManyAndReturnArgs} args - Arguments to update many ChallengeLikes.
     * @example
     * // Update many ChallengeLikes
     * const challengeLike = await prisma.challengeLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeLikes and only return the `id`
     * const challengeLikeWithIdOnly = await prisma.challengeLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeLike.
     * @param {ChallengeLikeUpsertArgs} args - Arguments to update or create a ChallengeLike.
     * @example
     * // Update or create a ChallengeLike
     * const challengeLike = await prisma.challengeLike.upsert({
     *   create: {
     *     // ... data to create a ChallengeLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeLike we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeLikeUpsertArgs>(args: SelectSubset<T, ChallengeLikeUpsertArgs<ExtArgs>>): Prisma__ChallengeLikeClient<$Result.GetResult<Prisma.$ChallengeLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLikeCountArgs} args - Arguments to filter ChallengeLikes to count.
     * @example
     * // Count the number of ChallengeLikes
     * const count = await prisma.challengeLike.count({
     *   where: {
     *     // ... the filter for the ChallengeLikes we want to count
     *   }
     * })
    **/
    count<T extends ChallengeLikeCountArgs>(
      args?: Subset<T, ChallengeLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeLikeAggregateArgs>(args: Subset<T, ChallengeLikeAggregateArgs>): Prisma.PrismaPromise<GetChallengeLikeAggregateType<T>>

    /**
     * Group by ChallengeLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeLikeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeLike model
   */
  readonly fields: ChallengeLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeLike model
   */
  interface ChallengeLikeFieldRefs {
    readonly id: FieldRef<"ChallengeLike", 'Int'>
    readonly userId: FieldRef<"ChallengeLike", 'Int'>
    readonly challengeId: FieldRef<"ChallengeLike", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeLike findUnique
   */
  export type ChallengeLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLike to fetch.
     */
    where: ChallengeLikeWhereUniqueInput
  }

  /**
   * ChallengeLike findUniqueOrThrow
   */
  export type ChallengeLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLike to fetch.
     */
    where: ChallengeLikeWhereUniqueInput
  }

  /**
   * ChallengeLike findFirst
   */
  export type ChallengeLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLike to fetch.
     */
    where?: ChallengeLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLikes to fetch.
     */
    orderBy?: ChallengeLikeOrderByWithRelationInput | ChallengeLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeLikes.
     */
    cursor?: ChallengeLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeLikes.
     */
    distinct?: ChallengeLikeScalarFieldEnum | ChallengeLikeScalarFieldEnum[]
  }

  /**
   * ChallengeLike findFirstOrThrow
   */
  export type ChallengeLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLike to fetch.
     */
    where?: ChallengeLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLikes to fetch.
     */
    orderBy?: ChallengeLikeOrderByWithRelationInput | ChallengeLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeLikes.
     */
    cursor?: ChallengeLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeLikes.
     */
    distinct?: ChallengeLikeScalarFieldEnum | ChallengeLikeScalarFieldEnum[]
  }

  /**
   * ChallengeLike findMany
   */
  export type ChallengeLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeLikes to fetch.
     */
    where?: ChallengeLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeLikes to fetch.
     */
    orderBy?: ChallengeLikeOrderByWithRelationInput | ChallengeLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeLikes.
     */
    cursor?: ChallengeLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeLikes.
     */
    skip?: number
    distinct?: ChallengeLikeScalarFieldEnum | ChallengeLikeScalarFieldEnum[]
  }

  /**
   * ChallengeLike create
   */
  export type ChallengeLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeLike.
     */
    data: XOR<ChallengeLikeCreateInput, ChallengeLikeUncheckedCreateInput>
  }

  /**
   * ChallengeLike createMany
   */
  export type ChallengeLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeLikes.
     */
    data: ChallengeLikeCreateManyInput | ChallengeLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeLike createManyAndReturn
   */
  export type ChallengeLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeLikes.
     */
    data: ChallengeLikeCreateManyInput | ChallengeLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeLike update
   */
  export type ChallengeLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeLike.
     */
    data: XOR<ChallengeLikeUpdateInput, ChallengeLikeUncheckedUpdateInput>
    /**
     * Choose, which ChallengeLike to update.
     */
    where: ChallengeLikeWhereUniqueInput
  }

  /**
   * ChallengeLike updateMany
   */
  export type ChallengeLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeLikes.
     */
    data: XOR<ChallengeLikeUpdateManyMutationInput, ChallengeLikeUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeLikes to update
     */
    where?: ChallengeLikeWhereInput
    /**
     * Limit how many ChallengeLikes to update.
     */
    limit?: number
  }

  /**
   * ChallengeLike updateManyAndReturn
   */
  export type ChallengeLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeLikes.
     */
    data: XOR<ChallengeLikeUpdateManyMutationInput, ChallengeLikeUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeLikes to update
     */
    where?: ChallengeLikeWhereInput
    /**
     * Limit how many ChallengeLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeLike upsert
   */
  export type ChallengeLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeLike to update in case it exists.
     */
    where: ChallengeLikeWhereUniqueInput
    /**
     * In case the ChallengeLike found by the `where` argument doesn't exist, create a new ChallengeLike with this data.
     */
    create: XOR<ChallengeLikeCreateInput, ChallengeLikeUncheckedCreateInput>
    /**
     * In case the ChallengeLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeLikeUpdateInput, ChallengeLikeUncheckedUpdateInput>
  }

  /**
   * ChallengeLike delete
   */
  export type ChallengeLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
    /**
     * Filter which ChallengeLike to delete.
     */
    where: ChallengeLikeWhereUniqueInput
  }

  /**
   * ChallengeLike deleteMany
   */
  export type ChallengeLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeLikes to delete
     */
    where?: ChallengeLikeWhereInput
    /**
     * Limit how many ChallengeLikes to delete.
     */
    limit?: number
  }

  /**
   * ChallengeLike without action
   */
  export type ChallengeLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeLike
     */
    select?: ChallengeLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeLike
     */
    omit?: ChallengeLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeLikeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeInstructions
   */

  export type AggregateChallengeInstructions = {
    _count: ChallengeInstructionsCountAggregateOutputType | null
    _avg: ChallengeInstructionsAvgAggregateOutputType | null
    _sum: ChallengeInstructionsSumAggregateOutputType | null
    _min: ChallengeInstructionsMinAggregateOutputType | null
    _max: ChallengeInstructionsMaxAggregateOutputType | null
  }

  export type ChallengeInstructionsAvgAggregateOutputType = {
    id: number | null
    number: number | null
    challengeId: number | null
  }

  export type ChallengeInstructionsSumAggregateOutputType = {
    id: number | null
    number: number | null
    challengeId: number | null
  }

  export type ChallengeInstructionsMinAggregateOutputType = {
    id: number | null
    number: number | null
    instruction: string | null
    completed: boolean | null
    challengeId: number | null
  }

  export type ChallengeInstructionsMaxAggregateOutputType = {
    id: number | null
    number: number | null
    instruction: string | null
    completed: boolean | null
    challengeId: number | null
  }

  export type ChallengeInstructionsCountAggregateOutputType = {
    id: number
    number: number
    instruction: number
    completed: number
    challengeId: number
    _all: number
  }


  export type ChallengeInstructionsAvgAggregateInputType = {
    id?: true
    number?: true
    challengeId?: true
  }

  export type ChallengeInstructionsSumAggregateInputType = {
    id?: true
    number?: true
    challengeId?: true
  }

  export type ChallengeInstructionsMinAggregateInputType = {
    id?: true
    number?: true
    instruction?: true
    completed?: true
    challengeId?: true
  }

  export type ChallengeInstructionsMaxAggregateInputType = {
    id?: true
    number?: true
    instruction?: true
    completed?: true
    challengeId?: true
  }

  export type ChallengeInstructionsCountAggregateInputType = {
    id?: true
    number?: true
    instruction?: true
    completed?: true
    challengeId?: true
    _all?: true
  }

  export type ChallengeInstructionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeInstructions to aggregate.
     */
    where?: ChallengeInstructionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstructions to fetch.
     */
    orderBy?: ChallengeInstructionsOrderByWithRelationInput | ChallengeInstructionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeInstructionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeInstructions
    **/
    _count?: true | ChallengeInstructionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeInstructionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeInstructionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeInstructionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeInstructionsMaxAggregateInputType
  }

  export type GetChallengeInstructionsAggregateType<T extends ChallengeInstructionsAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeInstructions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeInstructions[P]>
      : GetScalarType<T[P], AggregateChallengeInstructions[P]>
  }




  export type ChallengeInstructionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstructionsWhereInput
    orderBy?: ChallengeInstructionsOrderByWithAggregationInput | ChallengeInstructionsOrderByWithAggregationInput[]
    by: ChallengeInstructionsScalarFieldEnum[] | ChallengeInstructionsScalarFieldEnum
    having?: ChallengeInstructionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeInstructionsCountAggregateInputType | true
    _avg?: ChallengeInstructionsAvgAggregateInputType
    _sum?: ChallengeInstructionsSumAggregateInputType
    _min?: ChallengeInstructionsMinAggregateInputType
    _max?: ChallengeInstructionsMaxAggregateInputType
  }

  export type ChallengeInstructionsGroupByOutputType = {
    id: number
    number: number
    instruction: string
    completed: boolean
    challengeId: number
    _count: ChallengeInstructionsCountAggregateOutputType | null
    _avg: ChallengeInstructionsAvgAggregateOutputType | null
    _sum: ChallengeInstructionsSumAggregateOutputType | null
    _min: ChallengeInstructionsMinAggregateOutputType | null
    _max: ChallengeInstructionsMaxAggregateOutputType | null
  }

  type GetChallengeInstructionsGroupByPayload<T extends ChallengeInstructionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeInstructionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeInstructionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeInstructionsGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeInstructionsGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeInstructionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    instruction?: boolean
    completed?: boolean
    challengeId?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeInstructions"]>

  export type ChallengeInstructionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    instruction?: boolean
    completed?: boolean
    challengeId?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeInstructions"]>

  export type ChallengeInstructionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    instruction?: boolean
    completed?: boolean
    challengeId?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeInstructions"]>

  export type ChallengeInstructionsSelectScalar = {
    id?: boolean
    number?: boolean
    instruction?: boolean
    completed?: boolean
    challengeId?: boolean
  }

  export type ChallengeInstructionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "instruction" | "completed" | "challengeId", ExtArgs["result"]["challengeInstructions"]>
  export type ChallengeInstructionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeInstructionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeInstructionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeInstructionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeInstructions"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: number
      instruction: string
      completed: boolean
      challengeId: number
    }, ExtArgs["result"]["challengeInstructions"]>
    composites: {}
  }

  type ChallengeInstructionsGetPayload<S extends boolean | null | undefined | ChallengeInstructionsDefaultArgs> = $Result.GetResult<Prisma.$ChallengeInstructionsPayload, S>

  type ChallengeInstructionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeInstructionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeInstructionsCountAggregateInputType | true
    }

  export interface ChallengeInstructionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeInstructions'], meta: { name: 'ChallengeInstructions' } }
    /**
     * Find zero or one ChallengeInstructions that matches the filter.
     * @param {ChallengeInstructionsFindUniqueArgs} args - Arguments to find a ChallengeInstructions
     * @example
     * // Get one ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeInstructionsFindUniqueArgs>(args: SelectSubset<T, ChallengeInstructionsFindUniqueArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeInstructions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeInstructionsFindUniqueOrThrowArgs} args - Arguments to find a ChallengeInstructions
     * @example
     * // Get one ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeInstructionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeInstructionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeInstructions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstructionsFindFirstArgs} args - Arguments to find a ChallengeInstructions
     * @example
     * // Get one ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeInstructionsFindFirstArgs>(args?: SelectSubset<T, ChallengeInstructionsFindFirstArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeInstructions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstructionsFindFirstOrThrowArgs} args - Arguments to find a ChallengeInstructions
     * @example
     * // Get one ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeInstructionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeInstructionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeInstructions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstructionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.findMany()
     * 
     * // Get first 10 ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeInstructionsWithIdOnly = await prisma.challengeInstructions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeInstructionsFindManyArgs>(args?: SelectSubset<T, ChallengeInstructionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeInstructions.
     * @param {ChallengeInstructionsCreateArgs} args - Arguments to create a ChallengeInstructions.
     * @example
     * // Create one ChallengeInstructions
     * const ChallengeInstructions = await prisma.challengeInstructions.create({
     *   data: {
     *     // ... data to create a ChallengeInstructions
     *   }
     * })
     * 
     */
    create<T extends ChallengeInstructionsCreateArgs>(args: SelectSubset<T, ChallengeInstructionsCreateArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeInstructions.
     * @param {ChallengeInstructionsCreateManyArgs} args - Arguments to create many ChallengeInstructions.
     * @example
     * // Create many ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeInstructionsCreateManyArgs>(args?: SelectSubset<T, ChallengeInstructionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeInstructions and returns the data saved in the database.
     * @param {ChallengeInstructionsCreateManyAndReturnArgs} args - Arguments to create many ChallengeInstructions.
     * @example
     * // Create many ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeInstructions and only return the `id`
     * const challengeInstructionsWithIdOnly = await prisma.challengeInstructions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeInstructionsCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeInstructionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeInstructions.
     * @param {ChallengeInstructionsDeleteArgs} args - Arguments to delete one ChallengeInstructions.
     * @example
     * // Delete one ChallengeInstructions
     * const ChallengeInstructions = await prisma.challengeInstructions.delete({
     *   where: {
     *     // ... filter to delete one ChallengeInstructions
     *   }
     * })
     * 
     */
    delete<T extends ChallengeInstructionsDeleteArgs>(args: SelectSubset<T, ChallengeInstructionsDeleteArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeInstructions.
     * @param {ChallengeInstructionsUpdateArgs} args - Arguments to update one ChallengeInstructions.
     * @example
     * // Update one ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeInstructionsUpdateArgs>(args: SelectSubset<T, ChallengeInstructionsUpdateArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeInstructions.
     * @param {ChallengeInstructionsDeleteManyArgs} args - Arguments to filter ChallengeInstructions to delete.
     * @example
     * // Delete a few ChallengeInstructions
     * const { count } = await prisma.challengeInstructions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeInstructionsDeleteManyArgs>(args?: SelectSubset<T, ChallengeInstructionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstructionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeInstructionsUpdateManyArgs>(args: SelectSubset<T, ChallengeInstructionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeInstructions and returns the data updated in the database.
     * @param {ChallengeInstructionsUpdateManyAndReturnArgs} args - Arguments to update many ChallengeInstructions.
     * @example
     * // Update many ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeInstructions and only return the `id`
     * const challengeInstructionsWithIdOnly = await prisma.challengeInstructions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeInstructionsUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeInstructionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeInstructions.
     * @param {ChallengeInstructionsUpsertArgs} args - Arguments to update or create a ChallengeInstructions.
     * @example
     * // Update or create a ChallengeInstructions
     * const challengeInstructions = await prisma.challengeInstructions.upsert({
     *   create: {
     *     // ... data to create a ChallengeInstructions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeInstructions we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeInstructionsUpsertArgs>(args: SelectSubset<T, ChallengeInstructionsUpsertArgs<ExtArgs>>): Prisma__ChallengeInstructionsClient<$Result.GetResult<Prisma.$ChallengeInstructionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstructionsCountArgs} args - Arguments to filter ChallengeInstructions to count.
     * @example
     * // Count the number of ChallengeInstructions
     * const count = await prisma.challengeInstructions.count({
     *   where: {
     *     // ... the filter for the ChallengeInstructions we want to count
     *   }
     * })
    **/
    count<T extends ChallengeInstructionsCountArgs>(
      args?: Subset<T, ChallengeInstructionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeInstructionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstructionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeInstructionsAggregateArgs>(args: Subset<T, ChallengeInstructionsAggregateArgs>): Prisma.PrismaPromise<GetChallengeInstructionsAggregateType<T>>

    /**
     * Group by ChallengeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstructionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeInstructionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeInstructionsGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeInstructionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeInstructionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeInstructionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeInstructions model
   */
  readonly fields: ChallengeInstructionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeInstructions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeInstructionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeInstructions model
   */
  interface ChallengeInstructionsFieldRefs {
    readonly id: FieldRef<"ChallengeInstructions", 'Int'>
    readonly number: FieldRef<"ChallengeInstructions", 'Int'>
    readonly instruction: FieldRef<"ChallengeInstructions", 'String'>
    readonly completed: FieldRef<"ChallengeInstructions", 'Boolean'>
    readonly challengeId: FieldRef<"ChallengeInstructions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeInstructions findUnique
   */
  export type ChallengeInstructionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstructions to fetch.
     */
    where: ChallengeInstructionsWhereUniqueInput
  }

  /**
   * ChallengeInstructions findUniqueOrThrow
   */
  export type ChallengeInstructionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstructions to fetch.
     */
    where: ChallengeInstructionsWhereUniqueInput
  }

  /**
   * ChallengeInstructions findFirst
   */
  export type ChallengeInstructionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstructions to fetch.
     */
    where?: ChallengeInstructionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstructions to fetch.
     */
    orderBy?: ChallengeInstructionsOrderByWithRelationInput | ChallengeInstructionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeInstructions.
     */
    cursor?: ChallengeInstructionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeInstructions.
     */
    distinct?: ChallengeInstructionsScalarFieldEnum | ChallengeInstructionsScalarFieldEnum[]
  }

  /**
   * ChallengeInstructions findFirstOrThrow
   */
  export type ChallengeInstructionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstructions to fetch.
     */
    where?: ChallengeInstructionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstructions to fetch.
     */
    orderBy?: ChallengeInstructionsOrderByWithRelationInput | ChallengeInstructionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeInstructions.
     */
    cursor?: ChallengeInstructionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeInstructions.
     */
    distinct?: ChallengeInstructionsScalarFieldEnum | ChallengeInstructionsScalarFieldEnum[]
  }

  /**
   * ChallengeInstructions findMany
   */
  export type ChallengeInstructionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstructions to fetch.
     */
    where?: ChallengeInstructionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstructions to fetch.
     */
    orderBy?: ChallengeInstructionsOrderByWithRelationInput | ChallengeInstructionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeInstructions.
     */
    cursor?: ChallengeInstructionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstructions.
     */
    skip?: number
    distinct?: ChallengeInstructionsScalarFieldEnum | ChallengeInstructionsScalarFieldEnum[]
  }

  /**
   * ChallengeInstructions create
   */
  export type ChallengeInstructionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeInstructions.
     */
    data: XOR<ChallengeInstructionsCreateInput, ChallengeInstructionsUncheckedCreateInput>
  }

  /**
   * ChallengeInstructions createMany
   */
  export type ChallengeInstructionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeInstructions.
     */
    data: ChallengeInstructionsCreateManyInput | ChallengeInstructionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeInstructions createManyAndReturn
   */
  export type ChallengeInstructionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeInstructions.
     */
    data: ChallengeInstructionsCreateManyInput | ChallengeInstructionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeInstructions update
   */
  export type ChallengeInstructionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeInstructions.
     */
    data: XOR<ChallengeInstructionsUpdateInput, ChallengeInstructionsUncheckedUpdateInput>
    /**
     * Choose, which ChallengeInstructions to update.
     */
    where: ChallengeInstructionsWhereUniqueInput
  }

  /**
   * ChallengeInstructions updateMany
   */
  export type ChallengeInstructionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeInstructions.
     */
    data: XOR<ChallengeInstructionsUpdateManyMutationInput, ChallengeInstructionsUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeInstructions to update
     */
    where?: ChallengeInstructionsWhereInput
    /**
     * Limit how many ChallengeInstructions to update.
     */
    limit?: number
  }

  /**
   * ChallengeInstructions updateManyAndReturn
   */
  export type ChallengeInstructionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeInstructions.
     */
    data: XOR<ChallengeInstructionsUpdateManyMutationInput, ChallengeInstructionsUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeInstructions to update
     */
    where?: ChallengeInstructionsWhereInput
    /**
     * Limit how many ChallengeInstructions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeInstructions upsert
   */
  export type ChallengeInstructionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeInstructions to update in case it exists.
     */
    where: ChallengeInstructionsWhereUniqueInput
    /**
     * In case the ChallengeInstructions found by the `where` argument doesn't exist, create a new ChallengeInstructions with this data.
     */
    create: XOR<ChallengeInstructionsCreateInput, ChallengeInstructionsUncheckedCreateInput>
    /**
     * In case the ChallengeInstructions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeInstructionsUpdateInput, ChallengeInstructionsUncheckedUpdateInput>
  }

  /**
   * ChallengeInstructions delete
   */
  export type ChallengeInstructionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
    /**
     * Filter which ChallengeInstructions to delete.
     */
    where: ChallengeInstructionsWhereUniqueInput
  }

  /**
   * ChallengeInstructions deleteMany
   */
  export type ChallengeInstructionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeInstructions to delete
     */
    where?: ChallengeInstructionsWhereInput
    /**
     * Limit how many ChallengeInstructions to delete.
     */
    limit?: number
  }

  /**
   * ChallengeInstructions without action
   */
  export type ChallengeInstructionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstructions
     */
    select?: ChallengeInstructionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstructions
     */
    omit?: ChallengeInstructionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstructionsInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeSolutions
   */

  export type AggregateChallengeSolutions = {
    _count: ChallengeSolutionsCountAggregateOutputType | null
    _avg: ChallengeSolutionsAvgAggregateOutputType | null
    _sum: ChallengeSolutionsSumAggregateOutputType | null
    _min: ChallengeSolutionsMinAggregateOutputType | null
    _max: ChallengeSolutionsMaxAggregateOutputType | null
  }

  export type ChallengeSolutionsAvgAggregateOutputType = {
    id: number | null
    number: number | null
    challengeId: number | null
  }

  export type ChallengeSolutionsSumAggregateOutputType = {
    id: number | null
    number: number | null
    challengeId: number | null
  }

  export type ChallengeSolutionsMinAggregateOutputType = {
    id: number | null
    number: number | null
    solution: string | null
    challengeId: number | null
  }

  export type ChallengeSolutionsMaxAggregateOutputType = {
    id: number | null
    number: number | null
    solution: string | null
    challengeId: number | null
  }

  export type ChallengeSolutionsCountAggregateOutputType = {
    id: number
    number: number
    solution: number
    challengeId: number
    _all: number
  }


  export type ChallengeSolutionsAvgAggregateInputType = {
    id?: true
    number?: true
    challengeId?: true
  }

  export type ChallengeSolutionsSumAggregateInputType = {
    id?: true
    number?: true
    challengeId?: true
  }

  export type ChallengeSolutionsMinAggregateInputType = {
    id?: true
    number?: true
    solution?: true
    challengeId?: true
  }

  export type ChallengeSolutionsMaxAggregateInputType = {
    id?: true
    number?: true
    solution?: true
    challengeId?: true
  }

  export type ChallengeSolutionsCountAggregateInputType = {
    id?: true
    number?: true
    solution?: true
    challengeId?: true
    _all?: true
  }

  export type ChallengeSolutionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeSolutions to aggregate.
     */
    where?: ChallengeSolutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSolutions to fetch.
     */
    orderBy?: ChallengeSolutionsOrderByWithRelationInput | ChallengeSolutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeSolutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeSolutions
    **/
    _count?: true | ChallengeSolutionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeSolutionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSolutionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeSolutionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeSolutionsMaxAggregateInputType
  }

  export type GetChallengeSolutionsAggregateType<T extends ChallengeSolutionsAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeSolutions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeSolutions[P]>
      : GetScalarType<T[P], AggregateChallengeSolutions[P]>
  }




  export type ChallengeSolutionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeSolutionsWhereInput
    orderBy?: ChallengeSolutionsOrderByWithAggregationInput | ChallengeSolutionsOrderByWithAggregationInput[]
    by: ChallengeSolutionsScalarFieldEnum[] | ChallengeSolutionsScalarFieldEnum
    having?: ChallengeSolutionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeSolutionsCountAggregateInputType | true
    _avg?: ChallengeSolutionsAvgAggregateInputType
    _sum?: ChallengeSolutionsSumAggregateInputType
    _min?: ChallengeSolutionsMinAggregateInputType
    _max?: ChallengeSolutionsMaxAggregateInputType
  }

  export type ChallengeSolutionsGroupByOutputType = {
    id: number
    number: number
    solution: string
    challengeId: number
    _count: ChallengeSolutionsCountAggregateOutputType | null
    _avg: ChallengeSolutionsAvgAggregateOutputType | null
    _sum: ChallengeSolutionsSumAggregateOutputType | null
    _min: ChallengeSolutionsMinAggregateOutputType | null
    _max: ChallengeSolutionsMaxAggregateOutputType | null
  }

  type GetChallengeSolutionsGroupByPayload<T extends ChallengeSolutionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeSolutionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeSolutionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeSolutionsGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeSolutionsGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSolutionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    solution?: boolean
    challengeId?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeSolutions"]>

  export type ChallengeSolutionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    solution?: boolean
    challengeId?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeSolutions"]>

  export type ChallengeSolutionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    solution?: boolean
    challengeId?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeSolutions"]>

  export type ChallengeSolutionsSelectScalar = {
    id?: boolean
    number?: boolean
    solution?: boolean
    challengeId?: boolean
  }

  export type ChallengeSolutionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "solution" | "challengeId", ExtArgs["result"]["challengeSolutions"]>
  export type ChallengeSolutionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeSolutionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeSolutionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeSolutionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeSolutions"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: number
      solution: string
      challengeId: number
    }, ExtArgs["result"]["challengeSolutions"]>
    composites: {}
  }

  type ChallengeSolutionsGetPayload<S extends boolean | null | undefined | ChallengeSolutionsDefaultArgs> = $Result.GetResult<Prisma.$ChallengeSolutionsPayload, S>

  type ChallengeSolutionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeSolutionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeSolutionsCountAggregateInputType | true
    }

  export interface ChallengeSolutionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeSolutions'], meta: { name: 'ChallengeSolutions' } }
    /**
     * Find zero or one ChallengeSolutions that matches the filter.
     * @param {ChallengeSolutionsFindUniqueArgs} args - Arguments to find a ChallengeSolutions
     * @example
     * // Get one ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeSolutionsFindUniqueArgs>(args: SelectSubset<T, ChallengeSolutionsFindUniqueArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeSolutions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeSolutionsFindUniqueOrThrowArgs} args - Arguments to find a ChallengeSolutions
     * @example
     * // Get one ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeSolutionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeSolutionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeSolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSolutionsFindFirstArgs} args - Arguments to find a ChallengeSolutions
     * @example
     * // Get one ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeSolutionsFindFirstArgs>(args?: SelectSubset<T, ChallengeSolutionsFindFirstArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeSolutions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSolutionsFindFirstOrThrowArgs} args - Arguments to find a ChallengeSolutions
     * @example
     * // Get one ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeSolutionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeSolutionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeSolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSolutionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.findMany()
     * 
     * // Get first 10 ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeSolutionsWithIdOnly = await prisma.challengeSolutions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeSolutionsFindManyArgs>(args?: SelectSubset<T, ChallengeSolutionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeSolutions.
     * @param {ChallengeSolutionsCreateArgs} args - Arguments to create a ChallengeSolutions.
     * @example
     * // Create one ChallengeSolutions
     * const ChallengeSolutions = await prisma.challengeSolutions.create({
     *   data: {
     *     // ... data to create a ChallengeSolutions
     *   }
     * })
     * 
     */
    create<T extends ChallengeSolutionsCreateArgs>(args: SelectSubset<T, ChallengeSolutionsCreateArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeSolutions.
     * @param {ChallengeSolutionsCreateManyArgs} args - Arguments to create many ChallengeSolutions.
     * @example
     * // Create many ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeSolutionsCreateManyArgs>(args?: SelectSubset<T, ChallengeSolutionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeSolutions and returns the data saved in the database.
     * @param {ChallengeSolutionsCreateManyAndReturnArgs} args - Arguments to create many ChallengeSolutions.
     * @example
     * // Create many ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeSolutions and only return the `id`
     * const challengeSolutionsWithIdOnly = await prisma.challengeSolutions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeSolutionsCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeSolutionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeSolutions.
     * @param {ChallengeSolutionsDeleteArgs} args - Arguments to delete one ChallengeSolutions.
     * @example
     * // Delete one ChallengeSolutions
     * const ChallengeSolutions = await prisma.challengeSolutions.delete({
     *   where: {
     *     // ... filter to delete one ChallengeSolutions
     *   }
     * })
     * 
     */
    delete<T extends ChallengeSolutionsDeleteArgs>(args: SelectSubset<T, ChallengeSolutionsDeleteArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeSolutions.
     * @param {ChallengeSolutionsUpdateArgs} args - Arguments to update one ChallengeSolutions.
     * @example
     * // Update one ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeSolutionsUpdateArgs>(args: SelectSubset<T, ChallengeSolutionsUpdateArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeSolutions.
     * @param {ChallengeSolutionsDeleteManyArgs} args - Arguments to filter ChallengeSolutions to delete.
     * @example
     * // Delete a few ChallengeSolutions
     * const { count } = await prisma.challengeSolutions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeSolutionsDeleteManyArgs>(args?: SelectSubset<T, ChallengeSolutionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSolutionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeSolutionsUpdateManyArgs>(args: SelectSubset<T, ChallengeSolutionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeSolutions and returns the data updated in the database.
     * @param {ChallengeSolutionsUpdateManyAndReturnArgs} args - Arguments to update many ChallengeSolutions.
     * @example
     * // Update many ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeSolutions and only return the `id`
     * const challengeSolutionsWithIdOnly = await prisma.challengeSolutions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeSolutionsUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeSolutionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeSolutions.
     * @param {ChallengeSolutionsUpsertArgs} args - Arguments to update or create a ChallengeSolutions.
     * @example
     * // Update or create a ChallengeSolutions
     * const challengeSolutions = await prisma.challengeSolutions.upsert({
     *   create: {
     *     // ... data to create a ChallengeSolutions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeSolutions we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeSolutionsUpsertArgs>(args: SelectSubset<T, ChallengeSolutionsUpsertArgs<ExtArgs>>): Prisma__ChallengeSolutionsClient<$Result.GetResult<Prisma.$ChallengeSolutionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSolutionsCountArgs} args - Arguments to filter ChallengeSolutions to count.
     * @example
     * // Count the number of ChallengeSolutions
     * const count = await prisma.challengeSolutions.count({
     *   where: {
     *     // ... the filter for the ChallengeSolutions we want to count
     *   }
     * })
    **/
    count<T extends ChallengeSolutionsCountArgs>(
      args?: Subset<T, ChallengeSolutionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeSolutionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSolutionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeSolutionsAggregateArgs>(args: Subset<T, ChallengeSolutionsAggregateArgs>): Prisma.PrismaPromise<GetChallengeSolutionsAggregateType<T>>

    /**
     * Group by ChallengeSolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSolutionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeSolutionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeSolutionsGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeSolutionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeSolutionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeSolutionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeSolutions model
   */
  readonly fields: ChallengeSolutionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeSolutions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeSolutionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeSolutions model
   */
  interface ChallengeSolutionsFieldRefs {
    readonly id: FieldRef<"ChallengeSolutions", 'Int'>
    readonly number: FieldRef<"ChallengeSolutions", 'Int'>
    readonly solution: FieldRef<"ChallengeSolutions", 'String'>
    readonly challengeId: FieldRef<"ChallengeSolutions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeSolutions findUnique
   */
  export type ChallengeSolutionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSolutions to fetch.
     */
    where: ChallengeSolutionsWhereUniqueInput
  }

  /**
   * ChallengeSolutions findUniqueOrThrow
   */
  export type ChallengeSolutionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSolutions to fetch.
     */
    where: ChallengeSolutionsWhereUniqueInput
  }

  /**
   * ChallengeSolutions findFirst
   */
  export type ChallengeSolutionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSolutions to fetch.
     */
    where?: ChallengeSolutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSolutions to fetch.
     */
    orderBy?: ChallengeSolutionsOrderByWithRelationInput | ChallengeSolutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeSolutions.
     */
    cursor?: ChallengeSolutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeSolutions.
     */
    distinct?: ChallengeSolutionsScalarFieldEnum | ChallengeSolutionsScalarFieldEnum[]
  }

  /**
   * ChallengeSolutions findFirstOrThrow
   */
  export type ChallengeSolutionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSolutions to fetch.
     */
    where?: ChallengeSolutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSolutions to fetch.
     */
    orderBy?: ChallengeSolutionsOrderByWithRelationInput | ChallengeSolutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeSolutions.
     */
    cursor?: ChallengeSolutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeSolutions.
     */
    distinct?: ChallengeSolutionsScalarFieldEnum | ChallengeSolutionsScalarFieldEnum[]
  }

  /**
   * ChallengeSolutions findMany
   */
  export type ChallengeSolutionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeSolutions to fetch.
     */
    where?: ChallengeSolutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeSolutions to fetch.
     */
    orderBy?: ChallengeSolutionsOrderByWithRelationInput | ChallengeSolutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeSolutions.
     */
    cursor?: ChallengeSolutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeSolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeSolutions.
     */
    skip?: number
    distinct?: ChallengeSolutionsScalarFieldEnum | ChallengeSolutionsScalarFieldEnum[]
  }

  /**
   * ChallengeSolutions create
   */
  export type ChallengeSolutionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeSolutions.
     */
    data: XOR<ChallengeSolutionsCreateInput, ChallengeSolutionsUncheckedCreateInput>
  }

  /**
   * ChallengeSolutions createMany
   */
  export type ChallengeSolutionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeSolutions.
     */
    data: ChallengeSolutionsCreateManyInput | ChallengeSolutionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeSolutions createManyAndReturn
   */
  export type ChallengeSolutionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeSolutions.
     */
    data: ChallengeSolutionsCreateManyInput | ChallengeSolutionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeSolutions update
   */
  export type ChallengeSolutionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeSolutions.
     */
    data: XOR<ChallengeSolutionsUpdateInput, ChallengeSolutionsUncheckedUpdateInput>
    /**
     * Choose, which ChallengeSolutions to update.
     */
    where: ChallengeSolutionsWhereUniqueInput
  }

  /**
   * ChallengeSolutions updateMany
   */
  export type ChallengeSolutionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeSolutions.
     */
    data: XOR<ChallengeSolutionsUpdateManyMutationInput, ChallengeSolutionsUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeSolutions to update
     */
    where?: ChallengeSolutionsWhereInput
    /**
     * Limit how many ChallengeSolutions to update.
     */
    limit?: number
  }

  /**
   * ChallengeSolutions updateManyAndReturn
   */
  export type ChallengeSolutionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeSolutions.
     */
    data: XOR<ChallengeSolutionsUpdateManyMutationInput, ChallengeSolutionsUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeSolutions to update
     */
    where?: ChallengeSolutionsWhereInput
    /**
     * Limit how many ChallengeSolutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeSolutions upsert
   */
  export type ChallengeSolutionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeSolutions to update in case it exists.
     */
    where: ChallengeSolutionsWhereUniqueInput
    /**
     * In case the ChallengeSolutions found by the `where` argument doesn't exist, create a new ChallengeSolutions with this data.
     */
    create: XOR<ChallengeSolutionsCreateInput, ChallengeSolutionsUncheckedCreateInput>
    /**
     * In case the ChallengeSolutions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeSolutionsUpdateInput, ChallengeSolutionsUncheckedUpdateInput>
  }

  /**
   * ChallengeSolutions delete
   */
  export type ChallengeSolutionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
    /**
     * Filter which ChallengeSolutions to delete.
     */
    where: ChallengeSolutionsWhereUniqueInput
  }

  /**
   * ChallengeSolutions deleteMany
   */
  export type ChallengeSolutionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeSolutions to delete
     */
    where?: ChallengeSolutionsWhereInput
    /**
     * Limit how many ChallengeSolutions to delete.
     */
    limit?: number
  }

  /**
   * ChallengeSolutions without action
   */
  export type ChallengeSolutionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeSolutions
     */
    select?: ChallengeSolutionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeSolutions
     */
    omit?: ChallengeSolutionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSolutionsInclude<ExtArgs> | null
  }


  /**
   * Model CompletedChallenges
   */

  export type AggregateCompletedChallenges = {
    _count: CompletedChallengesCountAggregateOutputType | null
    _avg: CompletedChallengesAvgAggregateOutputType | null
    _sum: CompletedChallengesSumAggregateOutputType | null
    _min: CompletedChallengesMinAggregateOutputType | null
    _max: CompletedChallengesMaxAggregateOutputType | null
  }

  export type CompletedChallengesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
  }

  export type CompletedChallengesSumAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
  }

  export type CompletedChallengesMinAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
    createdAt: Date | null
  }

  export type CompletedChallengesMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    challengeId: number | null
    createdAt: Date | null
  }

  export type CompletedChallengesCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    createdAt: number
    _all: number
  }


  export type CompletedChallengesAvgAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
  }

  export type CompletedChallengesSumAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
  }

  export type CompletedChallengesMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    createdAt?: true
  }

  export type CompletedChallengesMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    createdAt?: true
  }

  export type CompletedChallengesCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    createdAt?: true
    _all?: true
  }

  export type CompletedChallengesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletedChallenges to aggregate.
     */
    where?: CompletedChallengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedChallenges to fetch.
     */
    orderBy?: CompletedChallengesOrderByWithRelationInput | CompletedChallengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompletedChallengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompletedChallenges
    **/
    _count?: true | CompletedChallengesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompletedChallengesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompletedChallengesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompletedChallengesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompletedChallengesMaxAggregateInputType
  }

  export type GetCompletedChallengesAggregateType<T extends CompletedChallengesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompletedChallenges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompletedChallenges[P]>
      : GetScalarType<T[P], AggregateCompletedChallenges[P]>
  }




  export type CompletedChallengesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedChallengesWhereInput
    orderBy?: CompletedChallengesOrderByWithAggregationInput | CompletedChallengesOrderByWithAggregationInput[]
    by: CompletedChallengesScalarFieldEnum[] | CompletedChallengesScalarFieldEnum
    having?: CompletedChallengesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompletedChallengesCountAggregateInputType | true
    _avg?: CompletedChallengesAvgAggregateInputType
    _sum?: CompletedChallengesSumAggregateInputType
    _min?: CompletedChallengesMinAggregateInputType
    _max?: CompletedChallengesMaxAggregateInputType
  }

  export type CompletedChallengesGroupByOutputType = {
    id: number
    userId: number
    challengeId: number
    createdAt: Date
    _count: CompletedChallengesCountAggregateOutputType | null
    _avg: CompletedChallengesAvgAggregateOutputType | null
    _sum: CompletedChallengesSumAggregateOutputType | null
    _min: CompletedChallengesMinAggregateOutputType | null
    _max: CompletedChallengesMaxAggregateOutputType | null
  }

  type GetCompletedChallengesGroupByPayload<T extends CompletedChallengesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompletedChallengesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompletedChallengesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompletedChallengesGroupByOutputType[P]>
            : GetScalarType<T[P], CompletedChallengesGroupByOutputType[P]>
        }
      >
    >


  export type CompletedChallengesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    Course?: boolean | CompletedChallenges$CourseArgs<ExtArgs>
    _count?: boolean | CompletedChallengesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["completedChallenges"]>

  export type CompletedChallengesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["completedChallenges"]>

  export type CompletedChallengesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["completedChallenges"]>

  export type CompletedChallengesSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    createdAt?: boolean
  }

  export type CompletedChallengesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "challengeId" | "createdAt", ExtArgs["result"]["completedChallenges"]>
  export type CompletedChallengesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    Course?: boolean | CompletedChallenges$CourseArgs<ExtArgs>
    _count?: boolean | CompletedChallengesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompletedChallengesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type CompletedChallengesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $CompletedChallengesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompletedChallenges"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
      Course: Prisma.$CoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      challengeId: number
      createdAt: Date
    }, ExtArgs["result"]["completedChallenges"]>
    composites: {}
  }

  type CompletedChallengesGetPayload<S extends boolean | null | undefined | CompletedChallengesDefaultArgs> = $Result.GetResult<Prisma.$CompletedChallengesPayload, S>

  type CompletedChallengesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompletedChallengesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompletedChallengesCountAggregateInputType | true
    }

  export interface CompletedChallengesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompletedChallenges'], meta: { name: 'CompletedChallenges' } }
    /**
     * Find zero or one CompletedChallenges that matches the filter.
     * @param {CompletedChallengesFindUniqueArgs} args - Arguments to find a CompletedChallenges
     * @example
     * // Get one CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompletedChallengesFindUniqueArgs>(args: SelectSubset<T, CompletedChallengesFindUniqueArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompletedChallenges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompletedChallengesFindUniqueOrThrowArgs} args - Arguments to find a CompletedChallenges
     * @example
     * // Get one CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompletedChallengesFindUniqueOrThrowArgs>(args: SelectSubset<T, CompletedChallengesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompletedChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedChallengesFindFirstArgs} args - Arguments to find a CompletedChallenges
     * @example
     * // Get one CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompletedChallengesFindFirstArgs>(args?: SelectSubset<T, CompletedChallengesFindFirstArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompletedChallenges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedChallengesFindFirstOrThrowArgs} args - Arguments to find a CompletedChallenges
     * @example
     * // Get one CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompletedChallengesFindFirstOrThrowArgs>(args?: SelectSubset<T, CompletedChallengesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompletedChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedChallengesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.findMany()
     * 
     * // Get first 10 CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const completedChallengesWithIdOnly = await prisma.completedChallenges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompletedChallengesFindManyArgs>(args?: SelectSubset<T, CompletedChallengesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompletedChallenges.
     * @param {CompletedChallengesCreateArgs} args - Arguments to create a CompletedChallenges.
     * @example
     * // Create one CompletedChallenges
     * const CompletedChallenges = await prisma.completedChallenges.create({
     *   data: {
     *     // ... data to create a CompletedChallenges
     *   }
     * })
     * 
     */
    create<T extends CompletedChallengesCreateArgs>(args: SelectSubset<T, CompletedChallengesCreateArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompletedChallenges.
     * @param {CompletedChallengesCreateManyArgs} args - Arguments to create many CompletedChallenges.
     * @example
     * // Create many CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompletedChallengesCreateManyArgs>(args?: SelectSubset<T, CompletedChallengesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompletedChallenges and returns the data saved in the database.
     * @param {CompletedChallengesCreateManyAndReturnArgs} args - Arguments to create many CompletedChallenges.
     * @example
     * // Create many CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompletedChallenges and only return the `id`
     * const completedChallengesWithIdOnly = await prisma.completedChallenges.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompletedChallengesCreateManyAndReturnArgs>(args?: SelectSubset<T, CompletedChallengesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompletedChallenges.
     * @param {CompletedChallengesDeleteArgs} args - Arguments to delete one CompletedChallenges.
     * @example
     * // Delete one CompletedChallenges
     * const CompletedChallenges = await prisma.completedChallenges.delete({
     *   where: {
     *     // ... filter to delete one CompletedChallenges
     *   }
     * })
     * 
     */
    delete<T extends CompletedChallengesDeleteArgs>(args: SelectSubset<T, CompletedChallengesDeleteArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompletedChallenges.
     * @param {CompletedChallengesUpdateArgs} args - Arguments to update one CompletedChallenges.
     * @example
     * // Update one CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompletedChallengesUpdateArgs>(args: SelectSubset<T, CompletedChallengesUpdateArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompletedChallenges.
     * @param {CompletedChallengesDeleteManyArgs} args - Arguments to filter CompletedChallenges to delete.
     * @example
     * // Delete a few CompletedChallenges
     * const { count } = await prisma.completedChallenges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompletedChallengesDeleteManyArgs>(args?: SelectSubset<T, CompletedChallengesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletedChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedChallengesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompletedChallengesUpdateManyArgs>(args: SelectSubset<T, CompletedChallengesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletedChallenges and returns the data updated in the database.
     * @param {CompletedChallengesUpdateManyAndReturnArgs} args - Arguments to update many CompletedChallenges.
     * @example
     * // Update many CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompletedChallenges and only return the `id`
     * const completedChallengesWithIdOnly = await prisma.completedChallenges.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompletedChallengesUpdateManyAndReturnArgs>(args: SelectSubset<T, CompletedChallengesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompletedChallenges.
     * @param {CompletedChallengesUpsertArgs} args - Arguments to update or create a CompletedChallenges.
     * @example
     * // Update or create a CompletedChallenges
     * const completedChallenges = await prisma.completedChallenges.upsert({
     *   create: {
     *     // ... data to create a CompletedChallenges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompletedChallenges we want to update
     *   }
     * })
     */
    upsert<T extends CompletedChallengesUpsertArgs>(args: SelectSubset<T, CompletedChallengesUpsertArgs<ExtArgs>>): Prisma__CompletedChallengesClient<$Result.GetResult<Prisma.$CompletedChallengesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompletedChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedChallengesCountArgs} args - Arguments to filter CompletedChallenges to count.
     * @example
     * // Count the number of CompletedChallenges
     * const count = await prisma.completedChallenges.count({
     *   where: {
     *     // ... the filter for the CompletedChallenges we want to count
     *   }
     * })
    **/
    count<T extends CompletedChallengesCountArgs>(
      args?: Subset<T, CompletedChallengesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompletedChallengesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompletedChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedChallengesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompletedChallengesAggregateArgs>(args: Subset<T, CompletedChallengesAggregateArgs>): Prisma.PrismaPromise<GetCompletedChallengesAggregateType<T>>

    /**
     * Group by CompletedChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedChallengesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompletedChallengesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompletedChallengesGroupByArgs['orderBy'] }
        : { orderBy?: CompletedChallengesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompletedChallengesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompletedChallengesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompletedChallenges model
   */
  readonly fields: CompletedChallengesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompletedChallenges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompletedChallengesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Course<T extends CompletedChallenges$CourseArgs<ExtArgs> = {}>(args?: Subset<T, CompletedChallenges$CourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompletedChallenges model
   */
  interface CompletedChallengesFieldRefs {
    readonly id: FieldRef<"CompletedChallenges", 'Int'>
    readonly userId: FieldRef<"CompletedChallenges", 'Int'>
    readonly challengeId: FieldRef<"CompletedChallenges", 'Int'>
    readonly createdAt: FieldRef<"CompletedChallenges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompletedChallenges findUnique
   */
  export type CompletedChallengesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * Filter, which CompletedChallenges to fetch.
     */
    where: CompletedChallengesWhereUniqueInput
  }

  /**
   * CompletedChallenges findUniqueOrThrow
   */
  export type CompletedChallengesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * Filter, which CompletedChallenges to fetch.
     */
    where: CompletedChallengesWhereUniqueInput
  }

  /**
   * CompletedChallenges findFirst
   */
  export type CompletedChallengesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * Filter, which CompletedChallenges to fetch.
     */
    where?: CompletedChallengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedChallenges to fetch.
     */
    orderBy?: CompletedChallengesOrderByWithRelationInput | CompletedChallengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletedChallenges.
     */
    cursor?: CompletedChallengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletedChallenges.
     */
    distinct?: CompletedChallengesScalarFieldEnum | CompletedChallengesScalarFieldEnum[]
  }

  /**
   * CompletedChallenges findFirstOrThrow
   */
  export type CompletedChallengesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * Filter, which CompletedChallenges to fetch.
     */
    where?: CompletedChallengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedChallenges to fetch.
     */
    orderBy?: CompletedChallengesOrderByWithRelationInput | CompletedChallengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletedChallenges.
     */
    cursor?: CompletedChallengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletedChallenges.
     */
    distinct?: CompletedChallengesScalarFieldEnum | CompletedChallengesScalarFieldEnum[]
  }

  /**
   * CompletedChallenges findMany
   */
  export type CompletedChallengesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * Filter, which CompletedChallenges to fetch.
     */
    where?: CompletedChallengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedChallenges to fetch.
     */
    orderBy?: CompletedChallengesOrderByWithRelationInput | CompletedChallengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompletedChallenges.
     */
    cursor?: CompletedChallengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedChallenges.
     */
    skip?: number
    distinct?: CompletedChallengesScalarFieldEnum | CompletedChallengesScalarFieldEnum[]
  }

  /**
   * CompletedChallenges create
   */
  export type CompletedChallengesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * The data needed to create a CompletedChallenges.
     */
    data: XOR<CompletedChallengesCreateInput, CompletedChallengesUncheckedCreateInput>
  }

  /**
   * CompletedChallenges createMany
   */
  export type CompletedChallengesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompletedChallenges.
     */
    data: CompletedChallengesCreateManyInput | CompletedChallengesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompletedChallenges createManyAndReturn
   */
  export type CompletedChallengesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * The data used to create many CompletedChallenges.
     */
    data: CompletedChallengesCreateManyInput | CompletedChallengesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompletedChallenges update
   */
  export type CompletedChallengesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * The data needed to update a CompletedChallenges.
     */
    data: XOR<CompletedChallengesUpdateInput, CompletedChallengesUncheckedUpdateInput>
    /**
     * Choose, which CompletedChallenges to update.
     */
    where: CompletedChallengesWhereUniqueInput
  }

  /**
   * CompletedChallenges updateMany
   */
  export type CompletedChallengesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompletedChallenges.
     */
    data: XOR<CompletedChallengesUpdateManyMutationInput, CompletedChallengesUncheckedUpdateManyInput>
    /**
     * Filter which CompletedChallenges to update
     */
    where?: CompletedChallengesWhereInput
    /**
     * Limit how many CompletedChallenges to update.
     */
    limit?: number
  }

  /**
   * CompletedChallenges updateManyAndReturn
   */
  export type CompletedChallengesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * The data used to update CompletedChallenges.
     */
    data: XOR<CompletedChallengesUpdateManyMutationInput, CompletedChallengesUncheckedUpdateManyInput>
    /**
     * Filter which CompletedChallenges to update
     */
    where?: CompletedChallengesWhereInput
    /**
     * Limit how many CompletedChallenges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompletedChallenges upsert
   */
  export type CompletedChallengesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * The filter to search for the CompletedChallenges to update in case it exists.
     */
    where: CompletedChallengesWhereUniqueInput
    /**
     * In case the CompletedChallenges found by the `where` argument doesn't exist, create a new CompletedChallenges with this data.
     */
    create: XOR<CompletedChallengesCreateInput, CompletedChallengesUncheckedCreateInput>
    /**
     * In case the CompletedChallenges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompletedChallengesUpdateInput, CompletedChallengesUncheckedUpdateInput>
  }

  /**
   * CompletedChallenges delete
   */
  export type CompletedChallengesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
    /**
     * Filter which CompletedChallenges to delete.
     */
    where: CompletedChallengesWhereUniqueInput
  }

  /**
   * CompletedChallenges deleteMany
   */
  export type CompletedChallengesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletedChallenges to delete
     */
    where?: CompletedChallengesWhereInput
    /**
     * Limit how many CompletedChallenges to delete.
     */
    limit?: number
  }

  /**
   * CompletedChallenges.Course
   */
  export type CompletedChallenges$CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * CompletedChallenges without action
   */
  export type CompletedChallengesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedChallenges
     */
    select?: CompletedChallengesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedChallenges
     */
    omit?: CompletedChallengesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompletedChallengesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    hash: 'hash',
    username: 'username',
    role: 'role',
    isPremium: 'isPremium',
    provider: 'provider',
    photo: 'photo',
    courseId: 'courseId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileImageScalarFieldEnum: {
    id: 'id',
    path: 'path',
    userId: 'userId'
  };

  export type UserProfileImageScalarFieldEnum = (typeof UserProfileImageScalarFieldEnum)[keyof typeof UserProfileImageScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    title: 'title',
    category: 'category',
    level: 'level',
    description: 'description',
    duration: 'duration',
    studentsCount: 'studentsCount',
    rating: 'rating',
    likes: 'likes',
    completions: 'completions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    createdAt: 'createdAt'
  };

  export type CourseLikeScalarFieldEnum = (typeof CourseLikeScalarFieldEnum)[keyof typeof CourseLikeScalarFieldEnum]


  export const UserCourseProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    currentStep: 'currentStep',
    completed: 'completed',
    startedAt: 'startedAt',
    updatedAt: 'updatedAt',
    rating: 'rating'
  };

  export type UserCourseProgressScalarFieldEnum = (typeof UserCourseProgressScalarFieldEnum)[keyof typeof UserCourseProgressScalarFieldEnum]


  export const CourseModuleScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    number: 'number'
  };

  export type CourseModuleScalarFieldEnum = (typeof CourseModuleScalarFieldEnum)[keyof typeof CourseModuleScalarFieldEnum]


  export const UserModuleProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseModuleId: 'courseModuleId',
    currentStep: 'currentStep',
    completed: 'completed',
    startedAt: 'startedAt',
    updatedAt: 'updatedAt',
    courseId: 'courseId'
  };

  export type UserModuleProgressScalarFieldEnum = (typeof UserModuleProgressScalarFieldEnum)[keyof typeof UserModuleProgressScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    number: 'number',
    url: 'url'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const MiniModuleScalarFieldEnum: {
    id: 'id',
    courseModuleId: 'courseModuleId',
    title: 'title',
    number: 'number'
  };

  export type MiniModuleScalarFieldEnum = (typeof MiniModuleScalarFieldEnum)[keyof typeof MiniModuleScalarFieldEnum]


  export const MiniModuleProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    miniModuleId: 'miniModuleId',
    currentStep: 'currentStep',
    completed: 'completed',
    startedAt: 'startedAt',
    updatedAt: 'updatedAt'
  };

  export type MiniModuleProgressScalarFieldEnum = (typeof MiniModuleProgressScalarFieldEnum)[keyof typeof MiniModuleProgressScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    explanation: 'explanation',
    more: 'more',
    example: 'example',
    note: 'note',
    assignment: 'assignment',
    number: 'number',
    miniModuleId: 'miniModuleId'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const LessonVideoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    number: 'number',
    url: 'url',
    miniModuleId: 'miniModuleId'
  };

  export type LessonVideoScalarFieldEnum = (typeof LessonVideoScalarFieldEnum)[keyof typeof LessonVideoScalarFieldEnum]


  export const LessonSolutionScalarFieldEnum: {
    id: 'id',
    solution: 'solution',
    lessonId: 'lessonId'
  };

  export type LessonSolutionScalarFieldEnum = (typeof LessonSolutionScalarFieldEnum)[keyof typeof LessonSolutionScalarFieldEnum]


  export const UserLessonProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lessonId: 'lessonId',
    currentStep: 'currentStep',
    completed: 'completed',
    startedAt: 'startedAt',
    updatedAt: 'updatedAt'
  };

  export type UserLessonProgressScalarFieldEnum = (typeof UserLessonProgressScalarFieldEnum)[keyof typeof UserLessonProgressScalarFieldEnum]


  export const CourseRatingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type CourseRatingScalarFieldEnum = (typeof CourseRatingScalarFieldEnum)[keyof typeof CourseRatingScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    difficulty: 'difficulty',
    title: 'title',
    description: 'description',
    relation: 'relation',
    duration: 'duration',
    useEditor: 'useEditor',
    likes: 'likes'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    content: 'content',
    type: 'type',
    createdAt: 'createdAt',
    read: 'read'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ChallengeLikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId'
  };

  export type ChallengeLikeScalarFieldEnum = (typeof ChallengeLikeScalarFieldEnum)[keyof typeof ChallengeLikeScalarFieldEnum]


  export const ChallengeInstructionsScalarFieldEnum: {
    id: 'id',
    number: 'number',
    instruction: 'instruction',
    completed: 'completed',
    challengeId: 'challengeId'
  };

  export type ChallengeInstructionsScalarFieldEnum = (typeof ChallengeInstructionsScalarFieldEnum)[keyof typeof ChallengeInstructionsScalarFieldEnum]


  export const ChallengeSolutionsScalarFieldEnum: {
    id: 'id',
    number: 'number',
    solution: 'solution',
    challengeId: 'challengeId'
  };

  export type ChallengeSolutionsScalarFieldEnum = (typeof ChallengeSolutionsScalarFieldEnum)[keyof typeof ChallengeSolutionsScalarFieldEnum]


  export const CompletedChallengesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    createdAt: 'createdAt'
  };

  export type CompletedChallengesScalarFieldEnum = (typeof CompletedChallengesScalarFieldEnum)[keyof typeof CompletedChallengesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Level'
   */
  export type EnumLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Level'>
    


  /**
   * Reference to a field of type 'Level[]'
   */
  export type ListEnumLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Level[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    hash?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isPremium?: BoolFilter<"User"> | boolean
    provider?: StringFilter<"User"> | string
    photo?: StringNullableFilter<"User"> | string | null
    courseId?: IntNullableFilter<"User"> | number | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    ratings?: CourseRatingListRelationFilter
    ChallengeLike?: ChallengeLikeListRelationFilter
    image?: UserProfileImageListRelationFilter
    createdCourses?: CourseListRelationFilter
    progress?: UserCourseProgressListRelationFilter
    userModuleProgress?: UserModuleProgressListRelationFilter
    MiniModuleProgress?: MiniModuleProgressListRelationFilter
    userLessonProgress?: UserLessonProgressListRelationFilter
    courseLikes?: CourseLikeListRelationFilter
    CompletedChallenges?: CompletedChallengesListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    hash?: SortOrder
    username?: SortOrderInput | SortOrder
    role?: SortOrder
    isPremium?: SortOrder
    provider?: SortOrder
    photo?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
    ratings?: CourseRatingOrderByRelationAggregateInput
    ChallengeLike?: ChallengeLikeOrderByRelationAggregateInput
    image?: UserProfileImageOrderByRelationAggregateInput
    createdCourses?: CourseOrderByRelationAggregateInput
    progress?: UserCourseProgressOrderByRelationAggregateInput
    userModuleProgress?: userModuleProgressOrderByRelationAggregateInput
    MiniModuleProgress?: MiniModuleProgressOrderByRelationAggregateInput
    userLessonProgress?: UserLessonProgressOrderByRelationAggregateInput
    courseLikes?: CourseLikeOrderByRelationAggregateInput
    CompletedChallenges?: CompletedChallengesOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    hash?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isPremium?: BoolFilter<"User"> | boolean
    provider?: StringFilter<"User"> | string
    photo?: StringNullableFilter<"User"> | string | null
    courseId?: IntNullableFilter<"User"> | number | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    ratings?: CourseRatingListRelationFilter
    ChallengeLike?: ChallengeLikeListRelationFilter
    image?: UserProfileImageListRelationFilter
    createdCourses?: CourseListRelationFilter
    progress?: UserCourseProgressListRelationFilter
    userModuleProgress?: UserModuleProgressListRelationFilter
    MiniModuleProgress?: MiniModuleProgressListRelationFilter
    userLessonProgress?: UserLessonProgressListRelationFilter
    courseLikes?: CourseLikeListRelationFilter
    CompletedChallenges?: CompletedChallengesListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    hash?: SortOrder
    username?: SortOrderInput | SortOrder
    role?: SortOrder
    isPremium?: SortOrder
    provider?: SortOrder
    photo?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringWithAggregatesFilter<"User"> | string
    hash?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isPremium?: BoolWithAggregatesFilter<"User"> | boolean
    provider?: StringWithAggregatesFilter<"User"> | string
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    courseId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type UserProfileImageWhereInput = {
    AND?: UserProfileImageWhereInput | UserProfileImageWhereInput[]
    OR?: UserProfileImageWhereInput[]
    NOT?: UserProfileImageWhereInput | UserProfileImageWhereInput[]
    id?: IntFilter<"UserProfileImage"> | number
    path?: StringFilter<"UserProfileImage"> | string
    userId?: IntFilter<"UserProfileImage"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProfileImageOrderByWithRelationInput = {
    id?: SortOrder
    path?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: UserProfileImageWhereInput | UserProfileImageWhereInput[]
    OR?: UserProfileImageWhereInput[]
    NOT?: UserProfileImageWhereInput | UserProfileImageWhereInput[]
    path?: StringFilter<"UserProfileImage"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileImageOrderByWithAggregationInput = {
    id?: SortOrder
    path?: SortOrder
    userId?: SortOrder
    _count?: UserProfileImageCountOrderByAggregateInput
    _avg?: UserProfileImageAvgOrderByAggregateInput
    _max?: UserProfileImageMaxOrderByAggregateInput
    _min?: UserProfileImageMinOrderByAggregateInput
    _sum?: UserProfileImageSumOrderByAggregateInput
  }

  export type UserProfileImageScalarWhereWithAggregatesInput = {
    AND?: UserProfileImageScalarWhereWithAggregatesInput | UserProfileImageScalarWhereWithAggregatesInput[]
    OR?: UserProfileImageScalarWhereWithAggregatesInput[]
    NOT?: UserProfileImageScalarWhereWithAggregatesInput | UserProfileImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserProfileImage"> | number
    path?: StringWithAggregatesFilter<"UserProfileImage"> | string
    userId?: IntWithAggregatesFilter<"UserProfileImage"> | number
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: IntFilter<"Course"> | number
    creatorId?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    category?: StringFilter<"Course"> | string
    level?: EnumLevelFilter<"Course"> | $Enums.Level
    description?: StringFilter<"Course"> | string
    duration?: StringFilter<"Course"> | string
    studentsCount?: IntFilter<"Course"> | number
    rating?: FloatFilter<"Course"> | number
    likes?: IntFilter<"Course"> | number
    completions?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    modules?: CourseModuleListRelationFilter
    progress?: UserCourseProgressListRelationFilter
    ratings?: CourseRatingListRelationFilter
    videos?: VideoListRelationFilter
    users?: UserListRelationFilter
    likedBy?: CourseLikeListRelationFilter
    completedChallenges?: CompletedChallengesListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    studentsCount?: SortOrder
    rating?: SortOrder
    likes?: SortOrder
    completions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    modules?: CourseModuleOrderByRelationAggregateInput
    progress?: UserCourseProgressOrderByRelationAggregateInput
    ratings?: CourseRatingOrderByRelationAggregateInput
    videos?: VideoOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    likedBy?: CourseLikeOrderByRelationAggregateInput
    completedChallenges?: CompletedChallengesOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    creatorId?: IntFilter<"Course"> | number
    category?: StringFilter<"Course"> | string
    level?: EnumLevelFilter<"Course"> | $Enums.Level
    description?: StringFilter<"Course"> | string
    duration?: StringFilter<"Course"> | string
    studentsCount?: IntFilter<"Course"> | number
    rating?: FloatFilter<"Course"> | number
    likes?: IntFilter<"Course"> | number
    completions?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    modules?: CourseModuleListRelationFilter
    progress?: UserCourseProgressListRelationFilter
    ratings?: CourseRatingListRelationFilter
    videos?: VideoListRelationFilter
    users?: UserListRelationFilter
    likedBy?: CourseLikeListRelationFilter
    completedChallenges?: CompletedChallengesListRelationFilter
  }, "id" | "title">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    studentsCount?: SortOrder
    rating?: SortOrder
    likes?: SortOrder
    completions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Course"> | number
    creatorId?: IntWithAggregatesFilter<"Course"> | number
    title?: StringWithAggregatesFilter<"Course"> | string
    category?: StringWithAggregatesFilter<"Course"> | string
    level?: EnumLevelWithAggregatesFilter<"Course"> | $Enums.Level
    description?: StringWithAggregatesFilter<"Course"> | string
    duration?: StringWithAggregatesFilter<"Course"> | string
    studentsCount?: IntWithAggregatesFilter<"Course"> | number
    rating?: FloatWithAggregatesFilter<"Course"> | number
    likes?: IntWithAggregatesFilter<"Course"> | number
    completions?: IntWithAggregatesFilter<"Course"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseLikeWhereInput = {
    AND?: CourseLikeWhereInput | CourseLikeWhereInput[]
    OR?: CourseLikeWhereInput[]
    NOT?: CourseLikeWhereInput | CourseLikeWhereInput[]
    id?: IntFilter<"CourseLike"> | number
    userId?: IntFilter<"CourseLike"> | number
    courseId?: IntFilter<"CourseLike"> | number
    createdAt?: DateTimeFilter<"CourseLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseLikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CourseLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_courseId?: CourseLikeUserIdCourseIdCompoundUniqueInput
    AND?: CourseLikeWhereInput | CourseLikeWhereInput[]
    OR?: CourseLikeWhereInput[]
    NOT?: CourseLikeWhereInput | CourseLikeWhereInput[]
    userId?: IntFilter<"CourseLike"> | number
    courseId?: IntFilter<"CourseLike"> | number
    createdAt?: DateTimeFilter<"CourseLike"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type CourseLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    _count?: CourseLikeCountOrderByAggregateInput
    _avg?: CourseLikeAvgOrderByAggregateInput
    _max?: CourseLikeMaxOrderByAggregateInput
    _min?: CourseLikeMinOrderByAggregateInput
    _sum?: CourseLikeSumOrderByAggregateInput
  }

  export type CourseLikeScalarWhereWithAggregatesInput = {
    AND?: CourseLikeScalarWhereWithAggregatesInput | CourseLikeScalarWhereWithAggregatesInput[]
    OR?: CourseLikeScalarWhereWithAggregatesInput[]
    NOT?: CourseLikeScalarWhereWithAggregatesInput | CourseLikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseLike"> | number
    userId?: IntWithAggregatesFilter<"CourseLike"> | number
    courseId?: IntWithAggregatesFilter<"CourseLike"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CourseLike"> | Date | string
  }

  export type UserCourseProgressWhereInput = {
    AND?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    OR?: UserCourseProgressWhereInput[]
    NOT?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    id?: IntFilter<"UserCourseProgress"> | number
    userId?: IntFilter<"UserCourseProgress"> | number
    courseId?: IntFilter<"UserCourseProgress"> | number
    currentStep?: IntFilter<"UserCourseProgress"> | number
    completed?: BoolFilter<"UserCourseProgress"> | boolean
    startedAt?: DateTimeFilter<"UserCourseProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseProgress"> | Date | string
    rating?: IntNullableFilter<"UserCourseProgress"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type UserCourseProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type UserCourseProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    OR?: UserCourseProgressWhereInput[]
    NOT?: UserCourseProgressWhereInput | UserCourseProgressWhereInput[]
    userId?: IntFilter<"UserCourseProgress"> | number
    courseId?: IntFilter<"UserCourseProgress"> | number
    currentStep?: IntFilter<"UserCourseProgress"> | number
    completed?: BoolFilter<"UserCourseProgress"> | boolean
    startedAt?: DateTimeFilter<"UserCourseProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseProgress"> | Date | string
    rating?: IntNullableFilter<"UserCourseProgress"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type UserCourseProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrderInput | SortOrder
    _count?: UserCourseProgressCountOrderByAggregateInput
    _avg?: UserCourseProgressAvgOrderByAggregateInput
    _max?: UserCourseProgressMaxOrderByAggregateInput
    _min?: UserCourseProgressMinOrderByAggregateInput
    _sum?: UserCourseProgressSumOrderByAggregateInput
  }

  export type UserCourseProgressScalarWhereWithAggregatesInput = {
    AND?: UserCourseProgressScalarWhereWithAggregatesInput | UserCourseProgressScalarWhereWithAggregatesInput[]
    OR?: UserCourseProgressScalarWhereWithAggregatesInput[]
    NOT?: UserCourseProgressScalarWhereWithAggregatesInput | UserCourseProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserCourseProgress"> | number
    userId?: IntWithAggregatesFilter<"UserCourseProgress"> | number
    courseId?: IntWithAggregatesFilter<"UserCourseProgress"> | number
    currentStep?: IntWithAggregatesFilter<"UserCourseProgress"> | number
    completed?: BoolWithAggregatesFilter<"UserCourseProgress"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"UserCourseProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserCourseProgress"> | Date | string
    rating?: IntNullableWithAggregatesFilter<"UserCourseProgress"> | number | null
  }

  export type CourseModuleWhereInput = {
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    id?: IntFilter<"CourseModule"> | number
    courseId?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    number?: IntFilter<"CourseModule"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    miniModules?: MiniModuleListRelationFilter
    progress?: UserModuleProgressListRelationFilter
  }

  export type CourseModuleOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    course?: CourseOrderByWithRelationInput
    miniModules?: MiniModuleOrderByRelationAggregateInput
    progress?: userModuleProgressOrderByRelationAggregateInput
  }

  export type CourseModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    courseId_number?: CourseModuleCourseIdNumberCompoundUniqueInput
    AND?: CourseModuleWhereInput | CourseModuleWhereInput[]
    OR?: CourseModuleWhereInput[]
    NOT?: CourseModuleWhereInput | CourseModuleWhereInput[]
    courseId?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    number?: IntFilter<"CourseModule"> | number
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    miniModules?: MiniModuleListRelationFilter
    progress?: UserModuleProgressListRelationFilter
  }, "id" | "courseId_number">

  export type CourseModuleOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    _count?: CourseModuleCountOrderByAggregateInput
    _avg?: CourseModuleAvgOrderByAggregateInput
    _max?: CourseModuleMaxOrderByAggregateInput
    _min?: CourseModuleMinOrderByAggregateInput
    _sum?: CourseModuleSumOrderByAggregateInput
  }

  export type CourseModuleScalarWhereWithAggregatesInput = {
    AND?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    OR?: CourseModuleScalarWhereWithAggregatesInput[]
    NOT?: CourseModuleScalarWhereWithAggregatesInput | CourseModuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseModule"> | number
    courseId?: IntWithAggregatesFilter<"CourseModule"> | number
    title?: StringWithAggregatesFilter<"CourseModule"> | string
    number?: IntWithAggregatesFilter<"CourseModule"> | number
  }

  export type userModuleProgressWhereInput = {
    AND?: userModuleProgressWhereInput | userModuleProgressWhereInput[]
    OR?: userModuleProgressWhereInput[]
    NOT?: userModuleProgressWhereInput | userModuleProgressWhereInput[]
    id?: IntFilter<"userModuleProgress"> | number
    userId?: IntFilter<"userModuleProgress"> | number
    courseModuleId?: IntFilter<"userModuleProgress"> | number
    currentStep?: IntFilter<"userModuleProgress"> | number
    completed?: BoolFilter<"userModuleProgress"> | boolean
    startedAt?: DateTimeFilter<"userModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"userModuleProgress"> | Date | string
    courseId?: IntNullableFilter<"userModuleProgress"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courseModule?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
  }

  export type userModuleProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    courseModule?: CourseModuleOrderByWithRelationInput
  }

  export type userModuleProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userModuleProgressWhereInput | userModuleProgressWhereInput[]
    OR?: userModuleProgressWhereInput[]
    NOT?: userModuleProgressWhereInput | userModuleProgressWhereInput[]
    userId?: IntFilter<"userModuleProgress"> | number
    courseModuleId?: IntFilter<"userModuleProgress"> | number
    currentStep?: IntFilter<"userModuleProgress"> | number
    completed?: BoolFilter<"userModuleProgress"> | boolean
    startedAt?: DateTimeFilter<"userModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"userModuleProgress"> | Date | string
    courseId?: IntNullableFilter<"userModuleProgress"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    courseModule?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
  }, "id">

  export type userModuleProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrderInput | SortOrder
    _count?: userModuleProgressCountOrderByAggregateInput
    _avg?: userModuleProgressAvgOrderByAggregateInput
    _max?: userModuleProgressMaxOrderByAggregateInput
    _min?: userModuleProgressMinOrderByAggregateInput
    _sum?: userModuleProgressSumOrderByAggregateInput
  }

  export type userModuleProgressScalarWhereWithAggregatesInput = {
    AND?: userModuleProgressScalarWhereWithAggregatesInput | userModuleProgressScalarWhereWithAggregatesInput[]
    OR?: userModuleProgressScalarWhereWithAggregatesInput[]
    NOT?: userModuleProgressScalarWhereWithAggregatesInput | userModuleProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userModuleProgress"> | number
    userId?: IntWithAggregatesFilter<"userModuleProgress"> | number
    courseModuleId?: IntWithAggregatesFilter<"userModuleProgress"> | number
    currentStep?: IntWithAggregatesFilter<"userModuleProgress"> | number
    completed?: BoolWithAggregatesFilter<"userModuleProgress"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"userModuleProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"userModuleProgress"> | Date | string
    courseId?: IntNullableWithAggregatesFilter<"userModuleProgress"> | number | null
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: IntFilter<"Video"> | number
    courseId?: IntFilter<"Video"> | number
    title?: StringFilter<"Video"> | string
    number?: IntFilter<"Video"> | number
    url?: StringFilter<"Video"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    courseId_number?: VideoCourseIdNumberCompoundUniqueInput
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    courseId?: IntFilter<"Video"> | number
    title?: StringFilter<"Video"> | string
    number?: IntFilter<"Video"> | number
    url?: StringFilter<"Video"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "courseId_number">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Video"> | number
    courseId?: IntWithAggregatesFilter<"Video"> | number
    title?: StringWithAggregatesFilter<"Video"> | string
    number?: IntWithAggregatesFilter<"Video"> | number
    url?: StringWithAggregatesFilter<"Video"> | string
  }

  export type MiniModuleWhereInput = {
    AND?: MiniModuleWhereInput | MiniModuleWhereInput[]
    OR?: MiniModuleWhereInput[]
    NOT?: MiniModuleWhereInput | MiniModuleWhereInput[]
    id?: IntFilter<"MiniModule"> | number
    courseModuleId?: IntFilter<"MiniModule"> | number
    title?: StringFilter<"MiniModule"> | string
    number?: IntFilter<"MiniModule"> | number
    courseModule?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    lessons?: LessonListRelationFilter
    lessonVideos?: LessonVideoListRelationFilter
    progress?: MiniModuleProgressListRelationFilter
  }

  export type MiniModuleOrderByWithRelationInput = {
    id?: SortOrder
    courseModuleId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    courseModule?: CourseModuleOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
    lessonVideos?: LessonVideoOrderByRelationAggregateInput
    progress?: MiniModuleProgressOrderByRelationAggregateInput
  }

  export type MiniModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    courseModuleId_number?: MiniModuleCourseModuleIdNumberCompoundUniqueInput
    AND?: MiniModuleWhereInput | MiniModuleWhereInput[]
    OR?: MiniModuleWhereInput[]
    NOT?: MiniModuleWhereInput | MiniModuleWhereInput[]
    courseModuleId?: IntFilter<"MiniModule"> | number
    title?: StringFilter<"MiniModule"> | string
    number?: IntFilter<"MiniModule"> | number
    courseModule?: XOR<CourseModuleScalarRelationFilter, CourseModuleWhereInput>
    lessons?: LessonListRelationFilter
    lessonVideos?: LessonVideoListRelationFilter
    progress?: MiniModuleProgressListRelationFilter
  }, "id" | "courseModuleId_number">

  export type MiniModuleOrderByWithAggregationInput = {
    id?: SortOrder
    courseModuleId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    _count?: MiniModuleCountOrderByAggregateInput
    _avg?: MiniModuleAvgOrderByAggregateInput
    _max?: MiniModuleMaxOrderByAggregateInput
    _min?: MiniModuleMinOrderByAggregateInput
    _sum?: MiniModuleSumOrderByAggregateInput
  }

  export type MiniModuleScalarWhereWithAggregatesInput = {
    AND?: MiniModuleScalarWhereWithAggregatesInput | MiniModuleScalarWhereWithAggregatesInput[]
    OR?: MiniModuleScalarWhereWithAggregatesInput[]
    NOT?: MiniModuleScalarWhereWithAggregatesInput | MiniModuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MiniModule"> | number
    courseModuleId?: IntWithAggregatesFilter<"MiniModule"> | number
    title?: StringWithAggregatesFilter<"MiniModule"> | string
    number?: IntWithAggregatesFilter<"MiniModule"> | number
  }

  export type MiniModuleProgressWhereInput = {
    AND?: MiniModuleProgressWhereInput | MiniModuleProgressWhereInput[]
    OR?: MiniModuleProgressWhereInput[]
    NOT?: MiniModuleProgressWhereInput | MiniModuleProgressWhereInput[]
    id?: IntFilter<"MiniModuleProgress"> | number
    userId?: IntFilter<"MiniModuleProgress"> | number
    miniModuleId?: IntFilter<"MiniModuleProgress"> | number
    currentStep?: IntFilter<"MiniModuleProgress"> | number
    completed?: BoolFilter<"MiniModuleProgress"> | boolean
    startedAt?: DateTimeFilter<"MiniModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"MiniModuleProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    miniModule?: XOR<MiniModuleScalarRelationFilter, MiniModuleWhereInput>
  }

  export type MiniModuleProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    miniModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    miniModule?: MiniModuleOrderByWithRelationInput
  }

  export type MiniModuleProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MiniModuleProgressWhereInput | MiniModuleProgressWhereInput[]
    OR?: MiniModuleProgressWhereInput[]
    NOT?: MiniModuleProgressWhereInput | MiniModuleProgressWhereInput[]
    userId?: IntFilter<"MiniModuleProgress"> | number
    miniModuleId?: IntFilter<"MiniModuleProgress"> | number
    currentStep?: IntFilter<"MiniModuleProgress"> | number
    completed?: BoolFilter<"MiniModuleProgress"> | boolean
    startedAt?: DateTimeFilter<"MiniModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"MiniModuleProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    miniModule?: XOR<MiniModuleScalarRelationFilter, MiniModuleWhereInput>
  }, "id">

  export type MiniModuleProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    miniModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MiniModuleProgressCountOrderByAggregateInput
    _avg?: MiniModuleProgressAvgOrderByAggregateInput
    _max?: MiniModuleProgressMaxOrderByAggregateInput
    _min?: MiniModuleProgressMinOrderByAggregateInput
    _sum?: MiniModuleProgressSumOrderByAggregateInput
  }

  export type MiniModuleProgressScalarWhereWithAggregatesInput = {
    AND?: MiniModuleProgressScalarWhereWithAggregatesInput | MiniModuleProgressScalarWhereWithAggregatesInput[]
    OR?: MiniModuleProgressScalarWhereWithAggregatesInput[]
    NOT?: MiniModuleProgressScalarWhereWithAggregatesInput | MiniModuleProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MiniModuleProgress"> | number
    userId?: IntWithAggregatesFilter<"MiniModuleProgress"> | number
    miniModuleId?: IntWithAggregatesFilter<"MiniModuleProgress"> | number
    currentStep?: IntWithAggregatesFilter<"MiniModuleProgress"> | number
    completed?: BoolWithAggregatesFilter<"MiniModuleProgress"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"MiniModuleProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MiniModuleProgress"> | Date | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: IntFilter<"Lesson"> | number
    title?: StringFilter<"Lesson"> | string
    explanation?: StringFilter<"Lesson"> | string
    more?: StringNullableFilter<"Lesson"> | string | null
    example?: StringNullableFilter<"Lesson"> | string | null
    note?: StringNullableFilter<"Lesson"> | string | null
    assignment?: StringFilter<"Lesson"> | string
    number?: IntFilter<"Lesson"> | number
    miniModuleId?: IntFilter<"Lesson"> | number
    miniModule?: XOR<MiniModuleScalarRelationFilter, MiniModuleWhereInput>
    solutions?: LessonSolutionListRelationFilter
    progress?: UserLessonProgressListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    explanation?: SortOrder
    more?: SortOrderInput | SortOrder
    example?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    assignment?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
    miniModule?: MiniModuleOrderByWithRelationInput
    solutions?: LessonSolutionOrderByRelationAggregateInput
    progress?: UserLessonProgressOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    title?: StringFilter<"Lesson"> | string
    explanation?: StringFilter<"Lesson"> | string
    more?: StringNullableFilter<"Lesson"> | string | null
    example?: StringNullableFilter<"Lesson"> | string | null
    note?: StringNullableFilter<"Lesson"> | string | null
    assignment?: StringFilter<"Lesson"> | string
    number?: IntFilter<"Lesson"> | number
    miniModuleId?: IntFilter<"Lesson"> | number
    miniModule?: XOR<MiniModuleScalarRelationFilter, MiniModuleWhereInput>
    solutions?: LessonSolutionListRelationFilter
    progress?: UserLessonProgressListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    explanation?: SortOrder
    more?: SortOrderInput | SortOrder
    example?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    assignment?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lesson"> | number
    title?: StringWithAggregatesFilter<"Lesson"> | string
    explanation?: StringWithAggregatesFilter<"Lesson"> | string
    more?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    example?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    note?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    assignment?: StringWithAggregatesFilter<"Lesson"> | string
    number?: IntWithAggregatesFilter<"Lesson"> | number
    miniModuleId?: IntWithAggregatesFilter<"Lesson"> | number
  }

  export type LessonVideoWhereInput = {
    AND?: LessonVideoWhereInput | LessonVideoWhereInput[]
    OR?: LessonVideoWhereInput[]
    NOT?: LessonVideoWhereInput | LessonVideoWhereInput[]
    id?: IntFilter<"LessonVideo"> | number
    title?: StringFilter<"LessonVideo"> | string
    number?: IntFilter<"LessonVideo"> | number
    url?: StringFilter<"LessonVideo"> | string
    miniModuleId?: IntFilter<"LessonVideo"> | number
    miniModule?: XOR<MiniModuleScalarRelationFilter, MiniModuleWhereInput>
  }

  export type LessonVideoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
    miniModuleId?: SortOrder
    miniModule?: MiniModuleOrderByWithRelationInput
  }

  export type LessonVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    miniModuleId_number?: LessonVideoMiniModuleIdNumberCompoundUniqueInput
    AND?: LessonVideoWhereInput | LessonVideoWhereInput[]
    OR?: LessonVideoWhereInput[]
    NOT?: LessonVideoWhereInput | LessonVideoWhereInput[]
    title?: StringFilter<"LessonVideo"> | string
    number?: IntFilter<"LessonVideo"> | number
    url?: StringFilter<"LessonVideo"> | string
    miniModuleId?: IntFilter<"LessonVideo"> | number
    miniModule?: XOR<MiniModuleScalarRelationFilter, MiniModuleWhereInput>
  }, "id" | "miniModuleId_number">

  export type LessonVideoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
    miniModuleId?: SortOrder
    _count?: LessonVideoCountOrderByAggregateInput
    _avg?: LessonVideoAvgOrderByAggregateInput
    _max?: LessonVideoMaxOrderByAggregateInput
    _min?: LessonVideoMinOrderByAggregateInput
    _sum?: LessonVideoSumOrderByAggregateInput
  }

  export type LessonVideoScalarWhereWithAggregatesInput = {
    AND?: LessonVideoScalarWhereWithAggregatesInput | LessonVideoScalarWhereWithAggregatesInput[]
    OR?: LessonVideoScalarWhereWithAggregatesInput[]
    NOT?: LessonVideoScalarWhereWithAggregatesInput | LessonVideoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LessonVideo"> | number
    title?: StringWithAggregatesFilter<"LessonVideo"> | string
    number?: IntWithAggregatesFilter<"LessonVideo"> | number
    url?: StringWithAggregatesFilter<"LessonVideo"> | string
    miniModuleId?: IntWithAggregatesFilter<"LessonVideo"> | number
  }

  export type LessonSolutionWhereInput = {
    AND?: LessonSolutionWhereInput | LessonSolutionWhereInput[]
    OR?: LessonSolutionWhereInput[]
    NOT?: LessonSolutionWhereInput | LessonSolutionWhereInput[]
    id?: IntFilter<"LessonSolution"> | number
    solution?: StringFilter<"LessonSolution"> | string
    lessonId?: IntFilter<"LessonSolution"> | number
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type LessonSolutionOrderByWithRelationInput = {
    id?: SortOrder
    solution?: SortOrder
    lessonId?: SortOrder
    lesson?: LessonOrderByWithRelationInput
  }

  export type LessonSolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lessonId?: number
    AND?: LessonSolutionWhereInput | LessonSolutionWhereInput[]
    OR?: LessonSolutionWhereInput[]
    NOT?: LessonSolutionWhereInput | LessonSolutionWhereInput[]
    solution?: StringFilter<"LessonSolution"> | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id" | "lessonId">

  export type LessonSolutionOrderByWithAggregationInput = {
    id?: SortOrder
    solution?: SortOrder
    lessonId?: SortOrder
    _count?: LessonSolutionCountOrderByAggregateInput
    _avg?: LessonSolutionAvgOrderByAggregateInput
    _max?: LessonSolutionMaxOrderByAggregateInput
    _min?: LessonSolutionMinOrderByAggregateInput
    _sum?: LessonSolutionSumOrderByAggregateInput
  }

  export type LessonSolutionScalarWhereWithAggregatesInput = {
    AND?: LessonSolutionScalarWhereWithAggregatesInput | LessonSolutionScalarWhereWithAggregatesInput[]
    OR?: LessonSolutionScalarWhereWithAggregatesInput[]
    NOT?: LessonSolutionScalarWhereWithAggregatesInput | LessonSolutionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LessonSolution"> | number
    solution?: StringWithAggregatesFilter<"LessonSolution"> | string
    lessonId?: IntWithAggregatesFilter<"LessonSolution"> | number
  }

  export type UserLessonProgressWhereInput = {
    AND?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    OR?: UserLessonProgressWhereInput[]
    NOT?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    id?: IntFilter<"UserLessonProgress"> | number
    userId?: IntFilter<"UserLessonProgress"> | number
    lessonId?: IntFilter<"UserLessonProgress"> | number
    currentStep?: IntFilter<"UserLessonProgress"> | number
    completed?: BoolFilter<"UserLessonProgress"> | boolean
    startedAt?: DateTimeFilter<"UserLessonProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserLessonProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type UserLessonProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type UserLessonProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    OR?: UserLessonProgressWhereInput[]
    NOT?: UserLessonProgressWhereInput | UserLessonProgressWhereInput[]
    userId?: IntFilter<"UserLessonProgress"> | number
    lessonId?: IntFilter<"UserLessonProgress"> | number
    currentStep?: IntFilter<"UserLessonProgress"> | number
    completed?: BoolFilter<"UserLessonProgress"> | boolean
    startedAt?: DateTimeFilter<"UserLessonProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserLessonProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id">

  export type UserLessonProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserLessonProgressCountOrderByAggregateInput
    _avg?: UserLessonProgressAvgOrderByAggregateInput
    _max?: UserLessonProgressMaxOrderByAggregateInput
    _min?: UserLessonProgressMinOrderByAggregateInput
    _sum?: UserLessonProgressSumOrderByAggregateInput
  }

  export type UserLessonProgressScalarWhereWithAggregatesInput = {
    AND?: UserLessonProgressScalarWhereWithAggregatesInput | UserLessonProgressScalarWhereWithAggregatesInput[]
    OR?: UserLessonProgressScalarWhereWithAggregatesInput[]
    NOT?: UserLessonProgressScalarWhereWithAggregatesInput | UserLessonProgressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserLessonProgress"> | number
    userId?: IntWithAggregatesFilter<"UserLessonProgress"> | number
    lessonId?: IntWithAggregatesFilter<"UserLessonProgress"> | number
    currentStep?: IntWithAggregatesFilter<"UserLessonProgress"> | number
    completed?: BoolWithAggregatesFilter<"UserLessonProgress"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"UserLessonProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLessonProgress"> | Date | string
  }

  export type CourseRatingWhereInput = {
    AND?: CourseRatingWhereInput | CourseRatingWhereInput[]
    OR?: CourseRatingWhereInput[]
    NOT?: CourseRatingWhereInput | CourseRatingWhereInput[]
    id?: IntFilter<"CourseRating"> | number
    userId?: IntFilter<"CourseRating"> | number
    courseId?: IntFilter<"CourseRating"> | number
    rating?: IntFilter<"CourseRating"> | number
    comment?: StringNullableFilter<"CourseRating"> | string | null
    createdAt?: DateTimeFilter<"CourseRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type CourseRatingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CourseRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseRatingWhereInput | CourseRatingWhereInput[]
    OR?: CourseRatingWhereInput[]
    NOT?: CourseRatingWhereInput | CourseRatingWhereInput[]
    userId?: IntFilter<"CourseRating"> | number
    courseId?: IntFilter<"CourseRating"> | number
    rating?: IntFilter<"CourseRating"> | number
    comment?: StringNullableFilter<"CourseRating"> | string | null
    createdAt?: DateTimeFilter<"CourseRating"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type CourseRatingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourseRatingCountOrderByAggregateInput
    _avg?: CourseRatingAvgOrderByAggregateInput
    _max?: CourseRatingMaxOrderByAggregateInput
    _min?: CourseRatingMinOrderByAggregateInput
    _sum?: CourseRatingSumOrderByAggregateInput
  }

  export type CourseRatingScalarWhereWithAggregatesInput = {
    AND?: CourseRatingScalarWhereWithAggregatesInput | CourseRatingScalarWhereWithAggregatesInput[]
    OR?: CourseRatingScalarWhereWithAggregatesInput[]
    NOT?: CourseRatingScalarWhereWithAggregatesInput | CourseRatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseRating"> | number
    userId?: IntWithAggregatesFilter<"CourseRating"> | number
    courseId?: IntWithAggregatesFilter<"CourseRating"> | number
    rating?: IntWithAggregatesFilter<"CourseRating"> | number
    comment?: StringNullableWithAggregatesFilter<"CourseRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourseRating"> | Date | string
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: IntFilter<"Challenge"> | number
    difficulty?: StringFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    relation?: StringNullableFilter<"Challenge"> | string | null
    duration?: StringFilter<"Challenge"> | string
    useEditor?: BoolFilter<"Challenge"> | boolean
    likes?: IntFilter<"Challenge"> | number
    instructions?: ChallengeInstructionsListRelationFilter
    likesList?: ChallengeLikeListRelationFilter
    solutions?: ChallengeSolutionsListRelationFilter
    completions?: CompletedChallengesListRelationFilter
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    difficulty?: SortOrder
    title?: SortOrder
    description?: SortOrder
    relation?: SortOrderInput | SortOrder
    duration?: SortOrder
    useEditor?: SortOrder
    likes?: SortOrder
    instructions?: ChallengeInstructionsOrderByRelationAggregateInput
    likesList?: ChallengeLikeOrderByRelationAggregateInput
    solutions?: ChallengeSolutionsOrderByRelationAggregateInput
    completions?: CompletedChallengesOrderByRelationAggregateInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    difficulty?: StringFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    relation?: StringNullableFilter<"Challenge"> | string | null
    duration?: StringFilter<"Challenge"> | string
    useEditor?: BoolFilter<"Challenge"> | boolean
    likes?: IntFilter<"Challenge"> | number
    instructions?: ChallengeInstructionsListRelationFilter
    likesList?: ChallengeLikeListRelationFilter
    solutions?: ChallengeSolutionsListRelationFilter
    completions?: CompletedChallengesListRelationFilter
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    difficulty?: SortOrder
    title?: SortOrder
    description?: SortOrder
    relation?: SortOrderInput | SortOrder
    duration?: SortOrder
    useEditor?: SortOrder
    likes?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Challenge"> | number
    difficulty?: StringWithAggregatesFilter<"Challenge"> | string
    title?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringWithAggregatesFilter<"Challenge"> | string
    relation?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    duration?: StringWithAggregatesFilter<"Challenge"> | string
    useEditor?: BoolWithAggregatesFilter<"Challenge"> | boolean
    likes?: IntWithAggregatesFilter<"Challenge"> | number
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    senderId?: IntFilter<"Message"> | number
    receiverId?: IntFilter<"Message"> | number
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    read?: BoolFilter<"Message"> | boolean
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    read?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: IntFilter<"Message"> | number
    receiverId?: IntFilter<"Message"> | number
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    read?: BoolFilter<"Message"> | boolean
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    read?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    senderId?: IntWithAggregatesFilter<"Message"> | number
    receiverId?: IntWithAggregatesFilter<"Message"> | number
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    read?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type ChallengeLikeWhereInput = {
    AND?: ChallengeLikeWhereInput | ChallengeLikeWhereInput[]
    OR?: ChallengeLikeWhereInput[]
    NOT?: ChallengeLikeWhereInput | ChallengeLikeWhereInput[]
    id?: IntFilter<"ChallengeLike"> | number
    userId?: IntFilter<"ChallengeLike"> | number
    challengeId?: IntFilter<"ChallengeLike"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeLikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ChallengeLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_challengeId?: ChallengeLikeUserIdChallengeIdCompoundUniqueInput
    AND?: ChallengeLikeWhereInput | ChallengeLikeWhereInput[]
    OR?: ChallengeLikeWhereInput[]
    NOT?: ChallengeLikeWhereInput | ChallengeLikeWhereInput[]
    userId?: IntFilter<"ChallengeLike"> | number
    challengeId?: IntFilter<"ChallengeLike"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "userId_challengeId">

  export type ChallengeLikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    _count?: ChallengeLikeCountOrderByAggregateInput
    _avg?: ChallengeLikeAvgOrderByAggregateInput
    _max?: ChallengeLikeMaxOrderByAggregateInput
    _min?: ChallengeLikeMinOrderByAggregateInput
    _sum?: ChallengeLikeSumOrderByAggregateInput
  }

  export type ChallengeLikeScalarWhereWithAggregatesInput = {
    AND?: ChallengeLikeScalarWhereWithAggregatesInput | ChallengeLikeScalarWhereWithAggregatesInput[]
    OR?: ChallengeLikeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeLikeScalarWhereWithAggregatesInput | ChallengeLikeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeLike"> | number
    userId?: IntWithAggregatesFilter<"ChallengeLike"> | number
    challengeId?: IntWithAggregatesFilter<"ChallengeLike"> | number
  }

  export type ChallengeInstructionsWhereInput = {
    AND?: ChallengeInstructionsWhereInput | ChallengeInstructionsWhereInput[]
    OR?: ChallengeInstructionsWhereInput[]
    NOT?: ChallengeInstructionsWhereInput | ChallengeInstructionsWhereInput[]
    id?: IntFilter<"ChallengeInstructions"> | number
    number?: IntFilter<"ChallengeInstructions"> | number
    instruction?: StringFilter<"ChallengeInstructions"> | string
    completed?: BoolFilter<"ChallengeInstructions"> | boolean
    challengeId?: IntFilter<"ChallengeInstructions"> | number
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeInstructionsOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    instruction?: SortOrder
    completed?: SortOrder
    challengeId?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ChallengeInstructionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeInstructionsWhereInput | ChallengeInstructionsWhereInput[]
    OR?: ChallengeInstructionsWhereInput[]
    NOT?: ChallengeInstructionsWhereInput | ChallengeInstructionsWhereInput[]
    number?: IntFilter<"ChallengeInstructions"> | number
    instruction?: StringFilter<"ChallengeInstructions"> | string
    completed?: BoolFilter<"ChallengeInstructions"> | boolean
    challengeId?: IntFilter<"ChallengeInstructions"> | number
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeInstructionsOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    instruction?: SortOrder
    completed?: SortOrder
    challengeId?: SortOrder
    _count?: ChallengeInstructionsCountOrderByAggregateInput
    _avg?: ChallengeInstructionsAvgOrderByAggregateInput
    _max?: ChallengeInstructionsMaxOrderByAggregateInput
    _min?: ChallengeInstructionsMinOrderByAggregateInput
    _sum?: ChallengeInstructionsSumOrderByAggregateInput
  }

  export type ChallengeInstructionsScalarWhereWithAggregatesInput = {
    AND?: ChallengeInstructionsScalarWhereWithAggregatesInput | ChallengeInstructionsScalarWhereWithAggregatesInput[]
    OR?: ChallengeInstructionsScalarWhereWithAggregatesInput[]
    NOT?: ChallengeInstructionsScalarWhereWithAggregatesInput | ChallengeInstructionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeInstructions"> | number
    number?: IntWithAggregatesFilter<"ChallengeInstructions"> | number
    instruction?: StringWithAggregatesFilter<"ChallengeInstructions"> | string
    completed?: BoolWithAggregatesFilter<"ChallengeInstructions"> | boolean
    challengeId?: IntWithAggregatesFilter<"ChallengeInstructions"> | number
  }

  export type ChallengeSolutionsWhereInput = {
    AND?: ChallengeSolutionsWhereInput | ChallengeSolutionsWhereInput[]
    OR?: ChallengeSolutionsWhereInput[]
    NOT?: ChallengeSolutionsWhereInput | ChallengeSolutionsWhereInput[]
    id?: IntFilter<"ChallengeSolutions"> | number
    number?: IntFilter<"ChallengeSolutions"> | number
    solution?: StringFilter<"ChallengeSolutions"> | string
    challengeId?: IntFilter<"ChallengeSolutions"> | number
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeSolutionsOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    solution?: SortOrder
    challengeId?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ChallengeSolutionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    number?: number
    AND?: ChallengeSolutionsWhereInput | ChallengeSolutionsWhereInput[]
    OR?: ChallengeSolutionsWhereInput[]
    NOT?: ChallengeSolutionsWhereInput | ChallengeSolutionsWhereInput[]
    solution?: StringFilter<"ChallengeSolutions"> | string
    challengeId?: IntFilter<"ChallengeSolutions"> | number
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id" | "number">

  export type ChallengeSolutionsOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    solution?: SortOrder
    challengeId?: SortOrder
    _count?: ChallengeSolutionsCountOrderByAggregateInput
    _avg?: ChallengeSolutionsAvgOrderByAggregateInput
    _max?: ChallengeSolutionsMaxOrderByAggregateInput
    _min?: ChallengeSolutionsMinOrderByAggregateInput
    _sum?: ChallengeSolutionsSumOrderByAggregateInput
  }

  export type ChallengeSolutionsScalarWhereWithAggregatesInput = {
    AND?: ChallengeSolutionsScalarWhereWithAggregatesInput | ChallengeSolutionsScalarWhereWithAggregatesInput[]
    OR?: ChallengeSolutionsScalarWhereWithAggregatesInput[]
    NOT?: ChallengeSolutionsScalarWhereWithAggregatesInput | ChallengeSolutionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeSolutions"> | number
    number?: IntWithAggregatesFilter<"ChallengeSolutions"> | number
    solution?: StringWithAggregatesFilter<"ChallengeSolutions"> | string
    challengeId?: IntWithAggregatesFilter<"ChallengeSolutions"> | number
  }

  export type CompletedChallengesWhereInput = {
    AND?: CompletedChallengesWhereInput | CompletedChallengesWhereInput[]
    OR?: CompletedChallengesWhereInput[]
    NOT?: CompletedChallengesWhereInput | CompletedChallengesWhereInput[]
    id?: IntFilter<"CompletedChallenges"> | number
    userId?: IntFilter<"CompletedChallenges"> | number
    challengeId?: IntFilter<"CompletedChallenges"> | number
    createdAt?: DateTimeFilter<"CompletedChallenges"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    Course?: CourseListRelationFilter
  }

  export type CompletedChallengesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
    Course?: CourseOrderByRelationAggregateInput
  }

  export type CompletedChallengesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompletedChallengesWhereInput | CompletedChallengesWhereInput[]
    OR?: CompletedChallengesWhereInput[]
    NOT?: CompletedChallengesWhereInput | CompletedChallengesWhereInput[]
    userId?: IntFilter<"CompletedChallenges"> | number
    challengeId?: IntFilter<"CompletedChallenges"> | number
    createdAt?: DateTimeFilter<"CompletedChallenges"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    Course?: CourseListRelationFilter
  }, "id">

  export type CompletedChallengesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
    _count?: CompletedChallengesCountOrderByAggregateInput
    _avg?: CompletedChallengesAvgOrderByAggregateInput
    _max?: CompletedChallengesMaxOrderByAggregateInput
    _min?: CompletedChallengesMinOrderByAggregateInput
    _sum?: CompletedChallengesSumOrderByAggregateInput
  }

  export type CompletedChallengesScalarWhereWithAggregatesInput = {
    AND?: CompletedChallengesScalarWhereWithAggregatesInput | CompletedChallengesScalarWhereWithAggregatesInput[]
    OR?: CompletedChallengesScalarWhereWithAggregatesInput[]
    NOT?: CompletedChallengesScalarWhereWithAggregatesInput | CompletedChallengesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompletedChallenges"> | number
    userId?: IntWithAggregatesFilter<"CompletedChallenges"> | number
    challengeId?: IntWithAggregatesFilter<"CompletedChallenges"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CompletedChallenges"> | Date | string
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserProfileImageCreateInput = {
    path: string
    user: UserCreateNestedOneWithoutImageInput
  }

  export type UserProfileImageUncheckedCreateInput = {
    id?: number
    path: string
    userId: number
  }

  export type UserProfileImageUpdateInput = {
    path?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutImageNestedInput
  }

  export type UserProfileImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserProfileImageCreateManyInput = {
    id?: number
    path: string
    userId: number
  }

  export type UserProfileImageUpdateManyMutationInput = {
    path?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseCreateInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLikeCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCourseLikesInput
    course: CourseCreateNestedOneWithoutLikedByInput
  }

  export type CourseLikeUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    createdAt?: Date | string
  }

  export type CourseLikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseLikesNestedInput
    course?: CourseUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type CourseLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLikeCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    createdAt?: Date | string
  }

  export type CourseLikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseProgressCreateInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
    user: UserCreateNestedOneWithoutProgressInput
    course: CourseCreateNestedOneWithoutProgressInput
  }

  export type UserCourseProgressUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
  }

  export type UserCourseProgressUpdateInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
    course?: CourseUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserCourseProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCourseProgressCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
  }

  export type UserCourseProgressUpdateManyMutationInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCourseProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseModuleCreateInput = {
    title: string
    number: number
    course: CourseCreateNestedOneWithoutModulesInput
    miniModules?: MiniModuleCreateNestedManyWithoutCourseModuleInput
    progress?: userModuleProgressCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    number: number
    miniModules?: MiniModuleUncheckedCreateNestedManyWithoutCourseModuleInput
    progress?: userModuleProgressUncheckedCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    miniModules?: MiniModuleUpdateManyWithoutCourseModuleNestedInput
    progress?: userModuleProgressUpdateManyWithoutCourseModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModules?: MiniModuleUncheckedUpdateManyWithoutCourseModuleNestedInput
    progress?: userModuleProgressUncheckedUpdateManyWithoutCourseModuleNestedInput
  }

  export type CourseModuleCreateManyInput = {
    id?: number
    courseId: number
    title: string
    number: number
  }

  export type CourseModuleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type CourseModuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type userModuleProgressCreateInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    user: UserCreateNestedOneWithoutUserModuleProgressInput
    courseModule: CourseModuleCreateNestedOneWithoutProgressInput
  }

  export type userModuleProgressUncheckedCreateInput = {
    id?: number
    userId: number
    courseModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
  }

  export type userModuleProgressUpdateInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutUserModuleProgressNestedInput
    courseModule?: CourseModuleUpdateOneRequiredWithoutProgressNestedInput
  }

  export type userModuleProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userModuleProgressCreateManyInput = {
    id?: number
    userId: number
    courseModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
  }

  export type userModuleProgressUpdateManyMutationInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userModuleProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VideoCreateInput = {
    title: string
    number: number
    url: string
    course: CourseCreateNestedOneWithoutVideosInput
  }

  export type VideoUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    number: number
    url: string
  }

  export type VideoUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type VideoCreateManyInput = {
    id?: number
    courseId: number
    title: string
    number: number
    url: string
  }

  export type VideoUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MiniModuleCreateInput = {
    title: string
    number: number
    courseModule: CourseModuleCreateNestedOneWithoutMiniModulesInput
    lessons?: LessonCreateNestedManyWithoutMiniModuleInput
    lessonVideos?: LessonVideoCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleUncheckedCreateInput = {
    id?: number
    courseModuleId: number
    title: string
    number: number
    lessons?: LessonUncheckedCreateNestedManyWithoutMiniModuleInput
    lessonVideos?: LessonVideoUncheckedCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressUncheckedCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    courseModule?: CourseModuleUpdateOneRequiredWithoutMiniModulesNestedInput
    lessons?: LessonUpdateManyWithoutMiniModuleNestedInput
    lessonVideos?: LessonVideoUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUncheckedUpdateManyWithoutMiniModuleNestedInput
    lessonVideos?: LessonVideoUncheckedUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUncheckedUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleCreateManyInput = {
    id?: number
    courseModuleId: number
    title: string
    number: number
  }

  export type MiniModuleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type MiniModuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type MiniModuleProgressCreateInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMiniModuleProgressInput
    miniModule: MiniModuleCreateNestedOneWithoutProgressInput
  }

  export type MiniModuleProgressUncheckedCreateInput = {
    id?: number
    userId: number
    miniModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type MiniModuleProgressUpdateInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMiniModuleProgressNestedInput
    miniModule?: MiniModuleUpdateOneRequiredWithoutProgressNestedInput
  }

  export type MiniModuleProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MiniModuleProgressCreateManyInput = {
    id?: number
    userId: number
    miniModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type MiniModuleProgressUpdateManyMutationInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MiniModuleProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateInput = {
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    miniModule: MiniModuleCreateNestedOneWithoutLessonsInput
    solutions?: LessonSolutionCreateNestedManyWithoutLessonInput
    progress?: UserLessonProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: number
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    miniModuleId: number
    solutions?: LessonSolutionUncheckedCreateNestedManyWithoutLessonInput
    progress?: UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModule?: MiniModuleUpdateOneRequiredWithoutLessonsNestedInput
    solutions?: LessonSolutionUpdateManyWithoutLessonNestedInput
    progress?: UserLessonProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
    solutions?: LessonSolutionUncheckedUpdateManyWithoutLessonNestedInput
    progress?: UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: number
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    miniModuleId: number
  }

  export type LessonUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
  }

  export type LessonVideoCreateInput = {
    title: string
    number: number
    url: string
    miniModule: MiniModuleCreateNestedOneWithoutLessonVideosInput
  }

  export type LessonVideoUncheckedCreateInput = {
    id?: number
    title: string
    number: number
    url: string
    miniModuleId: number
  }

  export type LessonVideoUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    miniModule?: MiniModuleUpdateOneRequiredWithoutLessonVideosNestedInput
  }

  export type LessonVideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    miniModuleId?: IntFieldUpdateOperationsInput | number
  }

  export type LessonVideoCreateManyInput = {
    id?: number
    title: string
    number: number
    url: string
    miniModuleId: number
  }

  export type LessonVideoUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type LessonVideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    miniModuleId?: IntFieldUpdateOperationsInput | number
  }

  export type LessonSolutionCreateInput = {
    solution: string
    lesson: LessonCreateNestedOneWithoutSolutionsInput
  }

  export type LessonSolutionUncheckedCreateInput = {
    id?: number
    solution: string
    lessonId: number
  }

  export type LessonSolutionUpdateInput = {
    solution?: StringFieldUpdateOperationsInput | string
    lesson?: LessonUpdateOneRequiredWithoutSolutionsNestedInput
  }

  export type LessonSolutionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
    lessonId?: IntFieldUpdateOperationsInput | number
  }

  export type LessonSolutionCreateManyInput = {
    id?: number
    solution: string
    lessonId: number
  }

  export type LessonSolutionUpdateManyMutationInput = {
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type LessonSolutionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
    lessonId?: IntFieldUpdateOperationsInput | number
  }

  export type UserLessonProgressCreateInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserLessonProgressInput
    lesson: LessonCreateNestedOneWithoutProgressInput
  }

  export type UserLessonProgressUncheckedCreateInput = {
    id?: number
    userId: number
    lessonId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonProgressUpdateInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserLessonProgressNestedInput
    lesson?: LessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserLessonProgressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonProgressCreateManyInput = {
    id?: number
    userId: number
    lessonId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonProgressUpdateManyMutationInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonProgressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseRatingCreateInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
    course: CourseCreateNestedOneWithoutRatingsInput
  }

  export type CourseRatingUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseRatingUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
    course?: CourseUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type CourseRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseRatingCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseRatingUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateInput = {
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsCreateNestedManyWithoutChallengeInput
    likesList?: ChallengeLikeCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: number
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsUncheckedCreateNestedManyWithoutChallengeInput
    likesList?: ChallengeLikeUncheckedCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsUncheckedCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUpdateManyWithoutChallengeNestedInput
    likesList?: ChallengeLikeUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUncheckedUpdateManyWithoutChallengeNestedInput
    likesList?: ChallengeLikeUncheckedUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUncheckedUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: number
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
  }

  export type ChallengeUpdateManyMutationInput = {
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type MessageCreateInput = {
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
    sender: UserCreateNestedOneWithoutSentMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
  }

  export type MessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageCreateManyInput = {
    id?: number
    senderId: number
    receiverId: number
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
  }

  export type MessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeLikeCreateInput = {
    user: UserCreateNestedOneWithoutChallengeLikeInput
    challenge: ChallengeCreateNestedOneWithoutLikesListInput
  }

  export type ChallengeLikeUncheckedCreateInput = {
    id?: number
    userId: number
    challengeId: number
  }

  export type ChallengeLikeUpdateInput = {
    user?: UserUpdateOneRequiredWithoutChallengeLikeNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutLikesListNestedInput
  }

  export type ChallengeLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeLikeCreateManyInput = {
    id?: number
    userId: number
    challengeId: number
  }

  export type ChallengeLikeUpdateManyMutationInput = {

  }

  export type ChallengeLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeInstructionsCreateInput = {
    number: number
    instruction: string
    completed?: boolean
    challenge: ChallengeCreateNestedOneWithoutInstructionsInput
  }

  export type ChallengeInstructionsUncheckedCreateInput = {
    id?: number
    number: number
    instruction: string
    completed?: boolean
    challengeId: number
  }

  export type ChallengeInstructionsUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    challenge?: ChallengeUpdateOneRequiredWithoutInstructionsNestedInput
  }

  export type ChallengeInstructionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeInstructionsCreateManyInput = {
    id?: number
    number: number
    instruction: string
    completed?: boolean
    challengeId: number
  }

  export type ChallengeInstructionsUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeInstructionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeSolutionsCreateInput = {
    number: number
    solution: string
    challenge: ChallengeCreateNestedOneWithoutSolutionsInput
  }

  export type ChallengeSolutionsUncheckedCreateInput = {
    id?: number
    number: number
    solution: string
    challengeId: number
  }

  export type ChallengeSolutionsUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
    challenge?: ChallengeUpdateOneRequiredWithoutSolutionsNestedInput
  }

  export type ChallengeSolutionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeSolutionsCreateManyInput = {
    id?: number
    number: number
    solution: string
    challengeId: number
  }

  export type ChallengeSolutionsUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSolutionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type CompletedChallengesCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompletedChallengesInput
    challenge: ChallengeCreateNestedOneWithoutCompletionsInput
    Course?: CourseCreateNestedManyWithoutCompletedChallengesInput
  }

  export type CompletedChallengesUncheckedCreateInput = {
    id?: number
    userId: number
    challengeId: number
    createdAt?: Date | string
    Course?: CourseUncheckedCreateNestedManyWithoutCompletedChallengesInput
  }

  export type CompletedChallengesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompletedChallengesNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutCompletionsNestedInput
    Course?: CourseUpdateManyWithoutCompletedChallengesNestedInput
  }

  export type CompletedChallengesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUncheckedUpdateManyWithoutCompletedChallengesNestedInput
  }

  export type CompletedChallengesCreateManyInput = {
    id?: number
    userId: number
    challengeId: number
    createdAt?: Date | string
  }

  export type CompletedChallengesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedChallengesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type CourseRatingListRelationFilter = {
    every?: CourseRatingWhereInput
    some?: CourseRatingWhereInput
    none?: CourseRatingWhereInput
  }

  export type ChallengeLikeListRelationFilter = {
    every?: ChallengeLikeWhereInput
    some?: ChallengeLikeWhereInput
    none?: ChallengeLikeWhereInput
  }

  export type UserProfileImageListRelationFilter = {
    every?: UserProfileImageWhereInput
    some?: UserProfileImageWhereInput
    none?: UserProfileImageWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type UserCourseProgressListRelationFilter = {
    every?: UserCourseProgressWhereInput
    some?: UserCourseProgressWhereInput
    none?: UserCourseProgressWhereInput
  }

  export type UserModuleProgressListRelationFilter = {
    every?: userModuleProgressWhereInput
    some?: userModuleProgressWhereInput
    none?: userModuleProgressWhereInput
  }

  export type MiniModuleProgressListRelationFilter = {
    every?: MiniModuleProgressWhereInput
    some?: MiniModuleProgressWhereInput
    none?: MiniModuleProgressWhereInput
  }

  export type UserLessonProgressListRelationFilter = {
    every?: UserLessonProgressWhereInput
    some?: UserLessonProgressWhereInput
    none?: UserLessonProgressWhereInput
  }

  export type CourseLikeListRelationFilter = {
    every?: CourseLikeWhereInput
    some?: CourseLikeWhereInput
    none?: CourseLikeWhereInput
  }

  export type CompletedChallengesListRelationFilter = {
    every?: CompletedChallengesWhereInput
    some?: CompletedChallengesWhereInput
    none?: CompletedChallengesWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CourseRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCourseProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userModuleProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MiniModuleProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLessonProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompletedChallengesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    hash?: SortOrder
    username?: SortOrder
    role?: SortOrder
    isPremium?: SortOrder
    provider?: SortOrder
    photo?: SortOrder
    courseId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    hash?: SortOrder
    username?: SortOrder
    role?: SortOrder
    isPremium?: SortOrder
    provider?: SortOrder
    photo?: SortOrder
    courseId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    hash?: SortOrder
    username?: SortOrder
    role?: SortOrder
    isPremium?: SortOrder
    provider?: SortOrder
    photo?: SortOrder
    courseId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserProfileImageCountOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileImageAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileImageMaxOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileImageMinOrderByAggregateInput = {
    id?: SortOrder
    path?: SortOrder
    userId?: SortOrder
  }

  export type UserProfileImageSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelFilter<$PrismaModel> | $Enums.Level
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CourseModuleListRelationFilter = {
    every?: CourseModuleWhereInput
    some?: CourseModuleWhereInput
    none?: CourseModuleWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CourseModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    studentsCount?: SortOrder
    rating?: SortOrder
    likes?: SortOrder
    completions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    studentsCount?: SortOrder
    rating?: SortOrder
    likes?: SortOrder
    completions?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    studentsCount?: SortOrder
    rating?: SortOrder
    likes?: SortOrder
    completions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    category?: SortOrder
    level?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    studentsCount?: SortOrder
    rating?: SortOrder
    likes?: SortOrder
    completions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    studentsCount?: SortOrder
    rating?: SortOrder
    likes?: SortOrder
    completions?: SortOrder
  }

  export type EnumLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelWithAggregatesFilter<$PrismaModel> | $Enums.Level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelFilter<$PrismaModel>
    _max?: NestedEnumLevelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseLikeUserIdCourseIdCompoundUniqueInput = {
    userId: number
    courseId: number
  }

  export type CourseLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type CourseLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type UserCourseProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
  }

  export type UserCourseProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    currentStep?: SortOrder
    rating?: SortOrder
  }

  export type UserCourseProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
  }

  export type UserCourseProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    rating?: SortOrder
  }

  export type UserCourseProgressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    currentStep?: SortOrder
    rating?: SortOrder
  }

  export type MiniModuleListRelationFilter = {
    every?: MiniModuleWhereInput
    some?: MiniModuleWhereInput
    none?: MiniModuleWhereInput
  }

  export type MiniModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseModuleCourseIdNumberCompoundUniqueInput = {
    courseId: number
    number: number
  }

  export type CourseModuleCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
  }

  export type CourseModuleAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    number?: SortOrder
  }

  export type CourseModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
  }

  export type CourseModuleMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
  }

  export type CourseModuleSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    number?: SortOrder
  }

  export type CourseModuleScalarRelationFilter = {
    is?: CourseModuleWhereInput
    isNot?: CourseModuleWhereInput
  }

  export type userModuleProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
  }

  export type userModuleProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseModuleId?: SortOrder
    currentStep?: SortOrder
    courseId?: SortOrder
  }

  export type userModuleProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
  }

  export type userModuleProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
  }

  export type userModuleProgressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseModuleId?: SortOrder
    currentStep?: SortOrder
    courseId?: SortOrder
  }

  export type VideoCourseIdNumberCompoundUniqueInput = {
    courseId: number
    number: number
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    number?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    number?: SortOrder
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type LessonVideoListRelationFilter = {
    every?: LessonVideoWhereInput
    some?: LessonVideoWhereInput
    none?: LessonVideoWhereInput
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MiniModuleCourseModuleIdNumberCompoundUniqueInput = {
    courseModuleId: number
    number: number
  }

  export type MiniModuleCountOrderByAggregateInput = {
    id?: SortOrder
    courseModuleId?: SortOrder
    title?: SortOrder
    number?: SortOrder
  }

  export type MiniModuleAvgOrderByAggregateInput = {
    id?: SortOrder
    courseModuleId?: SortOrder
    number?: SortOrder
  }

  export type MiniModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseModuleId?: SortOrder
    title?: SortOrder
    number?: SortOrder
  }

  export type MiniModuleMinOrderByAggregateInput = {
    id?: SortOrder
    courseModuleId?: SortOrder
    title?: SortOrder
    number?: SortOrder
  }

  export type MiniModuleSumOrderByAggregateInput = {
    id?: SortOrder
    courseModuleId?: SortOrder
    number?: SortOrder
  }

  export type MiniModuleScalarRelationFilter = {
    is?: MiniModuleWhereInput
    isNot?: MiniModuleWhereInput
  }

  export type MiniModuleProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    miniModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MiniModuleProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    miniModuleId?: SortOrder
    currentStep?: SortOrder
  }

  export type MiniModuleProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    miniModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MiniModuleProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    miniModuleId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MiniModuleProgressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    miniModuleId?: SortOrder
    currentStep?: SortOrder
  }

  export type LessonSolutionListRelationFilter = {
    every?: LessonSolutionWhereInput
    some?: LessonSolutionWhereInput
    none?: LessonSolutionWhereInput
  }

  export type LessonSolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    explanation?: SortOrder
    more?: SortOrder
    example?: SortOrder
    note?: SortOrder
    assignment?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    explanation?: SortOrder
    more?: SortOrder
    example?: SortOrder
    note?: SortOrder
    assignment?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    explanation?: SortOrder
    more?: SortOrder
    example?: SortOrder
    note?: SortOrder
    assignment?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonVideoMiniModuleIdNumberCompoundUniqueInput = {
    miniModuleId: number
    number: number
  }

  export type LessonVideoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonVideoAvgOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonVideoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    number?: SortOrder
    url?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonVideoSumOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    miniModuleId?: SortOrder
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type LessonSolutionCountOrderByAggregateInput = {
    id?: SortOrder
    solution?: SortOrder
    lessonId?: SortOrder
  }

  export type LessonSolutionAvgOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
  }

  export type LessonSolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    solution?: SortOrder
    lessonId?: SortOrder
  }

  export type LessonSolutionMinOrderByAggregateInput = {
    id?: SortOrder
    solution?: SortOrder
    lessonId?: SortOrder
  }

  export type LessonSolutionSumOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
  }

  export type UserLessonProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLessonProgressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    currentStep?: SortOrder
  }

  export type UserLessonProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLessonProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    currentStep?: SortOrder
    completed?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserLessonProgressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    currentStep?: SortOrder
  }

  export type CourseRatingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseRatingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
  }

  export type CourseRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseRatingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseRatingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
  }

  export type ChallengeInstructionsListRelationFilter = {
    every?: ChallengeInstructionsWhereInput
    some?: ChallengeInstructionsWhereInput
    none?: ChallengeInstructionsWhereInput
  }

  export type ChallengeSolutionsListRelationFilter = {
    every?: ChallengeSolutionsWhereInput
    some?: ChallengeSolutionsWhereInput
    none?: ChallengeSolutionsWhereInput
  }

  export type ChallengeInstructionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeSolutionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    difficulty?: SortOrder
    title?: SortOrder
    description?: SortOrder
    relation?: SortOrder
    duration?: SortOrder
    useEditor?: SortOrder
    likes?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    id?: SortOrder
    likes?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    difficulty?: SortOrder
    title?: SortOrder
    description?: SortOrder
    relation?: SortOrder
    duration?: SortOrder
    useEditor?: SortOrder
    likes?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    difficulty?: SortOrder
    title?: SortOrder
    description?: SortOrder
    relation?: SortOrder
    duration?: SortOrder
    useEditor?: SortOrder
    likes?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    id?: SortOrder
    likes?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    read?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    read?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    read?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type ChallengeScalarRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type ChallengeLikeUserIdChallengeIdCompoundUniqueInput = {
    userId: number
    challengeId: number
  }

  export type ChallengeLikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeLikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeInstructionsCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    instruction?: SortOrder
    completed?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeInstructionsAvgOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeInstructionsMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    instruction?: SortOrder
    completed?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeInstructionsMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    instruction?: SortOrder
    completed?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeInstructionsSumOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeSolutionsCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    solution?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeSolutionsAvgOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeSolutionsMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    solution?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeSolutionsMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    solution?: SortOrder
    challengeId?: SortOrder
  }

  export type ChallengeSolutionsSumOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    challengeId?: SortOrder
  }

  export type CompletedChallengesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompletedChallengesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
  }

  export type CompletedChallengesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompletedChallengesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    createdAt?: SortOrder
  }

  export type CompletedChallengesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
  }

  export type CourseCreateNestedOneWithoutUsersInput = {
    create?: XOR<CourseCreateWithoutUsersInput, CourseUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUsersInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseRatingCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseRatingCreateWithoutUserInput, CourseRatingUncheckedCreateWithoutUserInput> | CourseRatingCreateWithoutUserInput[] | CourseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutUserInput | CourseRatingCreateOrConnectWithoutUserInput[]
    createMany?: CourseRatingCreateManyUserInputEnvelope
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
  }

  export type ChallengeLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeLikeCreateWithoutUserInput, ChallengeLikeUncheckedCreateWithoutUserInput> | ChallengeLikeCreateWithoutUserInput[] | ChallengeLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutUserInput | ChallengeLikeCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeLikeCreateManyUserInputEnvelope
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
  }

  export type UserProfileImageCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProfileImageCreateWithoutUserInput, UserProfileImageUncheckedCreateWithoutUserInput> | UserProfileImageCreateWithoutUserInput[] | UserProfileImageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProfileImageCreateOrConnectWithoutUserInput | UserProfileImageCreateOrConnectWithoutUserInput[]
    createMany?: UserProfileImageCreateManyUserInputEnvelope
    connect?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserCourseProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type userModuleProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<userModuleProgressCreateWithoutUserInput, userModuleProgressUncheckedCreateWithoutUserInput> | userModuleProgressCreateWithoutUserInput[] | userModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutUserInput | userModuleProgressCreateOrConnectWithoutUserInput[]
    createMany?: userModuleProgressCreateManyUserInputEnvelope
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
  }

  export type MiniModuleProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<MiniModuleProgressCreateWithoutUserInput, MiniModuleProgressUncheckedCreateWithoutUserInput> | MiniModuleProgressCreateWithoutUserInput[] | MiniModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutUserInput | MiniModuleProgressCreateOrConnectWithoutUserInput[]
    createMany?: MiniModuleProgressCreateManyUserInputEnvelope
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
  }

  export type UserLessonProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type CourseLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseLikeCreateWithoutUserInput, CourseLikeUncheckedCreateWithoutUserInput> | CourseLikeCreateWithoutUserInput[] | CourseLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutUserInput | CourseLikeCreateOrConnectWithoutUserInput[]
    createMany?: CourseLikeCreateManyUserInputEnvelope
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
  }

  export type CompletedChallengesCreateNestedManyWithoutUserInput = {
    create?: XOR<CompletedChallengesCreateWithoutUserInput, CompletedChallengesUncheckedCreateWithoutUserInput> | CompletedChallengesCreateWithoutUserInput[] | CompletedChallengesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutUserInput | CompletedChallengesCreateOrConnectWithoutUserInput[]
    createMany?: CompletedChallengesCreateManyUserInputEnvelope
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type CourseRatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseRatingCreateWithoutUserInput, CourseRatingUncheckedCreateWithoutUserInput> | CourseRatingCreateWithoutUserInput[] | CourseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutUserInput | CourseRatingCreateOrConnectWithoutUserInput[]
    createMany?: CourseRatingCreateManyUserInputEnvelope
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
  }

  export type ChallengeLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeLikeCreateWithoutUserInput, ChallengeLikeUncheckedCreateWithoutUserInput> | ChallengeLikeCreateWithoutUserInput[] | ChallengeLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutUserInput | ChallengeLikeCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeLikeCreateManyUserInputEnvelope
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
  }

  export type UserProfileImageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProfileImageCreateWithoutUserInput, UserProfileImageUncheckedCreateWithoutUserInput> | UserProfileImageCreateWithoutUserInput[] | UserProfileImageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProfileImageCreateOrConnectWithoutUserInput | UserProfileImageCreateOrConnectWithoutUserInput[]
    createMany?: UserProfileImageCreateManyUserInputEnvelope
    connect?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserCourseProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type userModuleProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userModuleProgressCreateWithoutUserInput, userModuleProgressUncheckedCreateWithoutUserInput> | userModuleProgressCreateWithoutUserInput[] | userModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutUserInput | userModuleProgressCreateOrConnectWithoutUserInput[]
    createMany?: userModuleProgressCreateManyUserInputEnvelope
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
  }

  export type MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MiniModuleProgressCreateWithoutUserInput, MiniModuleProgressUncheckedCreateWithoutUserInput> | MiniModuleProgressCreateWithoutUserInput[] | MiniModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutUserInput | MiniModuleProgressCreateOrConnectWithoutUserInput[]
    createMany?: MiniModuleProgressCreateManyUserInputEnvelope
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
  }

  export type UserLessonProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type CourseLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseLikeCreateWithoutUserInput, CourseLikeUncheckedCreateWithoutUserInput> | CourseLikeCreateWithoutUserInput[] | CourseLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutUserInput | CourseLikeCreateOrConnectWithoutUserInput[]
    createMany?: CourseLikeCreateManyUserInputEnvelope
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
  }

  export type CompletedChallengesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompletedChallengesCreateWithoutUserInput, CompletedChallengesUncheckedCreateWithoutUserInput> | CompletedChallengesCreateWithoutUserInput[] | CompletedChallengesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutUserInput | CompletedChallengesCreateOrConnectWithoutUserInput[]
    createMany?: CompletedChallengesCreateManyUserInputEnvelope
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CourseUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CourseCreateWithoutUsersInput, CourseUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUsersInput
    upsert?: CourseUpsertWithoutUsersInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutUsersInput, CourseUpdateWithoutUsersInput>, CourseUncheckedUpdateWithoutUsersInput>
  }

  export type CourseRatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseRatingCreateWithoutUserInput, CourseRatingUncheckedCreateWithoutUserInput> | CourseRatingCreateWithoutUserInput[] | CourseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutUserInput | CourseRatingCreateOrConnectWithoutUserInput[]
    upsert?: CourseRatingUpsertWithWhereUniqueWithoutUserInput | CourseRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseRatingCreateManyUserInputEnvelope
    set?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    disconnect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    delete?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    update?: CourseRatingUpdateWithWhereUniqueWithoutUserInput | CourseRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseRatingUpdateManyWithWhereWithoutUserInput | CourseRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseRatingScalarWhereInput | CourseRatingScalarWhereInput[]
  }

  export type ChallengeLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeLikeCreateWithoutUserInput, ChallengeLikeUncheckedCreateWithoutUserInput> | ChallengeLikeCreateWithoutUserInput[] | ChallengeLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutUserInput | ChallengeLikeCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeLikeUpsertWithWhereUniqueWithoutUserInput | ChallengeLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeLikeCreateManyUserInputEnvelope
    set?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    disconnect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    delete?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    update?: ChallengeLikeUpdateWithWhereUniqueWithoutUserInput | ChallengeLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeLikeUpdateManyWithWhereWithoutUserInput | ChallengeLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeLikeScalarWhereInput | ChallengeLikeScalarWhereInput[]
  }

  export type UserProfileImageUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProfileImageCreateWithoutUserInput, UserProfileImageUncheckedCreateWithoutUserInput> | UserProfileImageCreateWithoutUserInput[] | UserProfileImageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProfileImageCreateOrConnectWithoutUserInput | UserProfileImageCreateOrConnectWithoutUserInput[]
    upsert?: UserProfileImageUpsertWithWhereUniqueWithoutUserInput | UserProfileImageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProfileImageCreateManyUserInputEnvelope
    set?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    disconnect?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    delete?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    connect?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    update?: UserProfileImageUpdateWithWhereUniqueWithoutUserInput | UserProfileImageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProfileImageUpdateManyWithWhereWithoutUserInput | UserProfileImageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProfileImageScalarWhereInput | UserProfileImageScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserCourseProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutUserInput | UserCourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutUserInput | UserCourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutUserInput | UserCourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type userModuleProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<userModuleProgressCreateWithoutUserInput, userModuleProgressUncheckedCreateWithoutUserInput> | userModuleProgressCreateWithoutUserInput[] | userModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutUserInput | userModuleProgressCreateOrConnectWithoutUserInput[]
    upsert?: userModuleProgressUpsertWithWhereUniqueWithoutUserInput | userModuleProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userModuleProgressCreateManyUserInputEnvelope
    set?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    disconnect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    delete?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    update?: userModuleProgressUpdateWithWhereUniqueWithoutUserInput | userModuleProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userModuleProgressUpdateManyWithWhereWithoutUserInput | userModuleProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userModuleProgressScalarWhereInput | userModuleProgressScalarWhereInput[]
  }

  export type MiniModuleProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<MiniModuleProgressCreateWithoutUserInput, MiniModuleProgressUncheckedCreateWithoutUserInput> | MiniModuleProgressCreateWithoutUserInput[] | MiniModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutUserInput | MiniModuleProgressCreateOrConnectWithoutUserInput[]
    upsert?: MiniModuleProgressUpsertWithWhereUniqueWithoutUserInput | MiniModuleProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MiniModuleProgressCreateManyUserInputEnvelope
    set?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    disconnect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    delete?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    update?: MiniModuleProgressUpdateWithWhereUniqueWithoutUserInput | MiniModuleProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MiniModuleProgressUpdateManyWithWhereWithoutUserInput | MiniModuleProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MiniModuleProgressScalarWhereInput | MiniModuleProgressScalarWhereInput[]
  }

  export type UserLessonProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutUserInput | UserLessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutUserInput | UserLessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutUserInput | UserLessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type CourseLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseLikeCreateWithoutUserInput, CourseLikeUncheckedCreateWithoutUserInput> | CourseLikeCreateWithoutUserInput[] | CourseLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutUserInput | CourseLikeCreateOrConnectWithoutUserInput[]
    upsert?: CourseLikeUpsertWithWhereUniqueWithoutUserInput | CourseLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseLikeCreateManyUserInputEnvelope
    set?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    disconnect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    delete?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    update?: CourseLikeUpdateWithWhereUniqueWithoutUserInput | CourseLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseLikeUpdateManyWithWhereWithoutUserInput | CourseLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseLikeScalarWhereInput | CourseLikeScalarWhereInput[]
  }

  export type CompletedChallengesUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompletedChallengesCreateWithoutUserInput, CompletedChallengesUncheckedCreateWithoutUserInput> | CompletedChallengesCreateWithoutUserInput[] | CompletedChallengesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutUserInput | CompletedChallengesCreateOrConnectWithoutUserInput[]
    upsert?: CompletedChallengesUpsertWithWhereUniqueWithoutUserInput | CompletedChallengesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompletedChallengesCreateManyUserInputEnvelope
    set?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    disconnect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    delete?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    update?: CompletedChallengesUpdateWithWhereUniqueWithoutUserInput | CompletedChallengesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompletedChallengesUpdateManyWithWhereWithoutUserInput | CompletedChallengesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseRatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseRatingCreateWithoutUserInput, CourseRatingUncheckedCreateWithoutUserInput> | CourseRatingCreateWithoutUserInput[] | CourseRatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutUserInput | CourseRatingCreateOrConnectWithoutUserInput[]
    upsert?: CourseRatingUpsertWithWhereUniqueWithoutUserInput | CourseRatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseRatingCreateManyUserInputEnvelope
    set?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    disconnect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    delete?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    update?: CourseRatingUpdateWithWhereUniqueWithoutUserInput | CourseRatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseRatingUpdateManyWithWhereWithoutUserInput | CourseRatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseRatingScalarWhereInput | CourseRatingScalarWhereInput[]
  }

  export type ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeLikeCreateWithoutUserInput, ChallengeLikeUncheckedCreateWithoutUserInput> | ChallengeLikeCreateWithoutUserInput[] | ChallengeLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutUserInput | ChallengeLikeCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeLikeUpsertWithWhereUniqueWithoutUserInput | ChallengeLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeLikeCreateManyUserInputEnvelope
    set?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    disconnect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    delete?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    update?: ChallengeLikeUpdateWithWhereUniqueWithoutUserInput | ChallengeLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeLikeUpdateManyWithWhereWithoutUserInput | ChallengeLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeLikeScalarWhereInput | ChallengeLikeScalarWhereInput[]
  }

  export type UserProfileImageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProfileImageCreateWithoutUserInput, UserProfileImageUncheckedCreateWithoutUserInput> | UserProfileImageCreateWithoutUserInput[] | UserProfileImageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProfileImageCreateOrConnectWithoutUserInput | UserProfileImageCreateOrConnectWithoutUserInput[]
    upsert?: UserProfileImageUpsertWithWhereUniqueWithoutUserInput | UserProfileImageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProfileImageCreateManyUserInputEnvelope
    set?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    disconnect?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    delete?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    connect?: UserProfileImageWhereUniqueInput | UserProfileImageWhereUniqueInput[]
    update?: UserProfileImageUpdateWithWhereUniqueWithoutUserInput | UserProfileImageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProfileImageUpdateManyWithWhereWithoutUserInput | UserProfileImageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProfileImageScalarWhereInput | UserProfileImageScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput> | CourseCreateWithoutCreatorInput[] | CourseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCreatorInput | CourseCreateOrConnectWithoutCreatorInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCreatorInput | CourseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCreatorInput | CourseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCreatorInput | CourseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput> | UserCourseProgressCreateWithoutUserInput[] | UserCourseProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutUserInput | UserCourseProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutUserInput | UserCourseProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseProgressCreateManyUserInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutUserInput | UserCourseProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutUserInput | UserCourseProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type userModuleProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userModuleProgressCreateWithoutUserInput, userModuleProgressUncheckedCreateWithoutUserInput> | userModuleProgressCreateWithoutUserInput[] | userModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutUserInput | userModuleProgressCreateOrConnectWithoutUserInput[]
    upsert?: userModuleProgressUpsertWithWhereUniqueWithoutUserInput | userModuleProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userModuleProgressCreateManyUserInputEnvelope
    set?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    disconnect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    delete?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    update?: userModuleProgressUpdateWithWhereUniqueWithoutUserInput | userModuleProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userModuleProgressUpdateManyWithWhereWithoutUserInput | userModuleProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userModuleProgressScalarWhereInput | userModuleProgressScalarWhereInput[]
  }

  export type MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MiniModuleProgressCreateWithoutUserInput, MiniModuleProgressUncheckedCreateWithoutUserInput> | MiniModuleProgressCreateWithoutUserInput[] | MiniModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutUserInput | MiniModuleProgressCreateOrConnectWithoutUserInput[]
    upsert?: MiniModuleProgressUpsertWithWhereUniqueWithoutUserInput | MiniModuleProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MiniModuleProgressCreateManyUserInputEnvelope
    set?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    disconnect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    delete?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    update?: MiniModuleProgressUpdateWithWhereUniqueWithoutUserInput | MiniModuleProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MiniModuleProgressUpdateManyWithWhereWithoutUserInput | MiniModuleProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MiniModuleProgressScalarWhereInput | MiniModuleProgressScalarWhereInput[]
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput> | UserLessonProgressCreateWithoutUserInput[] | UserLessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutUserInput | UserLessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutUserInput | UserLessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLessonProgressCreateManyUserInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutUserInput | UserLessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutUserInput | UserLessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type CourseLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseLikeCreateWithoutUserInput, CourseLikeUncheckedCreateWithoutUserInput> | CourseLikeCreateWithoutUserInput[] | CourseLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutUserInput | CourseLikeCreateOrConnectWithoutUserInput[]
    upsert?: CourseLikeUpsertWithWhereUniqueWithoutUserInput | CourseLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseLikeCreateManyUserInputEnvelope
    set?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    disconnect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    delete?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    update?: CourseLikeUpdateWithWhereUniqueWithoutUserInput | CourseLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseLikeUpdateManyWithWhereWithoutUserInput | CourseLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseLikeScalarWhereInput | CourseLikeScalarWhereInput[]
  }

  export type CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompletedChallengesCreateWithoutUserInput, CompletedChallengesUncheckedCreateWithoutUserInput> | CompletedChallengesCreateWithoutUserInput[] | CompletedChallengesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutUserInput | CompletedChallengesCreateOrConnectWithoutUserInput[]
    upsert?: CompletedChallengesUpsertWithWhereUniqueWithoutUserInput | CompletedChallengesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompletedChallengesCreateManyUserInputEnvelope
    set?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    disconnect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    delete?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    update?: CompletedChallengesUpdateWithWhereUniqueWithoutUserInput | CompletedChallengesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompletedChallengesUpdateManyWithWhereWithoutUserInput | CompletedChallengesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutImageInput = {
    create?: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutImageNestedInput = {
    create?: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageInput
    upsert?: UserUpsertWithoutImageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImageInput, UserUpdateWithoutImageInput>, UserUncheckedUpdateWithoutImageInput>
  }

  export type UserCreateNestedOneWithoutCreatedCoursesInput = {
    create?: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type UserCourseProgressCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type CourseRatingCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseRatingCreateWithoutCourseInput, CourseRatingUncheckedCreateWithoutCourseInput> | CourseRatingCreateWithoutCourseInput[] | CourseRatingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutCourseInput | CourseRatingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseRatingCreateManyCourseInputEnvelope
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutCourseInput = {
    create?: XOR<VideoCreateWithoutCourseInput, VideoUncheckedCreateWithoutCourseInput> | VideoCreateWithoutCourseInput[] | VideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutCourseInput | VideoCreateOrConnectWithoutCourseInput[]
    createMany?: VideoCreateManyCourseInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput> | UserCreateWithoutCourseInput[] | UserUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput | UserCreateOrConnectWithoutCourseInput[]
    createMany?: UserCreateManyCourseInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CourseLikeCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseLikeCreateWithoutCourseInput, CourseLikeUncheckedCreateWithoutCourseInput> | CourseLikeCreateWithoutCourseInput[] | CourseLikeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutCourseInput | CourseLikeCreateOrConnectWithoutCourseInput[]
    createMany?: CourseLikeCreateManyCourseInputEnvelope
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
  }

  export type CompletedChallengesCreateNestedManyWithoutCourseInput = {
    create?: XOR<CompletedChallengesCreateWithoutCourseInput, CompletedChallengesUncheckedCreateWithoutCourseInput> | CompletedChallengesCreateWithoutCourseInput[] | CompletedChallengesUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutCourseInput | CompletedChallengesCreateOrConnectWithoutCourseInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
  }

  export type CourseModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
  }

  export type UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
  }

  export type CourseRatingUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseRatingCreateWithoutCourseInput, CourseRatingUncheckedCreateWithoutCourseInput> | CourseRatingCreateWithoutCourseInput[] | CourseRatingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutCourseInput | CourseRatingCreateOrConnectWithoutCourseInput[]
    createMany?: CourseRatingCreateManyCourseInputEnvelope
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<VideoCreateWithoutCourseInput, VideoUncheckedCreateWithoutCourseInput> | VideoCreateWithoutCourseInput[] | VideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutCourseInput | VideoCreateOrConnectWithoutCourseInput[]
    createMany?: VideoCreateManyCourseInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput> | UserCreateWithoutCourseInput[] | UserUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput | UserCreateOrConnectWithoutCourseInput[]
    createMany?: UserCreateManyCourseInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CourseLikeUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseLikeCreateWithoutCourseInput, CourseLikeUncheckedCreateWithoutCourseInput> | CourseLikeCreateWithoutCourseInput[] | CourseLikeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutCourseInput | CourseLikeCreateOrConnectWithoutCourseInput[]
    createMany?: CourseLikeCreateManyCourseInputEnvelope
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
  }

  export type CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CompletedChallengesCreateWithoutCourseInput, CompletedChallengesUncheckedCreateWithoutCourseInput> | CompletedChallengesCreateWithoutCourseInput[] | CompletedChallengesUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutCourseInput | CompletedChallengesCreateOrConnectWithoutCourseInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
  }

  export type EnumLevelFieldUpdateOperationsInput = {
    set?: $Enums.Level
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreatedCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCoursesInput
    upsert?: UserUpsertWithoutCreatedCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCoursesInput, UserUpdateWithoutCreatedCoursesInput>, UserUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type CourseModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type UserCourseProgressUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput | UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput | UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutCourseInput | UserCourseProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type CourseRatingUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseRatingCreateWithoutCourseInput, CourseRatingUncheckedCreateWithoutCourseInput> | CourseRatingCreateWithoutCourseInput[] | CourseRatingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutCourseInput | CourseRatingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseRatingUpsertWithWhereUniqueWithoutCourseInput | CourseRatingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseRatingCreateManyCourseInputEnvelope
    set?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    disconnect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    delete?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    update?: CourseRatingUpdateWithWhereUniqueWithoutCourseInput | CourseRatingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseRatingUpdateManyWithWhereWithoutCourseInput | CourseRatingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseRatingScalarWhereInput | CourseRatingScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutCourseNestedInput = {
    create?: XOR<VideoCreateWithoutCourseInput, VideoUncheckedCreateWithoutCourseInput> | VideoCreateWithoutCourseInput[] | VideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutCourseInput | VideoCreateOrConnectWithoutCourseInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutCourseInput | VideoUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: VideoCreateManyCourseInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutCourseInput | VideoUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutCourseInput | VideoUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput> | UserCreateWithoutCourseInput[] | UserUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput | UserCreateOrConnectWithoutCourseInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCourseInput | UserUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCreateManyCourseInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCourseInput | UserUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCourseInput | UserUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CourseLikeUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseLikeCreateWithoutCourseInput, CourseLikeUncheckedCreateWithoutCourseInput> | CourseLikeCreateWithoutCourseInput[] | CourseLikeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutCourseInput | CourseLikeCreateOrConnectWithoutCourseInput[]
    upsert?: CourseLikeUpsertWithWhereUniqueWithoutCourseInput | CourseLikeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseLikeCreateManyCourseInputEnvelope
    set?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    disconnect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    delete?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    update?: CourseLikeUpdateWithWhereUniqueWithoutCourseInput | CourseLikeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseLikeUpdateManyWithWhereWithoutCourseInput | CourseLikeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseLikeScalarWhereInput | CourseLikeScalarWhereInput[]
  }

  export type CompletedChallengesUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CompletedChallengesCreateWithoutCourseInput, CompletedChallengesUncheckedCreateWithoutCourseInput> | CompletedChallengesCreateWithoutCourseInput[] | CompletedChallengesUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutCourseInput | CompletedChallengesCreateOrConnectWithoutCourseInput[]
    upsert?: CompletedChallengesUpsertWithWhereUniqueWithoutCourseInput | CompletedChallengesUpsertWithWhereUniqueWithoutCourseInput[]
    set?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    disconnect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    delete?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    update?: CompletedChallengesUpdateWithWhereUniqueWithoutCourseInput | CompletedChallengesUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CompletedChallengesUpdateManyWithWhereWithoutCourseInput | CompletedChallengesUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput> | CourseModuleCreateWithoutCourseInput[] | CourseModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseModuleCreateOrConnectWithoutCourseInput | CourseModuleCreateOrConnectWithoutCourseInput[]
    upsert?: CourseModuleUpsertWithWhereUniqueWithoutCourseInput | CourseModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseModuleCreateManyCourseInputEnvelope
    set?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    disconnect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    delete?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    connect?: CourseModuleWhereUniqueInput | CourseModuleWhereUniqueInput[]
    update?: CourseModuleUpdateWithWhereUniqueWithoutCourseInput | CourseModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseModuleUpdateManyWithWhereWithoutCourseInput | CourseModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput> | UserCourseProgressCreateWithoutCourseInput[] | UserCourseProgressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseProgressCreateOrConnectWithoutCourseInput | UserCourseProgressCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput | UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseProgressCreateManyCourseInputEnvelope
    set?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    disconnect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    delete?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    connect?: UserCourseProgressWhereUniqueInput | UserCourseProgressWhereUniqueInput[]
    update?: UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput | UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseProgressUpdateManyWithWhereWithoutCourseInput | UserCourseProgressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
  }

  export type CourseRatingUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseRatingCreateWithoutCourseInput, CourseRatingUncheckedCreateWithoutCourseInput> | CourseRatingCreateWithoutCourseInput[] | CourseRatingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseRatingCreateOrConnectWithoutCourseInput | CourseRatingCreateOrConnectWithoutCourseInput[]
    upsert?: CourseRatingUpsertWithWhereUniqueWithoutCourseInput | CourseRatingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseRatingCreateManyCourseInputEnvelope
    set?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    disconnect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    delete?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    connect?: CourseRatingWhereUniqueInput | CourseRatingWhereUniqueInput[]
    update?: CourseRatingUpdateWithWhereUniqueWithoutCourseInput | CourseRatingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseRatingUpdateManyWithWhereWithoutCourseInput | CourseRatingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseRatingScalarWhereInput | CourseRatingScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<VideoCreateWithoutCourseInput, VideoUncheckedCreateWithoutCourseInput> | VideoCreateWithoutCourseInput[] | VideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutCourseInput | VideoCreateOrConnectWithoutCourseInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutCourseInput | VideoUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: VideoCreateManyCourseInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutCourseInput | VideoUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutCourseInput | VideoUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput> | UserCreateWithoutCourseInput[] | UserUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput | UserCreateOrConnectWithoutCourseInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCourseInput | UserUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCreateManyCourseInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCourseInput | UserUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCourseInput | UserUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CourseLikeUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseLikeCreateWithoutCourseInput, CourseLikeUncheckedCreateWithoutCourseInput> | CourseLikeCreateWithoutCourseInput[] | CourseLikeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseLikeCreateOrConnectWithoutCourseInput | CourseLikeCreateOrConnectWithoutCourseInput[]
    upsert?: CourseLikeUpsertWithWhereUniqueWithoutCourseInput | CourseLikeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseLikeCreateManyCourseInputEnvelope
    set?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    disconnect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    delete?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    connect?: CourseLikeWhereUniqueInput | CourseLikeWhereUniqueInput[]
    update?: CourseLikeUpdateWithWhereUniqueWithoutCourseInput | CourseLikeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseLikeUpdateManyWithWhereWithoutCourseInput | CourseLikeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseLikeScalarWhereInput | CourseLikeScalarWhereInput[]
  }

  export type CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CompletedChallengesCreateWithoutCourseInput, CompletedChallengesUncheckedCreateWithoutCourseInput> | CompletedChallengesCreateWithoutCourseInput[] | CompletedChallengesUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutCourseInput | CompletedChallengesCreateOrConnectWithoutCourseInput[]
    upsert?: CompletedChallengesUpsertWithWhereUniqueWithoutCourseInput | CompletedChallengesUpsertWithWhereUniqueWithoutCourseInput[]
    set?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    disconnect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    delete?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    update?: CompletedChallengesUpdateWithWhereUniqueWithoutCourseInput | CompletedChallengesUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CompletedChallengesUpdateManyWithWhereWithoutCourseInput | CompletedChallengesUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCourseLikesInput = {
    create?: XOR<UserCreateWithoutCourseLikesInput, UserUncheckedCreateWithoutCourseLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseLikesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutLikedByInput = {
    create?: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLikedByInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCourseLikesNestedInput = {
    create?: XOR<UserCreateWithoutCourseLikesInput, UserUncheckedCreateWithoutCourseLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseLikesInput
    upsert?: UserUpsertWithoutCourseLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseLikesInput, UserUpdateWithoutCourseLikesInput>, UserUncheckedUpdateWithoutCourseLikesInput>
  }

  export type CourseUpdateOneRequiredWithoutLikedByNestedInput = {
    create?: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLikedByInput
    upsert?: CourseUpsertWithoutLikedByInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLikedByInput, CourseUpdateWithoutLikedByInput>, CourseUncheckedUpdateWithoutLikedByInput>
  }

  export type UserCreateNestedOneWithoutProgressInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutProgressInput = {
    create?: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgressInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    upsert?: UserUpsertWithoutProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressInput, UserUpdateWithoutProgressInput>, UserUncheckedUpdateWithoutProgressInput>
  }

  export type CourseUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseCreateOrConnectWithoutProgressInput
    upsert?: CourseUpsertWithoutProgressInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutProgressInput, CourseUpdateWithoutProgressInput>, CourseUncheckedUpdateWithoutProgressInput>
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type MiniModuleCreateNestedManyWithoutCourseModuleInput = {
    create?: XOR<MiniModuleCreateWithoutCourseModuleInput, MiniModuleUncheckedCreateWithoutCourseModuleInput> | MiniModuleCreateWithoutCourseModuleInput[] | MiniModuleUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: MiniModuleCreateOrConnectWithoutCourseModuleInput | MiniModuleCreateOrConnectWithoutCourseModuleInput[]
    createMany?: MiniModuleCreateManyCourseModuleInputEnvelope
    connect?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
  }

  export type userModuleProgressCreateNestedManyWithoutCourseModuleInput = {
    create?: XOR<userModuleProgressCreateWithoutCourseModuleInput, userModuleProgressUncheckedCreateWithoutCourseModuleInput> | userModuleProgressCreateWithoutCourseModuleInput[] | userModuleProgressUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutCourseModuleInput | userModuleProgressCreateOrConnectWithoutCourseModuleInput[]
    createMany?: userModuleProgressCreateManyCourseModuleInputEnvelope
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
  }

  export type MiniModuleUncheckedCreateNestedManyWithoutCourseModuleInput = {
    create?: XOR<MiniModuleCreateWithoutCourseModuleInput, MiniModuleUncheckedCreateWithoutCourseModuleInput> | MiniModuleCreateWithoutCourseModuleInput[] | MiniModuleUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: MiniModuleCreateOrConnectWithoutCourseModuleInput | MiniModuleCreateOrConnectWithoutCourseModuleInput[]
    createMany?: MiniModuleCreateManyCourseModuleInputEnvelope
    connect?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
  }

  export type userModuleProgressUncheckedCreateNestedManyWithoutCourseModuleInput = {
    create?: XOR<userModuleProgressCreateWithoutCourseModuleInput, userModuleProgressUncheckedCreateWithoutCourseModuleInput> | userModuleProgressCreateWithoutCourseModuleInput[] | userModuleProgressUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutCourseModuleInput | userModuleProgressCreateOrConnectWithoutCourseModuleInput[]
    createMany?: userModuleProgressCreateManyCourseModuleInputEnvelope
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type MiniModuleUpdateManyWithoutCourseModuleNestedInput = {
    create?: XOR<MiniModuleCreateWithoutCourseModuleInput, MiniModuleUncheckedCreateWithoutCourseModuleInput> | MiniModuleCreateWithoutCourseModuleInput[] | MiniModuleUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: MiniModuleCreateOrConnectWithoutCourseModuleInput | MiniModuleCreateOrConnectWithoutCourseModuleInput[]
    upsert?: MiniModuleUpsertWithWhereUniqueWithoutCourseModuleInput | MiniModuleUpsertWithWhereUniqueWithoutCourseModuleInput[]
    createMany?: MiniModuleCreateManyCourseModuleInputEnvelope
    set?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    disconnect?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    delete?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    connect?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    update?: MiniModuleUpdateWithWhereUniqueWithoutCourseModuleInput | MiniModuleUpdateWithWhereUniqueWithoutCourseModuleInput[]
    updateMany?: MiniModuleUpdateManyWithWhereWithoutCourseModuleInput | MiniModuleUpdateManyWithWhereWithoutCourseModuleInput[]
    deleteMany?: MiniModuleScalarWhereInput | MiniModuleScalarWhereInput[]
  }

  export type userModuleProgressUpdateManyWithoutCourseModuleNestedInput = {
    create?: XOR<userModuleProgressCreateWithoutCourseModuleInput, userModuleProgressUncheckedCreateWithoutCourseModuleInput> | userModuleProgressCreateWithoutCourseModuleInput[] | userModuleProgressUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutCourseModuleInput | userModuleProgressCreateOrConnectWithoutCourseModuleInput[]
    upsert?: userModuleProgressUpsertWithWhereUniqueWithoutCourseModuleInput | userModuleProgressUpsertWithWhereUniqueWithoutCourseModuleInput[]
    createMany?: userModuleProgressCreateManyCourseModuleInputEnvelope
    set?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    disconnect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    delete?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    update?: userModuleProgressUpdateWithWhereUniqueWithoutCourseModuleInput | userModuleProgressUpdateWithWhereUniqueWithoutCourseModuleInput[]
    updateMany?: userModuleProgressUpdateManyWithWhereWithoutCourseModuleInput | userModuleProgressUpdateManyWithWhereWithoutCourseModuleInput[]
    deleteMany?: userModuleProgressScalarWhereInput | userModuleProgressScalarWhereInput[]
  }

  export type MiniModuleUncheckedUpdateManyWithoutCourseModuleNestedInput = {
    create?: XOR<MiniModuleCreateWithoutCourseModuleInput, MiniModuleUncheckedCreateWithoutCourseModuleInput> | MiniModuleCreateWithoutCourseModuleInput[] | MiniModuleUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: MiniModuleCreateOrConnectWithoutCourseModuleInput | MiniModuleCreateOrConnectWithoutCourseModuleInput[]
    upsert?: MiniModuleUpsertWithWhereUniqueWithoutCourseModuleInput | MiniModuleUpsertWithWhereUniqueWithoutCourseModuleInput[]
    createMany?: MiniModuleCreateManyCourseModuleInputEnvelope
    set?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    disconnect?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    delete?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    connect?: MiniModuleWhereUniqueInput | MiniModuleWhereUniqueInput[]
    update?: MiniModuleUpdateWithWhereUniqueWithoutCourseModuleInput | MiniModuleUpdateWithWhereUniqueWithoutCourseModuleInput[]
    updateMany?: MiniModuleUpdateManyWithWhereWithoutCourseModuleInput | MiniModuleUpdateManyWithWhereWithoutCourseModuleInput[]
    deleteMany?: MiniModuleScalarWhereInput | MiniModuleScalarWhereInput[]
  }

  export type userModuleProgressUncheckedUpdateManyWithoutCourseModuleNestedInput = {
    create?: XOR<userModuleProgressCreateWithoutCourseModuleInput, userModuleProgressUncheckedCreateWithoutCourseModuleInput> | userModuleProgressCreateWithoutCourseModuleInput[] | userModuleProgressUncheckedCreateWithoutCourseModuleInput[]
    connectOrCreate?: userModuleProgressCreateOrConnectWithoutCourseModuleInput | userModuleProgressCreateOrConnectWithoutCourseModuleInput[]
    upsert?: userModuleProgressUpsertWithWhereUniqueWithoutCourseModuleInput | userModuleProgressUpsertWithWhereUniqueWithoutCourseModuleInput[]
    createMany?: userModuleProgressCreateManyCourseModuleInputEnvelope
    set?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    disconnect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    delete?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    connect?: userModuleProgressWhereUniqueInput | userModuleProgressWhereUniqueInput[]
    update?: userModuleProgressUpdateWithWhereUniqueWithoutCourseModuleInput | userModuleProgressUpdateWithWhereUniqueWithoutCourseModuleInput[]
    updateMany?: userModuleProgressUpdateManyWithWhereWithoutCourseModuleInput | userModuleProgressUpdateManyWithWhereWithoutCourseModuleInput[]
    deleteMany?: userModuleProgressScalarWhereInput | userModuleProgressScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserModuleProgressInput = {
    create?: XOR<UserCreateWithoutUserModuleProgressInput, UserUncheckedCreateWithoutUserModuleProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserModuleProgressInput
    connect?: UserWhereUniqueInput
  }

  export type CourseModuleCreateNestedOneWithoutProgressInput = {
    create?: XOR<CourseModuleCreateWithoutProgressInput, CourseModuleUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutProgressInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserModuleProgressNestedInput = {
    create?: XOR<UserCreateWithoutUserModuleProgressInput, UserUncheckedCreateWithoutUserModuleProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserModuleProgressInput
    upsert?: UserUpsertWithoutUserModuleProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserModuleProgressInput, UserUpdateWithoutUserModuleProgressInput>, UserUncheckedUpdateWithoutUserModuleProgressInput>
  }

  export type CourseModuleUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<CourseModuleCreateWithoutProgressInput, CourseModuleUncheckedCreateWithoutProgressInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutProgressInput
    upsert?: CourseModuleUpsertWithoutProgressInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutProgressInput, CourseModuleUpdateWithoutProgressInput>, CourseModuleUncheckedUpdateWithoutProgressInput>
  }

  export type CourseCreateNestedOneWithoutVideosInput = {
    create?: XOR<CourseCreateWithoutVideosInput, CourseUncheckedCreateWithoutVideosInput>
    connectOrCreate?: CourseCreateOrConnectWithoutVideosInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<CourseCreateWithoutVideosInput, CourseUncheckedCreateWithoutVideosInput>
    connectOrCreate?: CourseCreateOrConnectWithoutVideosInput
    upsert?: CourseUpsertWithoutVideosInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutVideosInput, CourseUpdateWithoutVideosInput>, CourseUncheckedUpdateWithoutVideosInput>
  }

  export type CourseModuleCreateNestedOneWithoutMiniModulesInput = {
    create?: XOR<CourseModuleCreateWithoutMiniModulesInput, CourseModuleUncheckedCreateWithoutMiniModulesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutMiniModulesInput
    connect?: CourseModuleWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutMiniModuleInput = {
    create?: XOR<LessonCreateWithoutMiniModuleInput, LessonUncheckedCreateWithoutMiniModuleInput> | LessonCreateWithoutMiniModuleInput[] | LessonUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutMiniModuleInput | LessonCreateOrConnectWithoutMiniModuleInput[]
    createMany?: LessonCreateManyMiniModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonVideoCreateNestedManyWithoutMiniModuleInput = {
    create?: XOR<LessonVideoCreateWithoutMiniModuleInput, LessonVideoUncheckedCreateWithoutMiniModuleInput> | LessonVideoCreateWithoutMiniModuleInput[] | LessonVideoUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonVideoCreateOrConnectWithoutMiniModuleInput | LessonVideoCreateOrConnectWithoutMiniModuleInput[]
    createMany?: LessonVideoCreateManyMiniModuleInputEnvelope
    connect?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
  }

  export type MiniModuleProgressCreateNestedManyWithoutMiniModuleInput = {
    create?: XOR<MiniModuleProgressCreateWithoutMiniModuleInput, MiniModuleProgressUncheckedCreateWithoutMiniModuleInput> | MiniModuleProgressCreateWithoutMiniModuleInput[] | MiniModuleProgressUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutMiniModuleInput | MiniModuleProgressCreateOrConnectWithoutMiniModuleInput[]
    createMany?: MiniModuleProgressCreateManyMiniModuleInputEnvelope
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutMiniModuleInput = {
    create?: XOR<LessonCreateWithoutMiniModuleInput, LessonUncheckedCreateWithoutMiniModuleInput> | LessonCreateWithoutMiniModuleInput[] | LessonUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutMiniModuleInput | LessonCreateOrConnectWithoutMiniModuleInput[]
    createMany?: LessonCreateManyMiniModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonVideoUncheckedCreateNestedManyWithoutMiniModuleInput = {
    create?: XOR<LessonVideoCreateWithoutMiniModuleInput, LessonVideoUncheckedCreateWithoutMiniModuleInput> | LessonVideoCreateWithoutMiniModuleInput[] | LessonVideoUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonVideoCreateOrConnectWithoutMiniModuleInput | LessonVideoCreateOrConnectWithoutMiniModuleInput[]
    createMany?: LessonVideoCreateManyMiniModuleInputEnvelope
    connect?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
  }

  export type MiniModuleProgressUncheckedCreateNestedManyWithoutMiniModuleInput = {
    create?: XOR<MiniModuleProgressCreateWithoutMiniModuleInput, MiniModuleProgressUncheckedCreateWithoutMiniModuleInput> | MiniModuleProgressCreateWithoutMiniModuleInput[] | MiniModuleProgressUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutMiniModuleInput | MiniModuleProgressCreateOrConnectWithoutMiniModuleInput[]
    createMany?: MiniModuleProgressCreateManyMiniModuleInputEnvelope
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
  }

  export type CourseModuleUpdateOneRequiredWithoutMiniModulesNestedInput = {
    create?: XOR<CourseModuleCreateWithoutMiniModulesInput, CourseModuleUncheckedCreateWithoutMiniModulesInput>
    connectOrCreate?: CourseModuleCreateOrConnectWithoutMiniModulesInput
    upsert?: CourseModuleUpsertWithoutMiniModulesInput
    connect?: CourseModuleWhereUniqueInput
    update?: XOR<XOR<CourseModuleUpdateToOneWithWhereWithoutMiniModulesInput, CourseModuleUpdateWithoutMiniModulesInput>, CourseModuleUncheckedUpdateWithoutMiniModulesInput>
  }

  export type LessonUpdateManyWithoutMiniModuleNestedInput = {
    create?: XOR<LessonCreateWithoutMiniModuleInput, LessonUncheckedCreateWithoutMiniModuleInput> | LessonCreateWithoutMiniModuleInput[] | LessonUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutMiniModuleInput | LessonCreateOrConnectWithoutMiniModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutMiniModuleInput | LessonUpsertWithWhereUniqueWithoutMiniModuleInput[]
    createMany?: LessonCreateManyMiniModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutMiniModuleInput | LessonUpdateWithWhereUniqueWithoutMiniModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutMiniModuleInput | LessonUpdateManyWithWhereWithoutMiniModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonVideoUpdateManyWithoutMiniModuleNestedInput = {
    create?: XOR<LessonVideoCreateWithoutMiniModuleInput, LessonVideoUncheckedCreateWithoutMiniModuleInput> | LessonVideoCreateWithoutMiniModuleInput[] | LessonVideoUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonVideoCreateOrConnectWithoutMiniModuleInput | LessonVideoCreateOrConnectWithoutMiniModuleInput[]
    upsert?: LessonVideoUpsertWithWhereUniqueWithoutMiniModuleInput | LessonVideoUpsertWithWhereUniqueWithoutMiniModuleInput[]
    createMany?: LessonVideoCreateManyMiniModuleInputEnvelope
    set?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    disconnect?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    delete?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    connect?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    update?: LessonVideoUpdateWithWhereUniqueWithoutMiniModuleInput | LessonVideoUpdateWithWhereUniqueWithoutMiniModuleInput[]
    updateMany?: LessonVideoUpdateManyWithWhereWithoutMiniModuleInput | LessonVideoUpdateManyWithWhereWithoutMiniModuleInput[]
    deleteMany?: LessonVideoScalarWhereInput | LessonVideoScalarWhereInput[]
  }

  export type MiniModuleProgressUpdateManyWithoutMiniModuleNestedInput = {
    create?: XOR<MiniModuleProgressCreateWithoutMiniModuleInput, MiniModuleProgressUncheckedCreateWithoutMiniModuleInput> | MiniModuleProgressCreateWithoutMiniModuleInput[] | MiniModuleProgressUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutMiniModuleInput | MiniModuleProgressCreateOrConnectWithoutMiniModuleInput[]
    upsert?: MiniModuleProgressUpsertWithWhereUniqueWithoutMiniModuleInput | MiniModuleProgressUpsertWithWhereUniqueWithoutMiniModuleInput[]
    createMany?: MiniModuleProgressCreateManyMiniModuleInputEnvelope
    set?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    disconnect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    delete?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    update?: MiniModuleProgressUpdateWithWhereUniqueWithoutMiniModuleInput | MiniModuleProgressUpdateWithWhereUniqueWithoutMiniModuleInput[]
    updateMany?: MiniModuleProgressUpdateManyWithWhereWithoutMiniModuleInput | MiniModuleProgressUpdateManyWithWhereWithoutMiniModuleInput[]
    deleteMany?: MiniModuleProgressScalarWhereInput | MiniModuleProgressScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutMiniModuleNestedInput = {
    create?: XOR<LessonCreateWithoutMiniModuleInput, LessonUncheckedCreateWithoutMiniModuleInput> | LessonCreateWithoutMiniModuleInput[] | LessonUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutMiniModuleInput | LessonCreateOrConnectWithoutMiniModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutMiniModuleInput | LessonUpsertWithWhereUniqueWithoutMiniModuleInput[]
    createMany?: LessonCreateManyMiniModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutMiniModuleInput | LessonUpdateWithWhereUniqueWithoutMiniModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutMiniModuleInput | LessonUpdateManyWithWhereWithoutMiniModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonVideoUncheckedUpdateManyWithoutMiniModuleNestedInput = {
    create?: XOR<LessonVideoCreateWithoutMiniModuleInput, LessonVideoUncheckedCreateWithoutMiniModuleInput> | LessonVideoCreateWithoutMiniModuleInput[] | LessonVideoUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: LessonVideoCreateOrConnectWithoutMiniModuleInput | LessonVideoCreateOrConnectWithoutMiniModuleInput[]
    upsert?: LessonVideoUpsertWithWhereUniqueWithoutMiniModuleInput | LessonVideoUpsertWithWhereUniqueWithoutMiniModuleInput[]
    createMany?: LessonVideoCreateManyMiniModuleInputEnvelope
    set?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    disconnect?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    delete?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    connect?: LessonVideoWhereUniqueInput | LessonVideoWhereUniqueInput[]
    update?: LessonVideoUpdateWithWhereUniqueWithoutMiniModuleInput | LessonVideoUpdateWithWhereUniqueWithoutMiniModuleInput[]
    updateMany?: LessonVideoUpdateManyWithWhereWithoutMiniModuleInput | LessonVideoUpdateManyWithWhereWithoutMiniModuleInput[]
    deleteMany?: LessonVideoScalarWhereInput | LessonVideoScalarWhereInput[]
  }

  export type MiniModuleProgressUncheckedUpdateManyWithoutMiniModuleNestedInput = {
    create?: XOR<MiniModuleProgressCreateWithoutMiniModuleInput, MiniModuleProgressUncheckedCreateWithoutMiniModuleInput> | MiniModuleProgressCreateWithoutMiniModuleInput[] | MiniModuleProgressUncheckedCreateWithoutMiniModuleInput[]
    connectOrCreate?: MiniModuleProgressCreateOrConnectWithoutMiniModuleInput | MiniModuleProgressCreateOrConnectWithoutMiniModuleInput[]
    upsert?: MiniModuleProgressUpsertWithWhereUniqueWithoutMiniModuleInput | MiniModuleProgressUpsertWithWhereUniqueWithoutMiniModuleInput[]
    createMany?: MiniModuleProgressCreateManyMiniModuleInputEnvelope
    set?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    disconnect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    delete?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    connect?: MiniModuleProgressWhereUniqueInput | MiniModuleProgressWhereUniqueInput[]
    update?: MiniModuleProgressUpdateWithWhereUniqueWithoutMiniModuleInput | MiniModuleProgressUpdateWithWhereUniqueWithoutMiniModuleInput[]
    updateMany?: MiniModuleProgressUpdateManyWithWhereWithoutMiniModuleInput | MiniModuleProgressUpdateManyWithWhereWithoutMiniModuleInput[]
    deleteMany?: MiniModuleProgressScalarWhereInput | MiniModuleProgressScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMiniModuleProgressInput = {
    create?: XOR<UserCreateWithoutMiniModuleProgressInput, UserUncheckedCreateWithoutMiniModuleProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutMiniModuleProgressInput
    connect?: UserWhereUniqueInput
  }

  export type MiniModuleCreateNestedOneWithoutProgressInput = {
    create?: XOR<MiniModuleCreateWithoutProgressInput, MiniModuleUncheckedCreateWithoutProgressInput>
    connectOrCreate?: MiniModuleCreateOrConnectWithoutProgressInput
    connect?: MiniModuleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMiniModuleProgressNestedInput = {
    create?: XOR<UserCreateWithoutMiniModuleProgressInput, UserUncheckedCreateWithoutMiniModuleProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutMiniModuleProgressInput
    upsert?: UserUpsertWithoutMiniModuleProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMiniModuleProgressInput, UserUpdateWithoutMiniModuleProgressInput>, UserUncheckedUpdateWithoutMiniModuleProgressInput>
  }

  export type MiniModuleUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<MiniModuleCreateWithoutProgressInput, MiniModuleUncheckedCreateWithoutProgressInput>
    connectOrCreate?: MiniModuleCreateOrConnectWithoutProgressInput
    upsert?: MiniModuleUpsertWithoutProgressInput
    connect?: MiniModuleWhereUniqueInput
    update?: XOR<XOR<MiniModuleUpdateToOneWithWhereWithoutProgressInput, MiniModuleUpdateWithoutProgressInput>, MiniModuleUncheckedUpdateWithoutProgressInput>
  }

  export type MiniModuleCreateNestedOneWithoutLessonsInput = {
    create?: XOR<MiniModuleCreateWithoutLessonsInput, MiniModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: MiniModuleCreateOrConnectWithoutLessonsInput
    connect?: MiniModuleWhereUniqueInput
  }

  export type LessonSolutionCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonSolutionCreateWithoutLessonInput, LessonSolutionUncheckedCreateWithoutLessonInput> | LessonSolutionCreateWithoutLessonInput[] | LessonSolutionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonSolutionCreateOrConnectWithoutLessonInput | LessonSolutionCreateOrConnectWithoutLessonInput[]
    createMany?: LessonSolutionCreateManyLessonInputEnvelope
    connect?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
  }

  export type UserLessonProgressCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type LessonSolutionUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonSolutionCreateWithoutLessonInput, LessonSolutionUncheckedCreateWithoutLessonInput> | LessonSolutionCreateWithoutLessonInput[] | LessonSolutionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonSolutionCreateOrConnectWithoutLessonInput | LessonSolutionCreateOrConnectWithoutLessonInput[]
    createMany?: LessonSolutionCreateManyLessonInputEnvelope
    connect?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
  }

  export type UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
  }

  export type MiniModuleUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<MiniModuleCreateWithoutLessonsInput, MiniModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: MiniModuleCreateOrConnectWithoutLessonsInput
    upsert?: MiniModuleUpsertWithoutLessonsInput
    connect?: MiniModuleWhereUniqueInput
    update?: XOR<XOR<MiniModuleUpdateToOneWithWhereWithoutLessonsInput, MiniModuleUpdateWithoutLessonsInput>, MiniModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type LessonSolutionUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonSolutionCreateWithoutLessonInput, LessonSolutionUncheckedCreateWithoutLessonInput> | LessonSolutionCreateWithoutLessonInput[] | LessonSolutionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonSolutionCreateOrConnectWithoutLessonInput | LessonSolutionCreateOrConnectWithoutLessonInput[]
    upsert?: LessonSolutionUpsertWithWhereUniqueWithoutLessonInput | LessonSolutionUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonSolutionCreateManyLessonInputEnvelope
    set?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    disconnect?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    delete?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    connect?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    update?: LessonSolutionUpdateWithWhereUniqueWithoutLessonInput | LessonSolutionUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonSolutionUpdateManyWithWhereWithoutLessonInput | LessonSolutionUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonSolutionScalarWhereInput | LessonSolutionScalarWhereInput[]
  }

  export type UserLessonProgressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput | UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput | UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutLessonInput | UserLessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type LessonSolutionUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonSolutionCreateWithoutLessonInput, LessonSolutionUncheckedCreateWithoutLessonInput> | LessonSolutionCreateWithoutLessonInput[] | LessonSolutionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonSolutionCreateOrConnectWithoutLessonInput | LessonSolutionCreateOrConnectWithoutLessonInput[]
    upsert?: LessonSolutionUpsertWithWhereUniqueWithoutLessonInput | LessonSolutionUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonSolutionCreateManyLessonInputEnvelope
    set?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    disconnect?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    delete?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    connect?: LessonSolutionWhereUniqueInput | LessonSolutionWhereUniqueInput[]
    update?: LessonSolutionUpdateWithWhereUniqueWithoutLessonInput | LessonSolutionUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonSolutionUpdateManyWithWhereWithoutLessonInput | LessonSolutionUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonSolutionScalarWhereInput | LessonSolutionScalarWhereInput[]
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput> | UserLessonProgressCreateWithoutLessonInput[] | UserLessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserLessonProgressCreateOrConnectWithoutLessonInput | UserLessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput | UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserLessonProgressCreateManyLessonInputEnvelope
    set?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    disconnect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    delete?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    connect?: UserLessonProgressWhereUniqueInput | UserLessonProgressWhereUniqueInput[]
    update?: UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput | UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserLessonProgressUpdateManyWithWhereWithoutLessonInput | UserLessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
  }

  export type MiniModuleCreateNestedOneWithoutLessonVideosInput = {
    create?: XOR<MiniModuleCreateWithoutLessonVideosInput, MiniModuleUncheckedCreateWithoutLessonVideosInput>
    connectOrCreate?: MiniModuleCreateOrConnectWithoutLessonVideosInput
    connect?: MiniModuleWhereUniqueInput
  }

  export type MiniModuleUpdateOneRequiredWithoutLessonVideosNestedInput = {
    create?: XOR<MiniModuleCreateWithoutLessonVideosInput, MiniModuleUncheckedCreateWithoutLessonVideosInput>
    connectOrCreate?: MiniModuleCreateOrConnectWithoutLessonVideosInput
    upsert?: MiniModuleUpsertWithoutLessonVideosInput
    connect?: MiniModuleWhereUniqueInput
    update?: XOR<XOR<MiniModuleUpdateToOneWithWhereWithoutLessonVideosInput, MiniModuleUpdateWithoutLessonVideosInput>, MiniModuleUncheckedUpdateWithoutLessonVideosInput>
  }

  export type LessonCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<LessonCreateWithoutSolutionsInput, LessonUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutSolutionsInput
    connect?: LessonWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutSolutionsNestedInput = {
    create?: XOR<LessonCreateWithoutSolutionsInput, LessonUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutSolutionsInput
    upsert?: LessonUpsertWithoutSolutionsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutSolutionsInput, LessonUpdateWithoutSolutionsInput>, LessonUncheckedUpdateWithoutSolutionsInput>
  }

  export type UserCreateNestedOneWithoutUserLessonProgressInput = {
    create?: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLessonProgressInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutProgressInput = {
    create?: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressInput
    connect?: LessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLessonProgressNestedInput = {
    create?: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLessonProgressInput
    upsert?: UserUpsertWithoutUserLessonProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserLessonProgressInput, UserUpdateWithoutUserLessonProgressInput>, UserUncheckedUpdateWithoutUserLessonProgressInput>
  }

  export type LessonUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressInput
    upsert?: LessonUpsertWithoutProgressInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutProgressInput, LessonUpdateWithoutProgressInput>, LessonUncheckedUpdateWithoutProgressInput>
  }

  export type UserCreateNestedOneWithoutRatingsInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutRatingsInput = {
    create?: XOR<CourseCreateWithoutRatingsInput, CourseUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRatingsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    upsert?: UserUpsertWithoutRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatingsInput, UserUpdateWithoutRatingsInput>, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type CourseUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<CourseCreateWithoutRatingsInput, CourseUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutRatingsInput
    upsert?: CourseUpsertWithoutRatingsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutRatingsInput, CourseUpdateWithoutRatingsInput>, CourseUncheckedUpdateWithoutRatingsInput>
  }

  export type ChallengeInstructionsCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeInstructionsCreateWithoutChallengeInput, ChallengeInstructionsUncheckedCreateWithoutChallengeInput> | ChallengeInstructionsCreateWithoutChallengeInput[] | ChallengeInstructionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeInstructionsCreateOrConnectWithoutChallengeInput | ChallengeInstructionsCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeInstructionsCreateManyChallengeInputEnvelope
    connect?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
  }

  export type ChallengeLikeCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeLikeCreateWithoutChallengeInput, ChallengeLikeUncheckedCreateWithoutChallengeInput> | ChallengeLikeCreateWithoutChallengeInput[] | ChallengeLikeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutChallengeInput | ChallengeLikeCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeLikeCreateManyChallengeInputEnvelope
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
  }

  export type ChallengeSolutionsCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeSolutionsCreateWithoutChallengeInput, ChallengeSolutionsUncheckedCreateWithoutChallengeInput> | ChallengeSolutionsCreateWithoutChallengeInput[] | ChallengeSolutionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSolutionsCreateOrConnectWithoutChallengeInput | ChallengeSolutionsCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeSolutionsCreateManyChallengeInputEnvelope
    connect?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
  }

  export type CompletedChallengesCreateNestedManyWithoutChallengeInput = {
    create?: XOR<CompletedChallengesCreateWithoutChallengeInput, CompletedChallengesUncheckedCreateWithoutChallengeInput> | CompletedChallengesCreateWithoutChallengeInput[] | CompletedChallengesUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutChallengeInput | CompletedChallengesCreateOrConnectWithoutChallengeInput[]
    createMany?: CompletedChallengesCreateManyChallengeInputEnvelope
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
  }

  export type ChallengeInstructionsUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeInstructionsCreateWithoutChallengeInput, ChallengeInstructionsUncheckedCreateWithoutChallengeInput> | ChallengeInstructionsCreateWithoutChallengeInput[] | ChallengeInstructionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeInstructionsCreateOrConnectWithoutChallengeInput | ChallengeInstructionsCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeInstructionsCreateManyChallengeInputEnvelope
    connect?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
  }

  export type ChallengeLikeUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeLikeCreateWithoutChallengeInput, ChallengeLikeUncheckedCreateWithoutChallengeInput> | ChallengeLikeCreateWithoutChallengeInput[] | ChallengeLikeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutChallengeInput | ChallengeLikeCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeLikeCreateManyChallengeInputEnvelope
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
  }

  export type ChallengeSolutionsUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeSolutionsCreateWithoutChallengeInput, ChallengeSolutionsUncheckedCreateWithoutChallengeInput> | ChallengeSolutionsCreateWithoutChallengeInput[] | ChallengeSolutionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSolutionsCreateOrConnectWithoutChallengeInput | ChallengeSolutionsCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeSolutionsCreateManyChallengeInputEnvelope
    connect?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
  }

  export type CompletedChallengesUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<CompletedChallengesCreateWithoutChallengeInput, CompletedChallengesUncheckedCreateWithoutChallengeInput> | CompletedChallengesCreateWithoutChallengeInput[] | CompletedChallengesUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutChallengeInput | CompletedChallengesCreateOrConnectWithoutChallengeInput[]
    createMany?: CompletedChallengesCreateManyChallengeInputEnvelope
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
  }

  export type ChallengeInstructionsUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeInstructionsCreateWithoutChallengeInput, ChallengeInstructionsUncheckedCreateWithoutChallengeInput> | ChallengeInstructionsCreateWithoutChallengeInput[] | ChallengeInstructionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeInstructionsCreateOrConnectWithoutChallengeInput | ChallengeInstructionsCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeInstructionsUpsertWithWhereUniqueWithoutChallengeInput | ChallengeInstructionsUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeInstructionsCreateManyChallengeInputEnvelope
    set?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    disconnect?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    delete?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    connect?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    update?: ChallengeInstructionsUpdateWithWhereUniqueWithoutChallengeInput | ChallengeInstructionsUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeInstructionsUpdateManyWithWhereWithoutChallengeInput | ChallengeInstructionsUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeInstructionsScalarWhereInput | ChallengeInstructionsScalarWhereInput[]
  }

  export type ChallengeLikeUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeLikeCreateWithoutChallengeInput, ChallengeLikeUncheckedCreateWithoutChallengeInput> | ChallengeLikeCreateWithoutChallengeInput[] | ChallengeLikeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutChallengeInput | ChallengeLikeCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeLikeUpsertWithWhereUniqueWithoutChallengeInput | ChallengeLikeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeLikeCreateManyChallengeInputEnvelope
    set?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    disconnect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    delete?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    update?: ChallengeLikeUpdateWithWhereUniqueWithoutChallengeInput | ChallengeLikeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeLikeUpdateManyWithWhereWithoutChallengeInput | ChallengeLikeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeLikeScalarWhereInput | ChallengeLikeScalarWhereInput[]
  }

  export type ChallengeSolutionsUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeSolutionsCreateWithoutChallengeInput, ChallengeSolutionsUncheckedCreateWithoutChallengeInput> | ChallengeSolutionsCreateWithoutChallengeInput[] | ChallengeSolutionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSolutionsCreateOrConnectWithoutChallengeInput | ChallengeSolutionsCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeSolutionsUpsertWithWhereUniqueWithoutChallengeInput | ChallengeSolutionsUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeSolutionsCreateManyChallengeInputEnvelope
    set?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    disconnect?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    delete?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    connect?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    update?: ChallengeSolutionsUpdateWithWhereUniqueWithoutChallengeInput | ChallengeSolutionsUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeSolutionsUpdateManyWithWhereWithoutChallengeInput | ChallengeSolutionsUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeSolutionsScalarWhereInput | ChallengeSolutionsScalarWhereInput[]
  }

  export type CompletedChallengesUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<CompletedChallengesCreateWithoutChallengeInput, CompletedChallengesUncheckedCreateWithoutChallengeInput> | CompletedChallengesCreateWithoutChallengeInput[] | CompletedChallengesUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutChallengeInput | CompletedChallengesCreateOrConnectWithoutChallengeInput[]
    upsert?: CompletedChallengesUpsertWithWhereUniqueWithoutChallengeInput | CompletedChallengesUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: CompletedChallengesCreateManyChallengeInputEnvelope
    set?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    disconnect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    delete?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    update?: CompletedChallengesUpdateWithWhereUniqueWithoutChallengeInput | CompletedChallengesUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: CompletedChallengesUpdateManyWithWhereWithoutChallengeInput | CompletedChallengesUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
  }

  export type ChallengeInstructionsUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeInstructionsCreateWithoutChallengeInput, ChallengeInstructionsUncheckedCreateWithoutChallengeInput> | ChallengeInstructionsCreateWithoutChallengeInput[] | ChallengeInstructionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeInstructionsCreateOrConnectWithoutChallengeInput | ChallengeInstructionsCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeInstructionsUpsertWithWhereUniqueWithoutChallengeInput | ChallengeInstructionsUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeInstructionsCreateManyChallengeInputEnvelope
    set?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    disconnect?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    delete?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    connect?: ChallengeInstructionsWhereUniqueInput | ChallengeInstructionsWhereUniqueInput[]
    update?: ChallengeInstructionsUpdateWithWhereUniqueWithoutChallengeInput | ChallengeInstructionsUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeInstructionsUpdateManyWithWhereWithoutChallengeInput | ChallengeInstructionsUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeInstructionsScalarWhereInput | ChallengeInstructionsScalarWhereInput[]
  }

  export type ChallengeLikeUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeLikeCreateWithoutChallengeInput, ChallengeLikeUncheckedCreateWithoutChallengeInput> | ChallengeLikeCreateWithoutChallengeInput[] | ChallengeLikeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeLikeCreateOrConnectWithoutChallengeInput | ChallengeLikeCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeLikeUpsertWithWhereUniqueWithoutChallengeInput | ChallengeLikeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeLikeCreateManyChallengeInputEnvelope
    set?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    disconnect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    delete?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    connect?: ChallengeLikeWhereUniqueInput | ChallengeLikeWhereUniqueInput[]
    update?: ChallengeLikeUpdateWithWhereUniqueWithoutChallengeInput | ChallengeLikeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeLikeUpdateManyWithWhereWithoutChallengeInput | ChallengeLikeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeLikeScalarWhereInput | ChallengeLikeScalarWhereInput[]
  }

  export type ChallengeSolutionsUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeSolutionsCreateWithoutChallengeInput, ChallengeSolutionsUncheckedCreateWithoutChallengeInput> | ChallengeSolutionsCreateWithoutChallengeInput[] | ChallengeSolutionsUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeSolutionsCreateOrConnectWithoutChallengeInput | ChallengeSolutionsCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeSolutionsUpsertWithWhereUniqueWithoutChallengeInput | ChallengeSolutionsUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeSolutionsCreateManyChallengeInputEnvelope
    set?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    disconnect?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    delete?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    connect?: ChallengeSolutionsWhereUniqueInput | ChallengeSolutionsWhereUniqueInput[]
    update?: ChallengeSolutionsUpdateWithWhereUniqueWithoutChallengeInput | ChallengeSolutionsUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeSolutionsUpdateManyWithWhereWithoutChallengeInput | ChallengeSolutionsUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeSolutionsScalarWhereInput | ChallengeSolutionsScalarWhereInput[]
  }

  export type CompletedChallengesUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<CompletedChallengesCreateWithoutChallengeInput, CompletedChallengesUncheckedCreateWithoutChallengeInput> | CompletedChallengesCreateWithoutChallengeInput[] | CompletedChallengesUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: CompletedChallengesCreateOrConnectWithoutChallengeInput | CompletedChallengesCreateOrConnectWithoutChallengeInput[]
    upsert?: CompletedChallengesUpsertWithWhereUniqueWithoutChallengeInput | CompletedChallengesUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: CompletedChallengesCreateManyChallengeInputEnvelope
    set?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    disconnect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    delete?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    connect?: CompletedChallengesWhereUniqueInput | CompletedChallengesWhereUniqueInput[]
    update?: CompletedChallengesUpdateWithWhereUniqueWithoutChallengeInput | CompletedChallengesUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: CompletedChallengesUpdateManyWithWhereWithoutChallengeInput | CompletedChallengesUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserCreateNestedOneWithoutChallengeLikeInput = {
    create?: XOR<UserCreateWithoutChallengeLikeInput, UserUncheckedCreateWithoutChallengeLikeInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeLikeInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutLikesListInput = {
    create?: XOR<ChallengeCreateWithoutLikesListInput, ChallengeUncheckedCreateWithoutLikesListInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutLikesListInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChallengeLikeNestedInput = {
    create?: XOR<UserCreateWithoutChallengeLikeInput, UserUncheckedCreateWithoutChallengeLikeInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeLikeInput
    upsert?: UserUpsertWithoutChallengeLikeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengeLikeInput, UserUpdateWithoutChallengeLikeInput>, UserUncheckedUpdateWithoutChallengeLikeInput>
  }

  export type ChallengeUpdateOneRequiredWithoutLikesListNestedInput = {
    create?: XOR<ChallengeCreateWithoutLikesListInput, ChallengeUncheckedCreateWithoutLikesListInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutLikesListInput
    upsert?: ChallengeUpsertWithoutLikesListInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutLikesListInput, ChallengeUpdateWithoutLikesListInput>, ChallengeUncheckedUpdateWithoutLikesListInput>
  }

  export type ChallengeCreateNestedOneWithoutInstructionsInput = {
    create?: XOR<ChallengeCreateWithoutInstructionsInput, ChallengeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutInstructionsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutInstructionsNestedInput = {
    create?: XOR<ChallengeCreateWithoutInstructionsInput, ChallengeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutInstructionsInput
    upsert?: ChallengeUpsertWithoutInstructionsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutInstructionsInput, ChallengeUpdateWithoutInstructionsInput>, ChallengeUncheckedUpdateWithoutInstructionsInput>
  }

  export type ChallengeCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<ChallengeCreateWithoutSolutionsInput, ChallengeUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutSolutionsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutSolutionsNestedInput = {
    create?: XOR<ChallengeCreateWithoutSolutionsInput, ChallengeUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutSolutionsInput
    upsert?: ChallengeUpsertWithoutSolutionsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutSolutionsInput, ChallengeUpdateWithoutSolutionsInput>, ChallengeUncheckedUpdateWithoutSolutionsInput>
  }

  export type UserCreateNestedOneWithoutCompletedChallengesInput = {
    create?: XOR<UserCreateWithoutCompletedChallengesInput, UserUncheckedCreateWithoutCompletedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<ChallengeCreateWithoutCompletionsInput, ChallengeUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutCompletionsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type CourseCreateNestedManyWithoutCompletedChallengesInput = {
    create?: XOR<CourseCreateWithoutCompletedChallengesInput, CourseUncheckedCreateWithoutCompletedChallengesInput> | CourseCreateWithoutCompletedChallengesInput[] | CourseUncheckedCreateWithoutCompletedChallengesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompletedChallengesInput | CourseCreateOrConnectWithoutCompletedChallengesInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCompletedChallengesInput = {
    create?: XOR<CourseCreateWithoutCompletedChallengesInput, CourseUncheckedCreateWithoutCompletedChallengesInput> | CourseCreateWithoutCompletedChallengesInput[] | CourseUncheckedCreateWithoutCompletedChallengesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompletedChallengesInput | CourseCreateOrConnectWithoutCompletedChallengesInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCompletedChallengesNestedInput = {
    create?: XOR<UserCreateWithoutCompletedChallengesInput, UserUncheckedCreateWithoutCompletedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedChallengesInput
    upsert?: UserUpsertWithoutCompletedChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompletedChallengesInput, UserUpdateWithoutCompletedChallengesInput>, UserUncheckedUpdateWithoutCompletedChallengesInput>
  }

  export type ChallengeUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<ChallengeCreateWithoutCompletionsInput, ChallengeUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutCompletionsInput
    upsert?: ChallengeUpsertWithoutCompletionsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutCompletionsInput, ChallengeUpdateWithoutCompletionsInput>, ChallengeUncheckedUpdateWithoutCompletionsInput>
  }

  export type CourseUpdateManyWithoutCompletedChallengesNestedInput = {
    create?: XOR<CourseCreateWithoutCompletedChallengesInput, CourseUncheckedCreateWithoutCompletedChallengesInput> | CourseCreateWithoutCompletedChallengesInput[] | CourseUncheckedCreateWithoutCompletedChallengesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompletedChallengesInput | CourseCreateOrConnectWithoutCompletedChallengesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCompletedChallengesInput | CourseUpsertWithWhereUniqueWithoutCompletedChallengesInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCompletedChallengesInput | CourseUpdateWithWhereUniqueWithoutCompletedChallengesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCompletedChallengesInput | CourseUpdateManyWithWhereWithoutCompletedChallengesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCompletedChallengesNestedInput = {
    create?: XOR<CourseCreateWithoutCompletedChallengesInput, CourseUncheckedCreateWithoutCompletedChallengesInput> | CourseCreateWithoutCompletedChallengesInput[] | CourseUncheckedCreateWithoutCompletedChallengesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCompletedChallengesInput | CourseCreateOrConnectWithoutCompletedChallengesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCompletedChallengesInput | CourseUpsertWithWhereUniqueWithoutCompletedChallengesInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCompletedChallengesInput | CourseUpdateWithWhereUniqueWithoutCompletedChallengesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCompletedChallengesInput | CourseUpdateManyWithWhereWithoutCompletedChallengesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelFilter<$PrismaModel> | $Enums.Level
  }

  export type NestedEnumLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Level | EnumLevelFieldRefInput<$PrismaModel>
    in?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Level[] | ListEnumLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelWithAggregatesFilter<$PrismaModel> | $Enums.Level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelFilter<$PrismaModel>
    _max?: NestedEnumLevelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CourseCreateWithoutUsersInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUsersInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUsersInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUsersInput, CourseUncheckedCreateWithoutUsersInput>
  }

  export type CourseRatingCreateWithoutUserInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutRatingsInput
  }

  export type CourseRatingUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseRatingCreateOrConnectWithoutUserInput = {
    where: CourseRatingWhereUniqueInput
    create: XOR<CourseRatingCreateWithoutUserInput, CourseRatingUncheckedCreateWithoutUserInput>
  }

  export type CourseRatingCreateManyUserInputEnvelope = {
    data: CourseRatingCreateManyUserInput | CourseRatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeLikeCreateWithoutUserInput = {
    challenge: ChallengeCreateNestedOneWithoutLikesListInput
  }

  export type ChallengeLikeUncheckedCreateWithoutUserInput = {
    id?: number
    challengeId: number
  }

  export type ChallengeLikeCreateOrConnectWithoutUserInput = {
    where: ChallengeLikeWhereUniqueInput
    create: XOR<ChallengeLikeCreateWithoutUserInput, ChallengeLikeUncheckedCreateWithoutUserInput>
  }

  export type ChallengeLikeCreateManyUserInputEnvelope = {
    data: ChallengeLikeCreateManyUserInput | ChallengeLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileImageCreateWithoutUserInput = {
    path: string
  }

  export type UserProfileImageUncheckedCreateWithoutUserInput = {
    id?: number
    path: string
  }

  export type UserProfileImageCreateOrConnectWithoutUserInput = {
    where: UserProfileImageWhereUniqueInput
    create: XOR<UserProfileImageCreateWithoutUserInput, UserProfileImageUncheckedCreateWithoutUserInput>
  }

  export type UserProfileImageCreateManyUserInputEnvelope = {
    data: UserProfileImageCreateManyUserInput | UserProfileImageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCreatorInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseCreateManyCreatorInputEnvelope = {
    data: CourseCreateManyCreatorInput | CourseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseProgressCreateWithoutUserInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
    course: CourseCreateNestedOneWithoutProgressInput
  }

  export type UserCourseProgressUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
  }

  export type UserCourseProgressCreateOrConnectWithoutUserInput = {
    where: UserCourseProgressWhereUniqueInput
    create: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput>
  }

  export type UserCourseProgressCreateManyUserInputEnvelope = {
    data: UserCourseProgressCreateManyUserInput | UserCourseProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userModuleProgressCreateWithoutUserInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    courseModule: CourseModuleCreateNestedOneWithoutProgressInput
  }

  export type userModuleProgressUncheckedCreateWithoutUserInput = {
    id?: number
    courseModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
  }

  export type userModuleProgressCreateOrConnectWithoutUserInput = {
    where: userModuleProgressWhereUniqueInput
    create: XOR<userModuleProgressCreateWithoutUserInput, userModuleProgressUncheckedCreateWithoutUserInput>
  }

  export type userModuleProgressCreateManyUserInputEnvelope = {
    data: userModuleProgressCreateManyUserInput | userModuleProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MiniModuleProgressCreateWithoutUserInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    miniModule: MiniModuleCreateNestedOneWithoutProgressInput
  }

  export type MiniModuleProgressUncheckedCreateWithoutUserInput = {
    id?: number
    miniModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type MiniModuleProgressCreateOrConnectWithoutUserInput = {
    where: MiniModuleProgressWhereUniqueInput
    create: XOR<MiniModuleProgressCreateWithoutUserInput, MiniModuleProgressUncheckedCreateWithoutUserInput>
  }

  export type MiniModuleProgressCreateManyUserInputEnvelope = {
    data: MiniModuleProgressCreateManyUserInput | MiniModuleProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLessonProgressCreateWithoutUserInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutProgressInput
  }

  export type UserLessonProgressUncheckedCreateWithoutUserInput = {
    id?: number
    lessonId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonProgressCreateOrConnectWithoutUserInput = {
    where: UserLessonProgressWhereUniqueInput
    create: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput>
  }

  export type UserLessonProgressCreateManyUserInputEnvelope = {
    data: UserLessonProgressCreateManyUserInput | UserLessonProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseLikeCreateWithoutUserInput = {
    createdAt?: Date | string
    course: CourseCreateNestedOneWithoutLikedByInput
  }

  export type CourseLikeUncheckedCreateWithoutUserInput = {
    id?: number
    courseId: number
    createdAt?: Date | string
  }

  export type CourseLikeCreateOrConnectWithoutUserInput = {
    where: CourseLikeWhereUniqueInput
    create: XOR<CourseLikeCreateWithoutUserInput, CourseLikeUncheckedCreateWithoutUserInput>
  }

  export type CourseLikeCreateManyUserInputEnvelope = {
    data: CourseLikeCreateManyUserInput | CourseLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompletedChallengesCreateWithoutUserInput = {
    createdAt?: Date | string
    challenge: ChallengeCreateNestedOneWithoutCompletionsInput
    Course?: CourseCreateNestedManyWithoutCompletedChallengesInput
  }

  export type CompletedChallengesUncheckedCreateWithoutUserInput = {
    id?: number
    challengeId: number
    createdAt?: Date | string
    Course?: CourseUncheckedCreateNestedManyWithoutCompletedChallengesInput
  }

  export type CompletedChallengesCreateOrConnectWithoutUserInput = {
    where: CompletedChallengesWhereUniqueInput
    create: XOR<CompletedChallengesCreateWithoutUserInput, CompletedChallengesUncheckedCreateWithoutUserInput>
  }

  export type CompletedChallengesCreateManyUserInputEnvelope = {
    data: CompletedChallengesCreateManyUserInput | CompletedChallengesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: number
    receiverId: number
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: number
    senderId: number
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutUsersInput = {
    update: XOR<CourseUpdateWithoutUsersInput, CourseUncheckedUpdateWithoutUsersInput>
    create: XOR<CourseCreateWithoutUsersInput, CourseUncheckedCreateWithoutUsersInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutUsersInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutUsersInput, CourseUncheckedUpdateWithoutUsersInput>
  }

  export type CourseUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseRatingUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseRatingWhereUniqueInput
    update: XOR<CourseRatingUpdateWithoutUserInput, CourseRatingUncheckedUpdateWithoutUserInput>
    create: XOR<CourseRatingCreateWithoutUserInput, CourseRatingUncheckedCreateWithoutUserInput>
  }

  export type CourseRatingUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseRatingWhereUniqueInput
    data: XOR<CourseRatingUpdateWithoutUserInput, CourseRatingUncheckedUpdateWithoutUserInput>
  }

  export type CourseRatingUpdateManyWithWhereWithoutUserInput = {
    where: CourseRatingScalarWhereInput
    data: XOR<CourseRatingUpdateManyMutationInput, CourseRatingUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseRatingScalarWhereInput = {
    AND?: CourseRatingScalarWhereInput | CourseRatingScalarWhereInput[]
    OR?: CourseRatingScalarWhereInput[]
    NOT?: CourseRatingScalarWhereInput | CourseRatingScalarWhereInput[]
    id?: IntFilter<"CourseRating"> | number
    userId?: IntFilter<"CourseRating"> | number
    courseId?: IntFilter<"CourseRating"> | number
    rating?: IntFilter<"CourseRating"> | number
    comment?: StringNullableFilter<"CourseRating"> | string | null
    createdAt?: DateTimeFilter<"CourseRating"> | Date | string
  }

  export type ChallengeLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeLikeWhereUniqueInput
    update: XOR<ChallengeLikeUpdateWithoutUserInput, ChallengeLikeUncheckedUpdateWithoutUserInput>
    create: XOR<ChallengeLikeCreateWithoutUserInput, ChallengeLikeUncheckedCreateWithoutUserInput>
  }

  export type ChallengeLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeLikeWhereUniqueInput
    data: XOR<ChallengeLikeUpdateWithoutUserInput, ChallengeLikeUncheckedUpdateWithoutUserInput>
  }

  export type ChallengeLikeUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeLikeScalarWhereInput
    data: XOR<ChallengeLikeUpdateManyMutationInput, ChallengeLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type ChallengeLikeScalarWhereInput = {
    AND?: ChallengeLikeScalarWhereInput | ChallengeLikeScalarWhereInput[]
    OR?: ChallengeLikeScalarWhereInput[]
    NOT?: ChallengeLikeScalarWhereInput | ChallengeLikeScalarWhereInput[]
    id?: IntFilter<"ChallengeLike"> | number
    userId?: IntFilter<"ChallengeLike"> | number
    challengeId?: IntFilter<"ChallengeLike"> | number
  }

  export type UserProfileImageUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProfileImageWhereUniqueInput
    update: XOR<UserProfileImageUpdateWithoutUserInput, UserProfileImageUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileImageCreateWithoutUserInput, UserProfileImageUncheckedCreateWithoutUserInput>
  }

  export type UserProfileImageUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProfileImageWhereUniqueInput
    data: XOR<UserProfileImageUpdateWithoutUserInput, UserProfileImageUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileImageUpdateManyWithWhereWithoutUserInput = {
    where: UserProfileImageScalarWhereInput
    data: XOR<UserProfileImageUpdateManyMutationInput, UserProfileImageUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProfileImageScalarWhereInput = {
    AND?: UserProfileImageScalarWhereInput | UserProfileImageScalarWhereInput[]
    OR?: UserProfileImageScalarWhereInput[]
    NOT?: UserProfileImageScalarWhereInput | UserProfileImageScalarWhereInput[]
    id?: IntFilter<"UserProfileImage"> | number
    path?: StringFilter<"UserProfileImage"> | string
    userId?: IntFilter<"UserProfileImage"> | number
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: IntFilter<"Course"> | number
    creatorId?: IntFilter<"Course"> | number
    title?: StringFilter<"Course"> | string
    category?: StringFilter<"Course"> | string
    level?: EnumLevelFilter<"Course"> | $Enums.Level
    description?: StringFilter<"Course"> | string
    duration?: StringFilter<"Course"> | string
    studentsCount?: IntFilter<"Course"> | number
    rating?: FloatFilter<"Course"> | number
    likes?: IntFilter<"Course"> | number
    completions?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type UserCourseProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCourseProgressWhereUniqueInput
    update: XOR<UserCourseProgressUpdateWithoutUserInput, UserCourseProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserCourseProgressCreateWithoutUserInput, UserCourseProgressUncheckedCreateWithoutUserInput>
  }

  export type UserCourseProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCourseProgressWhereUniqueInput
    data: XOR<UserCourseProgressUpdateWithoutUserInput, UserCourseProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserCourseProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserCourseProgressScalarWhereInput
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCourseProgressScalarWhereInput = {
    AND?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
    OR?: UserCourseProgressScalarWhereInput[]
    NOT?: UserCourseProgressScalarWhereInput | UserCourseProgressScalarWhereInput[]
    id?: IntFilter<"UserCourseProgress"> | number
    userId?: IntFilter<"UserCourseProgress"> | number
    courseId?: IntFilter<"UserCourseProgress"> | number
    currentStep?: IntFilter<"UserCourseProgress"> | number
    completed?: BoolFilter<"UserCourseProgress"> | boolean
    startedAt?: DateTimeFilter<"UserCourseProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourseProgress"> | Date | string
    rating?: IntNullableFilter<"UserCourseProgress"> | number | null
  }

  export type userModuleProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: userModuleProgressWhereUniqueInput
    update: XOR<userModuleProgressUpdateWithoutUserInput, userModuleProgressUncheckedUpdateWithoutUserInput>
    create: XOR<userModuleProgressCreateWithoutUserInput, userModuleProgressUncheckedCreateWithoutUserInput>
  }

  export type userModuleProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: userModuleProgressWhereUniqueInput
    data: XOR<userModuleProgressUpdateWithoutUserInput, userModuleProgressUncheckedUpdateWithoutUserInput>
  }

  export type userModuleProgressUpdateManyWithWhereWithoutUserInput = {
    where: userModuleProgressScalarWhereInput
    data: XOR<userModuleProgressUpdateManyMutationInput, userModuleProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type userModuleProgressScalarWhereInput = {
    AND?: userModuleProgressScalarWhereInput | userModuleProgressScalarWhereInput[]
    OR?: userModuleProgressScalarWhereInput[]
    NOT?: userModuleProgressScalarWhereInput | userModuleProgressScalarWhereInput[]
    id?: IntFilter<"userModuleProgress"> | number
    userId?: IntFilter<"userModuleProgress"> | number
    courseModuleId?: IntFilter<"userModuleProgress"> | number
    currentStep?: IntFilter<"userModuleProgress"> | number
    completed?: BoolFilter<"userModuleProgress"> | boolean
    startedAt?: DateTimeFilter<"userModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"userModuleProgress"> | Date | string
    courseId?: IntNullableFilter<"userModuleProgress"> | number | null
  }

  export type MiniModuleProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: MiniModuleProgressWhereUniqueInput
    update: XOR<MiniModuleProgressUpdateWithoutUserInput, MiniModuleProgressUncheckedUpdateWithoutUserInput>
    create: XOR<MiniModuleProgressCreateWithoutUserInput, MiniModuleProgressUncheckedCreateWithoutUserInput>
  }

  export type MiniModuleProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: MiniModuleProgressWhereUniqueInput
    data: XOR<MiniModuleProgressUpdateWithoutUserInput, MiniModuleProgressUncheckedUpdateWithoutUserInput>
  }

  export type MiniModuleProgressUpdateManyWithWhereWithoutUserInput = {
    where: MiniModuleProgressScalarWhereInput
    data: XOR<MiniModuleProgressUpdateManyMutationInput, MiniModuleProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type MiniModuleProgressScalarWhereInput = {
    AND?: MiniModuleProgressScalarWhereInput | MiniModuleProgressScalarWhereInput[]
    OR?: MiniModuleProgressScalarWhereInput[]
    NOT?: MiniModuleProgressScalarWhereInput | MiniModuleProgressScalarWhereInput[]
    id?: IntFilter<"MiniModuleProgress"> | number
    userId?: IntFilter<"MiniModuleProgress"> | number
    miniModuleId?: IntFilter<"MiniModuleProgress"> | number
    currentStep?: IntFilter<"MiniModuleProgress"> | number
    completed?: BoolFilter<"MiniModuleProgress"> | boolean
    startedAt?: DateTimeFilter<"MiniModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"MiniModuleProgress"> | Date | string
  }

  export type UserLessonProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLessonProgressWhereUniqueInput
    update: XOR<UserLessonProgressUpdateWithoutUserInput, UserLessonProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserLessonProgressCreateWithoutUserInput, UserLessonProgressUncheckedCreateWithoutUserInput>
  }

  export type UserLessonProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLessonProgressWhereUniqueInput
    data: XOR<UserLessonProgressUpdateWithoutUserInput, UserLessonProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserLessonProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserLessonProgressScalarWhereInput
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLessonProgressScalarWhereInput = {
    AND?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
    OR?: UserLessonProgressScalarWhereInput[]
    NOT?: UserLessonProgressScalarWhereInput | UserLessonProgressScalarWhereInput[]
    id?: IntFilter<"UserLessonProgress"> | number
    userId?: IntFilter<"UserLessonProgress"> | number
    lessonId?: IntFilter<"UserLessonProgress"> | number
    currentStep?: IntFilter<"UserLessonProgress"> | number
    completed?: BoolFilter<"UserLessonProgress"> | boolean
    startedAt?: DateTimeFilter<"UserLessonProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserLessonProgress"> | Date | string
  }

  export type CourseLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseLikeWhereUniqueInput
    update: XOR<CourseLikeUpdateWithoutUserInput, CourseLikeUncheckedUpdateWithoutUserInput>
    create: XOR<CourseLikeCreateWithoutUserInput, CourseLikeUncheckedCreateWithoutUserInput>
  }

  export type CourseLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseLikeWhereUniqueInput
    data: XOR<CourseLikeUpdateWithoutUserInput, CourseLikeUncheckedUpdateWithoutUserInput>
  }

  export type CourseLikeUpdateManyWithWhereWithoutUserInput = {
    where: CourseLikeScalarWhereInput
    data: XOR<CourseLikeUpdateManyMutationInput, CourseLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseLikeScalarWhereInput = {
    AND?: CourseLikeScalarWhereInput | CourseLikeScalarWhereInput[]
    OR?: CourseLikeScalarWhereInput[]
    NOT?: CourseLikeScalarWhereInput | CourseLikeScalarWhereInput[]
    id?: IntFilter<"CourseLike"> | number
    userId?: IntFilter<"CourseLike"> | number
    courseId?: IntFilter<"CourseLike"> | number
    createdAt?: DateTimeFilter<"CourseLike"> | Date | string
  }

  export type CompletedChallengesUpsertWithWhereUniqueWithoutUserInput = {
    where: CompletedChallengesWhereUniqueInput
    update: XOR<CompletedChallengesUpdateWithoutUserInput, CompletedChallengesUncheckedUpdateWithoutUserInput>
    create: XOR<CompletedChallengesCreateWithoutUserInput, CompletedChallengesUncheckedCreateWithoutUserInput>
  }

  export type CompletedChallengesUpdateWithWhereUniqueWithoutUserInput = {
    where: CompletedChallengesWhereUniqueInput
    data: XOR<CompletedChallengesUpdateWithoutUserInput, CompletedChallengesUncheckedUpdateWithoutUserInput>
  }

  export type CompletedChallengesUpdateManyWithWhereWithoutUserInput = {
    where: CompletedChallengesScalarWhereInput
    data: XOR<CompletedChallengesUpdateManyMutationInput, CompletedChallengesUncheckedUpdateManyWithoutUserInput>
  }

  export type CompletedChallengesScalarWhereInput = {
    AND?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
    OR?: CompletedChallengesScalarWhereInput[]
    NOT?: CompletedChallengesScalarWhereInput | CompletedChallengesScalarWhereInput[]
    id?: IntFilter<"CompletedChallenges"> | number
    userId?: IntFilter<"CompletedChallenges"> | number
    challengeId?: IntFilter<"CompletedChallenges"> | number
    createdAt?: DateTimeFilter<"CompletedChallenges"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    senderId?: IntFilter<"Message"> | number
    receiverId?: IntFilter<"Message"> | number
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    read?: BoolFilter<"Message"> | boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type UserCreateWithoutImageInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutImageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutImageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
  }

  export type UserUpsertWithoutImageInput = {
    update: XOR<UserUpdateWithoutImageInput, UserUncheckedUpdateWithoutImageInput>
    create: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImageInput, UserUncheckedUpdateWithoutImageInput>
  }

  export type UserUpdateWithoutImageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutCreatedCoursesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutCreatedCoursesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutCreatedCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
  }

  export type CourseModuleCreateWithoutCourseInput = {
    title: string
    number: number
    miniModules?: MiniModuleCreateNestedManyWithoutCourseModuleInput
    progress?: userModuleProgressCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    number: number
    miniModules?: MiniModuleUncheckedCreateNestedManyWithoutCourseModuleInput
    progress?: userModuleProgressUncheckedCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleCreateManyCourseInputEnvelope = {
    data: CourseModuleCreateManyCourseInput | CourseModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseProgressCreateWithoutCourseInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
    user: UserCreateNestedOneWithoutProgressInput
  }

  export type UserCourseProgressUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
  }

  export type UserCourseProgressCreateOrConnectWithoutCourseInput = {
    where: UserCourseProgressWhereUniqueInput
    create: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseProgressCreateManyCourseInputEnvelope = {
    data: UserCourseProgressCreateManyCourseInput | UserCourseProgressCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseRatingCreateWithoutCourseInput = {
    rating: number
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRatingsInput
  }

  export type CourseRatingUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type CourseRatingCreateOrConnectWithoutCourseInput = {
    where: CourseRatingWhereUniqueInput
    create: XOR<CourseRatingCreateWithoutCourseInput, CourseRatingUncheckedCreateWithoutCourseInput>
  }

  export type CourseRatingCreateManyCourseInputEnvelope = {
    data: CourseRatingCreateManyCourseInput | CourseRatingCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type VideoCreateWithoutCourseInput = {
    title: string
    number: number
    url: string
  }

  export type VideoUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    number: number
    url: string
  }

  export type VideoCreateOrConnectWithoutCourseInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutCourseInput, VideoUncheckedCreateWithoutCourseInput>
  }

  export type VideoCreateManyCourseInputEnvelope = {
    data: VideoCreateManyCourseInput | VideoCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCourseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutCourseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutCourseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
  }

  export type UserCreateManyCourseInputEnvelope = {
    data: UserCreateManyCourseInput | UserCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseLikeCreateWithoutCourseInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCourseLikesInput
  }

  export type CourseLikeUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type CourseLikeCreateOrConnectWithoutCourseInput = {
    where: CourseLikeWhereUniqueInput
    create: XOR<CourseLikeCreateWithoutCourseInput, CourseLikeUncheckedCreateWithoutCourseInput>
  }

  export type CourseLikeCreateManyCourseInputEnvelope = {
    data: CourseLikeCreateManyCourseInput | CourseLikeCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CompletedChallengesCreateWithoutCourseInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompletedChallengesInput
    challenge: ChallengeCreateNestedOneWithoutCompletionsInput
  }

  export type CompletedChallengesUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    challengeId: number
    createdAt?: Date | string
  }

  export type CompletedChallengesCreateOrConnectWithoutCourseInput = {
    where: CompletedChallengesWhereUniqueInput
    create: XOR<CompletedChallengesCreateWithoutCourseInput, CompletedChallengesUncheckedCreateWithoutCourseInput>
  }

  export type UserUpsertWithoutCreatedCoursesInput = {
    update: XOR<UserUpdateWithoutCreatedCoursesInput, UserUncheckedUpdateWithoutCreatedCoursesInput>
    create: XOR<UserCreateWithoutCreatedCoursesInput, UserUncheckedCreateWithoutCreatedCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCoursesInput, UserUncheckedUpdateWithoutCreatedCoursesInput>
  }

  export type UserUpdateWithoutCreatedCoursesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CourseModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    update: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseModuleCreateWithoutCourseInput, CourseModuleUncheckedCreateWithoutCourseInput>
  }

  export type CourseModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseModuleWhereUniqueInput
    data: XOR<CourseModuleUpdateWithoutCourseInput, CourseModuleUncheckedUpdateWithoutCourseInput>
  }

  export type CourseModuleUpdateManyWithWhereWithoutCourseInput = {
    where: CourseModuleScalarWhereInput
    data: XOR<CourseModuleUpdateManyMutationInput, CourseModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseModuleScalarWhereInput = {
    AND?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    OR?: CourseModuleScalarWhereInput[]
    NOT?: CourseModuleScalarWhereInput | CourseModuleScalarWhereInput[]
    id?: IntFilter<"CourseModule"> | number
    courseId?: IntFilter<"CourseModule"> | number
    title?: StringFilter<"CourseModule"> | string
    number?: IntFilter<"CourseModule"> | number
  }

  export type UserCourseProgressUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserCourseProgressWhereUniqueInput
    update: XOR<UserCourseProgressUpdateWithoutCourseInput, UserCourseProgressUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCourseProgressCreateWithoutCourseInput, UserCourseProgressUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseProgressUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserCourseProgressWhereUniqueInput
    data: XOR<UserCourseProgressUpdateWithoutCourseInput, UserCourseProgressUncheckedUpdateWithoutCourseInput>
  }

  export type UserCourseProgressUpdateManyWithWhereWithoutCourseInput = {
    where: UserCourseProgressScalarWhereInput
    data: XOR<UserCourseProgressUpdateManyMutationInput, UserCourseProgressUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseRatingUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseRatingWhereUniqueInput
    update: XOR<CourseRatingUpdateWithoutCourseInput, CourseRatingUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseRatingCreateWithoutCourseInput, CourseRatingUncheckedCreateWithoutCourseInput>
  }

  export type CourseRatingUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseRatingWhereUniqueInput
    data: XOR<CourseRatingUpdateWithoutCourseInput, CourseRatingUncheckedUpdateWithoutCourseInput>
  }

  export type CourseRatingUpdateManyWithWhereWithoutCourseInput = {
    where: CourseRatingScalarWhereInput
    data: XOR<CourseRatingUpdateManyMutationInput, CourseRatingUncheckedUpdateManyWithoutCourseInput>
  }

  export type VideoUpsertWithWhereUniqueWithoutCourseInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutCourseInput, VideoUncheckedUpdateWithoutCourseInput>
    create: XOR<VideoCreateWithoutCourseInput, VideoUncheckedCreateWithoutCourseInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutCourseInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutCourseInput, VideoUncheckedUpdateWithoutCourseInput>
  }

  export type VideoUpdateManyWithWhereWithoutCourseInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutCourseInput>
  }

  export type VideoScalarWhereInput = {
    AND?: VideoScalarWhereInput | VideoScalarWhereInput[]
    OR?: VideoScalarWhereInput[]
    NOT?: VideoScalarWhereInput | VideoScalarWhereInput[]
    id?: IntFilter<"Video"> | number
    courseId?: IntFilter<"Video"> | number
    title?: StringFilter<"Video"> | string
    number?: IntFilter<"Video"> | number
    url?: StringFilter<"Video"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCourseInput, UserUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCourseInput, UserUncheckedUpdateWithoutCourseInput>
  }

  export type UserUpdateManyWithWhereWithoutCourseInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCourseInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    email?: StringFilter<"User"> | string
    hash?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isPremium?: BoolFilter<"User"> | boolean
    provider?: StringFilter<"User"> | string
    photo?: StringNullableFilter<"User"> | string | null
    courseId?: IntNullableFilter<"User"> | number | null
  }

  export type CourseLikeUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseLikeWhereUniqueInput
    update: XOR<CourseLikeUpdateWithoutCourseInput, CourseLikeUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseLikeCreateWithoutCourseInput, CourseLikeUncheckedCreateWithoutCourseInput>
  }

  export type CourseLikeUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseLikeWhereUniqueInput
    data: XOR<CourseLikeUpdateWithoutCourseInput, CourseLikeUncheckedUpdateWithoutCourseInput>
  }

  export type CourseLikeUpdateManyWithWhereWithoutCourseInput = {
    where: CourseLikeScalarWhereInput
    data: XOR<CourseLikeUpdateManyMutationInput, CourseLikeUncheckedUpdateManyWithoutCourseInput>
  }

  export type CompletedChallengesUpsertWithWhereUniqueWithoutCourseInput = {
    where: CompletedChallengesWhereUniqueInput
    update: XOR<CompletedChallengesUpdateWithoutCourseInput, CompletedChallengesUncheckedUpdateWithoutCourseInput>
    create: XOR<CompletedChallengesCreateWithoutCourseInput, CompletedChallengesUncheckedCreateWithoutCourseInput>
  }

  export type CompletedChallengesUpdateWithWhereUniqueWithoutCourseInput = {
    where: CompletedChallengesWhereUniqueInput
    data: XOR<CompletedChallengesUpdateWithoutCourseInput, CompletedChallengesUncheckedUpdateWithoutCourseInput>
  }

  export type CompletedChallengesUpdateManyWithWhereWithoutCourseInput = {
    where: CompletedChallengesScalarWhereInput
    data: XOR<CompletedChallengesUpdateManyMutationInput, CompletedChallengesUncheckedUpdateManyWithoutCourseInput>
  }

  export type UserCreateWithoutCourseLikesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutCourseLikesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutCourseLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseLikesInput, UserUncheckedCreateWithoutCourseLikesInput>
  }

  export type CourseCreateWithoutLikedByInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLikedByInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLikedByInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
  }

  export type UserUpsertWithoutCourseLikesInput = {
    update: XOR<UserUpdateWithoutCourseLikesInput, UserUncheckedUpdateWithoutCourseLikesInput>
    create: XOR<UserCreateWithoutCourseLikesInput, UserUncheckedCreateWithoutCourseLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseLikesInput, UserUncheckedUpdateWithoutCourseLikesInput>
  }

  export type UserUpdateWithoutCourseLikesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CourseUpsertWithoutLikedByInput = {
    update: XOR<CourseUpdateWithoutLikedByInput, CourseUncheckedUpdateWithoutLikedByInput>
    create: XOR<CourseCreateWithoutLikedByInput, CourseUncheckedCreateWithoutLikedByInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLikedByInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLikedByInput, CourseUncheckedUpdateWithoutLikedByInput>
  }

  export type CourseUpdateWithoutLikedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLikedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutProgressInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutProgressInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
  }

  export type CourseCreateWithoutProgressInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutProgressInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutProgressInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutProgressInput = {
    update: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
  }

  export type UserUpdateWithoutProgressInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CourseUpsertWithoutProgressInput = {
    update: XOR<CourseUpdateWithoutProgressInput, CourseUncheckedUpdateWithoutProgressInput>
    create: XOR<CourseCreateWithoutProgressInput, CourseUncheckedCreateWithoutProgressInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutProgressInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutProgressInput, CourseUncheckedUpdateWithoutProgressInput>
  }

  export type CourseUpdateWithoutProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutModulesInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type MiniModuleCreateWithoutCourseModuleInput = {
    title: string
    number: number
    lessons?: LessonCreateNestedManyWithoutMiniModuleInput
    lessonVideos?: LessonVideoCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleUncheckedCreateWithoutCourseModuleInput = {
    id?: number
    title: string
    number: number
    lessons?: LessonUncheckedCreateNestedManyWithoutMiniModuleInput
    lessonVideos?: LessonVideoUncheckedCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressUncheckedCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleCreateOrConnectWithoutCourseModuleInput = {
    where: MiniModuleWhereUniqueInput
    create: XOR<MiniModuleCreateWithoutCourseModuleInput, MiniModuleUncheckedCreateWithoutCourseModuleInput>
  }

  export type MiniModuleCreateManyCourseModuleInputEnvelope = {
    data: MiniModuleCreateManyCourseModuleInput | MiniModuleCreateManyCourseModuleInput[]
    skipDuplicates?: boolean
  }

  export type userModuleProgressCreateWithoutCourseModuleInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
    user: UserCreateNestedOneWithoutUserModuleProgressInput
  }

  export type userModuleProgressUncheckedCreateWithoutCourseModuleInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
  }

  export type userModuleProgressCreateOrConnectWithoutCourseModuleInput = {
    where: userModuleProgressWhereUniqueInput
    create: XOR<userModuleProgressCreateWithoutCourseModuleInput, userModuleProgressUncheckedCreateWithoutCourseModuleInput>
  }

  export type userModuleProgressCreateManyCourseModuleInputEnvelope = {
    data: userModuleProgressCreateManyCourseModuleInput | userModuleProgressCreateManyCourseModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type MiniModuleUpsertWithWhereUniqueWithoutCourseModuleInput = {
    where: MiniModuleWhereUniqueInput
    update: XOR<MiniModuleUpdateWithoutCourseModuleInput, MiniModuleUncheckedUpdateWithoutCourseModuleInput>
    create: XOR<MiniModuleCreateWithoutCourseModuleInput, MiniModuleUncheckedCreateWithoutCourseModuleInput>
  }

  export type MiniModuleUpdateWithWhereUniqueWithoutCourseModuleInput = {
    where: MiniModuleWhereUniqueInput
    data: XOR<MiniModuleUpdateWithoutCourseModuleInput, MiniModuleUncheckedUpdateWithoutCourseModuleInput>
  }

  export type MiniModuleUpdateManyWithWhereWithoutCourseModuleInput = {
    where: MiniModuleScalarWhereInput
    data: XOR<MiniModuleUpdateManyMutationInput, MiniModuleUncheckedUpdateManyWithoutCourseModuleInput>
  }

  export type MiniModuleScalarWhereInput = {
    AND?: MiniModuleScalarWhereInput | MiniModuleScalarWhereInput[]
    OR?: MiniModuleScalarWhereInput[]
    NOT?: MiniModuleScalarWhereInput | MiniModuleScalarWhereInput[]
    id?: IntFilter<"MiniModule"> | number
    courseModuleId?: IntFilter<"MiniModule"> | number
    title?: StringFilter<"MiniModule"> | string
    number?: IntFilter<"MiniModule"> | number
  }

  export type userModuleProgressUpsertWithWhereUniqueWithoutCourseModuleInput = {
    where: userModuleProgressWhereUniqueInput
    update: XOR<userModuleProgressUpdateWithoutCourseModuleInput, userModuleProgressUncheckedUpdateWithoutCourseModuleInput>
    create: XOR<userModuleProgressCreateWithoutCourseModuleInput, userModuleProgressUncheckedCreateWithoutCourseModuleInput>
  }

  export type userModuleProgressUpdateWithWhereUniqueWithoutCourseModuleInput = {
    where: userModuleProgressWhereUniqueInput
    data: XOR<userModuleProgressUpdateWithoutCourseModuleInput, userModuleProgressUncheckedUpdateWithoutCourseModuleInput>
  }

  export type userModuleProgressUpdateManyWithWhereWithoutCourseModuleInput = {
    where: userModuleProgressScalarWhereInput
    data: XOR<userModuleProgressUpdateManyMutationInput, userModuleProgressUncheckedUpdateManyWithoutCourseModuleInput>
  }

  export type UserCreateWithoutUserModuleProgressInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutUserModuleProgressInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutUserModuleProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserModuleProgressInput, UserUncheckedCreateWithoutUserModuleProgressInput>
  }

  export type CourseModuleCreateWithoutProgressInput = {
    title: string
    number: number
    course: CourseCreateNestedOneWithoutModulesInput
    miniModules?: MiniModuleCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutProgressInput = {
    id?: number
    courseId: number
    title: string
    number: number
    miniModules?: MiniModuleUncheckedCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutProgressInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutProgressInput, CourseModuleUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutUserModuleProgressInput = {
    update: XOR<UserUpdateWithoutUserModuleProgressInput, UserUncheckedUpdateWithoutUserModuleProgressInput>
    create: XOR<UserCreateWithoutUserModuleProgressInput, UserUncheckedCreateWithoutUserModuleProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserModuleProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserModuleProgressInput, UserUncheckedUpdateWithoutUserModuleProgressInput>
  }

  export type UserUpdateWithoutUserModuleProgressInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutUserModuleProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CourseModuleUpsertWithoutProgressInput = {
    update: XOR<CourseModuleUpdateWithoutProgressInput, CourseModuleUncheckedUpdateWithoutProgressInput>
    create: XOR<CourseModuleCreateWithoutProgressInput, CourseModuleUncheckedCreateWithoutProgressInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutProgressInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutProgressInput, CourseModuleUncheckedUpdateWithoutProgressInput>
  }

  export type CourseModuleUpdateWithoutProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    miniModules?: MiniModuleUpdateManyWithoutCourseModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModules?: MiniModuleUncheckedUpdateManyWithoutCourseModuleNestedInput
  }

  export type CourseCreateWithoutVideosInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutVideosInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutVideosInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutVideosInput, CourseUncheckedCreateWithoutVideosInput>
  }

  export type CourseUpsertWithoutVideosInput = {
    update: XOR<CourseUpdateWithoutVideosInput, CourseUncheckedUpdateWithoutVideosInput>
    create: XOR<CourseCreateWithoutVideosInput, CourseUncheckedCreateWithoutVideosInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutVideosInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutVideosInput, CourseUncheckedUpdateWithoutVideosInput>
  }

  export type CourseUpdateWithoutVideosInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseModuleCreateWithoutMiniModulesInput = {
    title: string
    number: number
    course: CourseCreateNestedOneWithoutModulesInput
    progress?: userModuleProgressCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleUncheckedCreateWithoutMiniModulesInput = {
    id?: number
    courseId: number
    title: string
    number: number
    progress?: userModuleProgressUncheckedCreateNestedManyWithoutCourseModuleInput
  }

  export type CourseModuleCreateOrConnectWithoutMiniModulesInput = {
    where: CourseModuleWhereUniqueInput
    create: XOR<CourseModuleCreateWithoutMiniModulesInput, CourseModuleUncheckedCreateWithoutMiniModulesInput>
  }

  export type LessonCreateWithoutMiniModuleInput = {
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    solutions?: LessonSolutionCreateNestedManyWithoutLessonInput
    progress?: UserLessonProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutMiniModuleInput = {
    id?: number
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    solutions?: LessonSolutionUncheckedCreateNestedManyWithoutLessonInput
    progress?: UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutMiniModuleInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutMiniModuleInput, LessonUncheckedCreateWithoutMiniModuleInput>
  }

  export type LessonCreateManyMiniModuleInputEnvelope = {
    data: LessonCreateManyMiniModuleInput | LessonCreateManyMiniModuleInput[]
    skipDuplicates?: boolean
  }

  export type LessonVideoCreateWithoutMiniModuleInput = {
    title: string
    number: number
    url: string
  }

  export type LessonVideoUncheckedCreateWithoutMiniModuleInput = {
    id?: number
    title: string
    number: number
    url: string
  }

  export type LessonVideoCreateOrConnectWithoutMiniModuleInput = {
    where: LessonVideoWhereUniqueInput
    create: XOR<LessonVideoCreateWithoutMiniModuleInput, LessonVideoUncheckedCreateWithoutMiniModuleInput>
  }

  export type LessonVideoCreateManyMiniModuleInputEnvelope = {
    data: LessonVideoCreateManyMiniModuleInput | LessonVideoCreateManyMiniModuleInput[]
    skipDuplicates?: boolean
  }

  export type MiniModuleProgressCreateWithoutMiniModuleInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMiniModuleProgressInput
  }

  export type MiniModuleProgressUncheckedCreateWithoutMiniModuleInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type MiniModuleProgressCreateOrConnectWithoutMiniModuleInput = {
    where: MiniModuleProgressWhereUniqueInput
    create: XOR<MiniModuleProgressCreateWithoutMiniModuleInput, MiniModuleProgressUncheckedCreateWithoutMiniModuleInput>
  }

  export type MiniModuleProgressCreateManyMiniModuleInputEnvelope = {
    data: MiniModuleProgressCreateManyMiniModuleInput | MiniModuleProgressCreateManyMiniModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseModuleUpsertWithoutMiniModulesInput = {
    update: XOR<CourseModuleUpdateWithoutMiniModulesInput, CourseModuleUncheckedUpdateWithoutMiniModulesInput>
    create: XOR<CourseModuleCreateWithoutMiniModulesInput, CourseModuleUncheckedCreateWithoutMiniModulesInput>
    where?: CourseModuleWhereInput
  }

  export type CourseModuleUpdateToOneWithWhereWithoutMiniModulesInput = {
    where?: CourseModuleWhereInput
    data: XOR<CourseModuleUpdateWithoutMiniModulesInput, CourseModuleUncheckedUpdateWithoutMiniModulesInput>
  }

  export type CourseModuleUpdateWithoutMiniModulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    progress?: userModuleProgressUpdateManyWithoutCourseModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutMiniModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    progress?: userModuleProgressUncheckedUpdateManyWithoutCourseModuleNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutMiniModuleInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutMiniModuleInput, LessonUncheckedUpdateWithoutMiniModuleInput>
    create: XOR<LessonCreateWithoutMiniModuleInput, LessonUncheckedCreateWithoutMiniModuleInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutMiniModuleInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutMiniModuleInput, LessonUncheckedUpdateWithoutMiniModuleInput>
  }

  export type LessonUpdateManyWithWhereWithoutMiniModuleInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutMiniModuleInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: IntFilter<"Lesson"> | number
    title?: StringFilter<"Lesson"> | string
    explanation?: StringFilter<"Lesson"> | string
    more?: StringNullableFilter<"Lesson"> | string | null
    example?: StringNullableFilter<"Lesson"> | string | null
    note?: StringNullableFilter<"Lesson"> | string | null
    assignment?: StringFilter<"Lesson"> | string
    number?: IntFilter<"Lesson"> | number
    miniModuleId?: IntFilter<"Lesson"> | number
  }

  export type LessonVideoUpsertWithWhereUniqueWithoutMiniModuleInput = {
    where: LessonVideoWhereUniqueInput
    update: XOR<LessonVideoUpdateWithoutMiniModuleInput, LessonVideoUncheckedUpdateWithoutMiniModuleInput>
    create: XOR<LessonVideoCreateWithoutMiniModuleInput, LessonVideoUncheckedCreateWithoutMiniModuleInput>
  }

  export type LessonVideoUpdateWithWhereUniqueWithoutMiniModuleInput = {
    where: LessonVideoWhereUniqueInput
    data: XOR<LessonVideoUpdateWithoutMiniModuleInput, LessonVideoUncheckedUpdateWithoutMiniModuleInput>
  }

  export type LessonVideoUpdateManyWithWhereWithoutMiniModuleInput = {
    where: LessonVideoScalarWhereInput
    data: XOR<LessonVideoUpdateManyMutationInput, LessonVideoUncheckedUpdateManyWithoutMiniModuleInput>
  }

  export type LessonVideoScalarWhereInput = {
    AND?: LessonVideoScalarWhereInput | LessonVideoScalarWhereInput[]
    OR?: LessonVideoScalarWhereInput[]
    NOT?: LessonVideoScalarWhereInput | LessonVideoScalarWhereInput[]
    id?: IntFilter<"LessonVideo"> | number
    title?: StringFilter<"LessonVideo"> | string
    number?: IntFilter<"LessonVideo"> | number
    url?: StringFilter<"LessonVideo"> | string
    miniModuleId?: IntFilter<"LessonVideo"> | number
  }

  export type MiniModuleProgressUpsertWithWhereUniqueWithoutMiniModuleInput = {
    where: MiniModuleProgressWhereUniqueInput
    update: XOR<MiniModuleProgressUpdateWithoutMiniModuleInput, MiniModuleProgressUncheckedUpdateWithoutMiniModuleInput>
    create: XOR<MiniModuleProgressCreateWithoutMiniModuleInput, MiniModuleProgressUncheckedCreateWithoutMiniModuleInput>
  }

  export type MiniModuleProgressUpdateWithWhereUniqueWithoutMiniModuleInput = {
    where: MiniModuleProgressWhereUniqueInput
    data: XOR<MiniModuleProgressUpdateWithoutMiniModuleInput, MiniModuleProgressUncheckedUpdateWithoutMiniModuleInput>
  }

  export type MiniModuleProgressUpdateManyWithWhereWithoutMiniModuleInput = {
    where: MiniModuleProgressScalarWhereInput
    data: XOR<MiniModuleProgressUpdateManyMutationInput, MiniModuleProgressUncheckedUpdateManyWithoutMiniModuleInput>
  }

  export type UserCreateWithoutMiniModuleProgressInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutMiniModuleProgressInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutMiniModuleProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMiniModuleProgressInput, UserUncheckedCreateWithoutMiniModuleProgressInput>
  }

  export type MiniModuleCreateWithoutProgressInput = {
    title: string
    number: number
    courseModule: CourseModuleCreateNestedOneWithoutMiniModulesInput
    lessons?: LessonCreateNestedManyWithoutMiniModuleInput
    lessonVideos?: LessonVideoCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleUncheckedCreateWithoutProgressInput = {
    id?: number
    courseModuleId: number
    title: string
    number: number
    lessons?: LessonUncheckedCreateNestedManyWithoutMiniModuleInput
    lessonVideos?: LessonVideoUncheckedCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleCreateOrConnectWithoutProgressInput = {
    where: MiniModuleWhereUniqueInput
    create: XOR<MiniModuleCreateWithoutProgressInput, MiniModuleUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutMiniModuleProgressInput = {
    update: XOR<UserUpdateWithoutMiniModuleProgressInput, UserUncheckedUpdateWithoutMiniModuleProgressInput>
    create: XOR<UserCreateWithoutMiniModuleProgressInput, UserUncheckedCreateWithoutMiniModuleProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMiniModuleProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMiniModuleProgressInput, UserUncheckedUpdateWithoutMiniModuleProgressInput>
  }

  export type UserUpdateWithoutMiniModuleProgressInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutMiniModuleProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MiniModuleUpsertWithoutProgressInput = {
    update: XOR<MiniModuleUpdateWithoutProgressInput, MiniModuleUncheckedUpdateWithoutProgressInput>
    create: XOR<MiniModuleCreateWithoutProgressInput, MiniModuleUncheckedCreateWithoutProgressInput>
    where?: MiniModuleWhereInput
  }

  export type MiniModuleUpdateToOneWithWhereWithoutProgressInput = {
    where?: MiniModuleWhereInput
    data: XOR<MiniModuleUpdateWithoutProgressInput, MiniModuleUncheckedUpdateWithoutProgressInput>
  }

  export type MiniModuleUpdateWithoutProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    courseModule?: CourseModuleUpdateOneRequiredWithoutMiniModulesNestedInput
    lessons?: LessonUpdateManyWithoutMiniModuleNestedInput
    lessonVideos?: LessonVideoUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleUncheckedUpdateWithoutProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUncheckedUpdateManyWithoutMiniModuleNestedInput
    lessonVideos?: LessonVideoUncheckedUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleCreateWithoutLessonsInput = {
    title: string
    number: number
    courseModule: CourseModuleCreateNestedOneWithoutMiniModulesInput
    lessonVideos?: LessonVideoCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleUncheckedCreateWithoutLessonsInput = {
    id?: number
    courseModuleId: number
    title: string
    number: number
    lessonVideos?: LessonVideoUncheckedCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressUncheckedCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleCreateOrConnectWithoutLessonsInput = {
    where: MiniModuleWhereUniqueInput
    create: XOR<MiniModuleCreateWithoutLessonsInput, MiniModuleUncheckedCreateWithoutLessonsInput>
  }

  export type LessonSolutionCreateWithoutLessonInput = {
    solution: string
  }

  export type LessonSolutionUncheckedCreateWithoutLessonInput = {
    id?: number
    solution: string
  }

  export type LessonSolutionCreateOrConnectWithoutLessonInput = {
    where: LessonSolutionWhereUniqueInput
    create: XOR<LessonSolutionCreateWithoutLessonInput, LessonSolutionUncheckedCreateWithoutLessonInput>
  }

  export type LessonSolutionCreateManyLessonInputEnvelope = {
    data: LessonSolutionCreateManyLessonInput | LessonSolutionCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type UserLessonProgressCreateWithoutLessonInput = {
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserLessonProgressInput
  }

  export type UserLessonProgressUncheckedCreateWithoutLessonInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonProgressCreateOrConnectWithoutLessonInput = {
    where: UserLessonProgressWhereUniqueInput
    create: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type UserLessonProgressCreateManyLessonInputEnvelope = {
    data: UserLessonProgressCreateManyLessonInput | UserLessonProgressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type MiniModuleUpsertWithoutLessonsInput = {
    update: XOR<MiniModuleUpdateWithoutLessonsInput, MiniModuleUncheckedUpdateWithoutLessonsInput>
    create: XOR<MiniModuleCreateWithoutLessonsInput, MiniModuleUncheckedCreateWithoutLessonsInput>
    where?: MiniModuleWhereInput
  }

  export type MiniModuleUpdateToOneWithWhereWithoutLessonsInput = {
    where?: MiniModuleWhereInput
    data: XOR<MiniModuleUpdateWithoutLessonsInput, MiniModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type MiniModuleUpdateWithoutLessonsInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    courseModule?: CourseModuleUpdateOneRequiredWithoutMiniModulesNestedInput
    lessonVideos?: LessonVideoUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    lessonVideos?: LessonVideoUncheckedUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUncheckedUpdateManyWithoutMiniModuleNestedInput
  }

  export type LessonSolutionUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonSolutionWhereUniqueInput
    update: XOR<LessonSolutionUpdateWithoutLessonInput, LessonSolutionUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonSolutionCreateWithoutLessonInput, LessonSolutionUncheckedCreateWithoutLessonInput>
  }

  export type LessonSolutionUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonSolutionWhereUniqueInput
    data: XOR<LessonSolutionUpdateWithoutLessonInput, LessonSolutionUncheckedUpdateWithoutLessonInput>
  }

  export type LessonSolutionUpdateManyWithWhereWithoutLessonInput = {
    where: LessonSolutionScalarWhereInput
    data: XOR<LessonSolutionUpdateManyMutationInput, LessonSolutionUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonSolutionScalarWhereInput = {
    AND?: LessonSolutionScalarWhereInput | LessonSolutionScalarWhereInput[]
    OR?: LessonSolutionScalarWhereInput[]
    NOT?: LessonSolutionScalarWhereInput | LessonSolutionScalarWhereInput[]
    id?: IntFilter<"LessonSolution"> | number
    solution?: StringFilter<"LessonSolution"> | string
    lessonId?: IntFilter<"LessonSolution"> | number
  }

  export type UserLessonProgressUpsertWithWhereUniqueWithoutLessonInput = {
    where: UserLessonProgressWhereUniqueInput
    update: XOR<UserLessonProgressUpdateWithoutLessonInput, UserLessonProgressUncheckedUpdateWithoutLessonInput>
    create: XOR<UserLessonProgressCreateWithoutLessonInput, UserLessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type UserLessonProgressUpdateWithWhereUniqueWithoutLessonInput = {
    where: UserLessonProgressWhereUniqueInput
    data: XOR<UserLessonProgressUpdateWithoutLessonInput, UserLessonProgressUncheckedUpdateWithoutLessonInput>
  }

  export type UserLessonProgressUpdateManyWithWhereWithoutLessonInput = {
    where: UserLessonProgressScalarWhereInput
    data: XOR<UserLessonProgressUpdateManyMutationInput, UserLessonProgressUncheckedUpdateManyWithoutLessonInput>
  }

  export type MiniModuleCreateWithoutLessonVideosInput = {
    title: string
    number: number
    courseModule: CourseModuleCreateNestedOneWithoutMiniModulesInput
    lessons?: LessonCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleUncheckedCreateWithoutLessonVideosInput = {
    id?: number
    courseModuleId: number
    title: string
    number: number
    lessons?: LessonUncheckedCreateNestedManyWithoutMiniModuleInput
    progress?: MiniModuleProgressUncheckedCreateNestedManyWithoutMiniModuleInput
  }

  export type MiniModuleCreateOrConnectWithoutLessonVideosInput = {
    where: MiniModuleWhereUniqueInput
    create: XOR<MiniModuleCreateWithoutLessonVideosInput, MiniModuleUncheckedCreateWithoutLessonVideosInput>
  }

  export type MiniModuleUpsertWithoutLessonVideosInput = {
    update: XOR<MiniModuleUpdateWithoutLessonVideosInput, MiniModuleUncheckedUpdateWithoutLessonVideosInput>
    create: XOR<MiniModuleCreateWithoutLessonVideosInput, MiniModuleUncheckedCreateWithoutLessonVideosInput>
    where?: MiniModuleWhereInput
  }

  export type MiniModuleUpdateToOneWithWhereWithoutLessonVideosInput = {
    where?: MiniModuleWhereInput
    data: XOR<MiniModuleUpdateWithoutLessonVideosInput, MiniModuleUncheckedUpdateWithoutLessonVideosInput>
  }

  export type MiniModuleUpdateWithoutLessonVideosInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    courseModule?: CourseModuleUpdateOneRequiredWithoutMiniModulesNestedInput
    lessons?: LessonUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleUncheckedUpdateWithoutLessonVideosInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUncheckedUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUncheckedUpdateManyWithoutMiniModuleNestedInput
  }

  export type LessonCreateWithoutSolutionsInput = {
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    miniModule: MiniModuleCreateNestedOneWithoutLessonsInput
    progress?: UserLessonProgressCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutSolutionsInput = {
    id?: number
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    miniModuleId: number
    progress?: UserLessonProgressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutSolutionsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutSolutionsInput, LessonUncheckedCreateWithoutSolutionsInput>
  }

  export type LessonUpsertWithoutSolutionsInput = {
    update: XOR<LessonUpdateWithoutSolutionsInput, LessonUncheckedUpdateWithoutSolutionsInput>
    create: XOR<LessonCreateWithoutSolutionsInput, LessonUncheckedCreateWithoutSolutionsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutSolutionsInput, LessonUncheckedUpdateWithoutSolutionsInput>
  }

  export type LessonUpdateWithoutSolutionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModule?: MiniModuleUpdateOneRequiredWithoutLessonsNestedInput
    progress?: UserLessonProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutSolutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
    progress?: UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutUserLessonProgressInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutUserLessonProgressInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutUserLessonProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
  }

  export type LessonCreateWithoutProgressInput = {
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    miniModule: MiniModuleCreateNestedOneWithoutLessonsInput
    solutions?: LessonSolutionCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutProgressInput = {
    id?: number
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
    miniModuleId: number
    solutions?: LessonSolutionUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutProgressInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutUserLessonProgressInput = {
    update: XOR<UserUpdateWithoutUserLessonProgressInput, UserUncheckedUpdateWithoutUserLessonProgressInput>
    create: XOR<UserCreateWithoutUserLessonProgressInput, UserUncheckedCreateWithoutUserLessonProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserLessonProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserLessonProgressInput, UserUncheckedUpdateWithoutUserLessonProgressInput>
  }

  export type UserUpdateWithoutUserLessonProgressInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutUserLessonProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type LessonUpsertWithoutProgressInput = {
    update: XOR<LessonUpdateWithoutProgressInput, LessonUncheckedUpdateWithoutProgressInput>
    create: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutProgressInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutProgressInput, LessonUncheckedUpdateWithoutProgressInput>
  }

  export type LessonUpdateWithoutProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModule?: MiniModuleUpdateOneRequiredWithoutLessonsNestedInput
    solutions?: LessonSolutionUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
    solutions?: LessonSolutionUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutRatingsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutRatingsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
  }

  export type CourseCreateWithoutRatingsInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutRatingsInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
    completedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutRatingsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutRatingsInput, CourseUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutRatingsInput = {
    update: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateWithoutRatingsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CourseUpsertWithoutRatingsInput = {
    update: XOR<CourseUpdateWithoutRatingsInput, CourseUncheckedUpdateWithoutRatingsInput>
    create: XOR<CourseCreateWithoutRatingsInput, CourseUncheckedCreateWithoutRatingsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutRatingsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutRatingsInput, CourseUncheckedUpdateWithoutRatingsInput>
  }

  export type CourseUpdateWithoutRatingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ChallengeInstructionsCreateWithoutChallengeInput = {
    number: number
    instruction: string
    completed?: boolean
  }

  export type ChallengeInstructionsUncheckedCreateWithoutChallengeInput = {
    id?: number
    number: number
    instruction: string
    completed?: boolean
  }

  export type ChallengeInstructionsCreateOrConnectWithoutChallengeInput = {
    where: ChallengeInstructionsWhereUniqueInput
    create: XOR<ChallengeInstructionsCreateWithoutChallengeInput, ChallengeInstructionsUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeInstructionsCreateManyChallengeInputEnvelope = {
    data: ChallengeInstructionsCreateManyChallengeInput | ChallengeInstructionsCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeLikeCreateWithoutChallengeInput = {
    user: UserCreateNestedOneWithoutChallengeLikeInput
  }

  export type ChallengeLikeUncheckedCreateWithoutChallengeInput = {
    id?: number
    userId: number
  }

  export type ChallengeLikeCreateOrConnectWithoutChallengeInput = {
    where: ChallengeLikeWhereUniqueInput
    create: XOR<ChallengeLikeCreateWithoutChallengeInput, ChallengeLikeUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeLikeCreateManyChallengeInputEnvelope = {
    data: ChallengeLikeCreateManyChallengeInput | ChallengeLikeCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeSolutionsCreateWithoutChallengeInput = {
    number: number
    solution: string
  }

  export type ChallengeSolutionsUncheckedCreateWithoutChallengeInput = {
    id?: number
    number: number
    solution: string
  }

  export type ChallengeSolutionsCreateOrConnectWithoutChallengeInput = {
    where: ChallengeSolutionsWhereUniqueInput
    create: XOR<ChallengeSolutionsCreateWithoutChallengeInput, ChallengeSolutionsUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeSolutionsCreateManyChallengeInputEnvelope = {
    data: ChallengeSolutionsCreateManyChallengeInput | ChallengeSolutionsCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type CompletedChallengesCreateWithoutChallengeInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompletedChallengesInput
    Course?: CourseCreateNestedManyWithoutCompletedChallengesInput
  }

  export type CompletedChallengesUncheckedCreateWithoutChallengeInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    Course?: CourseUncheckedCreateNestedManyWithoutCompletedChallengesInput
  }

  export type CompletedChallengesCreateOrConnectWithoutChallengeInput = {
    where: CompletedChallengesWhereUniqueInput
    create: XOR<CompletedChallengesCreateWithoutChallengeInput, CompletedChallengesUncheckedCreateWithoutChallengeInput>
  }

  export type CompletedChallengesCreateManyChallengeInputEnvelope = {
    data: CompletedChallengesCreateManyChallengeInput | CompletedChallengesCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeInstructionsUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeInstructionsWhereUniqueInput
    update: XOR<ChallengeInstructionsUpdateWithoutChallengeInput, ChallengeInstructionsUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeInstructionsCreateWithoutChallengeInput, ChallengeInstructionsUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeInstructionsUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeInstructionsWhereUniqueInput
    data: XOR<ChallengeInstructionsUpdateWithoutChallengeInput, ChallengeInstructionsUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeInstructionsUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeInstructionsScalarWhereInput
    data: XOR<ChallengeInstructionsUpdateManyMutationInput, ChallengeInstructionsUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeInstructionsScalarWhereInput = {
    AND?: ChallengeInstructionsScalarWhereInput | ChallengeInstructionsScalarWhereInput[]
    OR?: ChallengeInstructionsScalarWhereInput[]
    NOT?: ChallengeInstructionsScalarWhereInput | ChallengeInstructionsScalarWhereInput[]
    id?: IntFilter<"ChallengeInstructions"> | number
    number?: IntFilter<"ChallengeInstructions"> | number
    instruction?: StringFilter<"ChallengeInstructions"> | string
    completed?: BoolFilter<"ChallengeInstructions"> | boolean
    challengeId?: IntFilter<"ChallengeInstructions"> | number
  }

  export type ChallengeLikeUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeLikeWhereUniqueInput
    update: XOR<ChallengeLikeUpdateWithoutChallengeInput, ChallengeLikeUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeLikeCreateWithoutChallengeInput, ChallengeLikeUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeLikeUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeLikeWhereUniqueInput
    data: XOR<ChallengeLikeUpdateWithoutChallengeInput, ChallengeLikeUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeLikeUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeLikeScalarWhereInput
    data: XOR<ChallengeLikeUpdateManyMutationInput, ChallengeLikeUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeSolutionsUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeSolutionsWhereUniqueInput
    update: XOR<ChallengeSolutionsUpdateWithoutChallengeInput, ChallengeSolutionsUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeSolutionsCreateWithoutChallengeInput, ChallengeSolutionsUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeSolutionsUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeSolutionsWhereUniqueInput
    data: XOR<ChallengeSolutionsUpdateWithoutChallengeInput, ChallengeSolutionsUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeSolutionsUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeSolutionsScalarWhereInput
    data: XOR<ChallengeSolutionsUpdateManyMutationInput, ChallengeSolutionsUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeSolutionsScalarWhereInput = {
    AND?: ChallengeSolutionsScalarWhereInput | ChallengeSolutionsScalarWhereInput[]
    OR?: ChallengeSolutionsScalarWhereInput[]
    NOT?: ChallengeSolutionsScalarWhereInput | ChallengeSolutionsScalarWhereInput[]
    id?: IntFilter<"ChallengeSolutions"> | number
    number?: IntFilter<"ChallengeSolutions"> | number
    solution?: StringFilter<"ChallengeSolutions"> | string
    challengeId?: IntFilter<"ChallengeSolutions"> | number
  }

  export type CompletedChallengesUpsertWithWhereUniqueWithoutChallengeInput = {
    where: CompletedChallengesWhereUniqueInput
    update: XOR<CompletedChallengesUpdateWithoutChallengeInput, CompletedChallengesUncheckedUpdateWithoutChallengeInput>
    create: XOR<CompletedChallengesCreateWithoutChallengeInput, CompletedChallengesUncheckedCreateWithoutChallengeInput>
  }

  export type CompletedChallengesUpdateWithWhereUniqueWithoutChallengeInput = {
    where: CompletedChallengesWhereUniqueInput
    data: XOR<CompletedChallengesUpdateWithoutChallengeInput, CompletedChallengesUncheckedUpdateWithoutChallengeInput>
  }

  export type CompletedChallengesUpdateManyWithWhereWithoutChallengeInput = {
    where: CompletedChallengesScalarWhereInput
    data: XOR<CompletedChallengesUpdateManyMutationInput, CompletedChallengesUncheckedUpdateManyWithoutChallengeInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutChallengeLikeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutChallengeLikeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    CompletedChallenges?: CompletedChallengesUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutChallengeLikeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengeLikeInput, UserUncheckedCreateWithoutChallengeLikeInput>
  }

  export type ChallengeCreateWithoutLikesListInput = {
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutLikesListInput = {
    id?: number
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsUncheckedCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsUncheckedCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutLikesListInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutLikesListInput, ChallengeUncheckedCreateWithoutLikesListInput>
  }

  export type UserUpsertWithoutChallengeLikeInput = {
    update: XOR<UserUpdateWithoutChallengeLikeInput, UserUncheckedUpdateWithoutChallengeLikeInput>
    create: XOR<UserCreateWithoutChallengeLikeInput, UserUncheckedCreateWithoutChallengeLikeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengeLikeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengeLikeInput, UserUncheckedUpdateWithoutChallengeLikeInput>
  }

  export type UserUpdateWithoutChallengeLikeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengeLikeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ChallengeUpsertWithoutLikesListInput = {
    update: XOR<ChallengeUpdateWithoutLikesListInput, ChallengeUncheckedUpdateWithoutLikesListInput>
    create: XOR<ChallengeCreateWithoutLikesListInput, ChallengeUncheckedCreateWithoutLikesListInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutLikesListInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutLikesListInput, ChallengeUncheckedUpdateWithoutLikesListInput>
  }

  export type ChallengeUpdateWithoutLikesListInput = {
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutLikesListInput = {
    id?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUncheckedUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUncheckedUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutInstructionsInput = {
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    likesList?: ChallengeLikeCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutInstructionsInput = {
    id?: number
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    likesList?: ChallengeLikeUncheckedCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsUncheckedCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutInstructionsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutInstructionsInput, ChallengeUncheckedCreateWithoutInstructionsInput>
  }

  export type ChallengeUpsertWithoutInstructionsInput = {
    update: XOR<ChallengeUpdateWithoutInstructionsInput, ChallengeUncheckedUpdateWithoutInstructionsInput>
    create: XOR<ChallengeCreateWithoutInstructionsInput, ChallengeUncheckedCreateWithoutInstructionsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutInstructionsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutInstructionsInput, ChallengeUncheckedUpdateWithoutInstructionsInput>
  }

  export type ChallengeUpdateWithoutInstructionsInput = {
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    likesList?: ChallengeLikeUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutInstructionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    likesList?: ChallengeLikeUncheckedUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUncheckedUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutSolutionsInput = {
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsCreateNestedManyWithoutChallengeInput
    likesList?: ChallengeLikeCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutSolutionsInput = {
    id?: number
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsUncheckedCreateNestedManyWithoutChallengeInput
    likesList?: ChallengeLikeUncheckedCreateNestedManyWithoutChallengeInput
    completions?: CompletedChallengesUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutSolutionsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutSolutionsInput, ChallengeUncheckedCreateWithoutSolutionsInput>
  }

  export type ChallengeUpsertWithoutSolutionsInput = {
    update: XOR<ChallengeUpdateWithoutSolutionsInput, ChallengeUncheckedUpdateWithoutSolutionsInput>
    create: XOR<ChallengeCreateWithoutSolutionsInput, ChallengeUncheckedCreateWithoutSolutionsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutSolutionsInput, ChallengeUncheckedUpdateWithoutSolutionsInput>
  }

  export type ChallengeUpdateWithoutSolutionsInput = {
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUpdateManyWithoutChallengeNestedInput
    likesList?: ChallengeLikeUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutSolutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUncheckedUpdateManyWithoutChallengeNestedInput
    likesList?: ChallengeLikeUncheckedUpdateManyWithoutChallengeNestedInput
    completions?: CompletedChallengesUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type UserCreateWithoutCompletedChallengesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    course?: CourseCreateNestedOneWithoutUsersInput
    ratings?: CourseRatingCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeCreateNestedManyWithoutUserInput
    image?: UserProfileImageCreateNestedManyWithoutUserInput
    createdCourses?: CourseCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutCompletedChallengesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
    courseId?: number | null
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutUserInput
    ChallengeLike?: ChallengeLikeUncheckedCreateNestedManyWithoutUserInput
    image?: UserProfileImageUncheckedCreateNestedManyWithoutUserInput
    createdCourses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutUserInput
    userModuleProgress?: userModuleProgressUncheckedCreateNestedManyWithoutUserInput
    MiniModuleProgress?: MiniModuleProgressUncheckedCreateNestedManyWithoutUserInput
    userLessonProgress?: UserLessonProgressUncheckedCreateNestedManyWithoutUserInput
    courseLikes?: CourseLikeUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutCompletedChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompletedChallengesInput, UserUncheckedCreateWithoutCompletedChallengesInput>
  }

  export type ChallengeCreateWithoutCompletionsInput = {
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsCreateNestedManyWithoutChallengeInput
    likesList?: ChallengeLikeCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutCompletionsInput = {
    id?: number
    difficulty: string
    title: string
    description: string
    relation?: string | null
    duration: string
    useEditor?: boolean
    likes?: number
    instructions?: ChallengeInstructionsUncheckedCreateNestedManyWithoutChallengeInput
    likesList?: ChallengeLikeUncheckedCreateNestedManyWithoutChallengeInput
    solutions?: ChallengeSolutionsUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutCompletionsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutCompletionsInput, ChallengeUncheckedCreateWithoutCompletionsInput>
  }

  export type CourseCreateWithoutCompletedChallengesInput = {
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedCoursesInput
    modules?: CourseModuleCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingCreateNestedManyWithoutCourseInput
    videos?: VideoCreateNestedManyWithoutCourseInput
    users?: UserCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCompletedChallengesInput = {
    id?: number
    creatorId: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: CourseModuleUncheckedCreateNestedManyWithoutCourseInput
    progress?: UserCourseProgressUncheckedCreateNestedManyWithoutCourseInput
    ratings?: CourseRatingUncheckedCreateNestedManyWithoutCourseInput
    videos?: VideoUncheckedCreateNestedManyWithoutCourseInput
    users?: UserUncheckedCreateNestedManyWithoutCourseInput
    likedBy?: CourseLikeUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCompletedChallengesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCompletedChallengesInput, CourseUncheckedCreateWithoutCompletedChallengesInput>
  }

  export type UserUpsertWithoutCompletedChallengesInput = {
    update: XOR<UserUpdateWithoutCompletedChallengesInput, UserUncheckedUpdateWithoutCompletedChallengesInput>
    create: XOR<UserCreateWithoutCompletedChallengesInput, UserUncheckedCreateWithoutCompletedChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompletedChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompletedChallengesInput, UserUncheckedUpdateWithoutCompletedChallengesInput>
  }

  export type UserUpdateWithoutCompletedChallengesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneWithoutUsersNestedInput
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutCompletedChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ChallengeUpsertWithoutCompletionsInput = {
    update: XOR<ChallengeUpdateWithoutCompletionsInput, ChallengeUncheckedUpdateWithoutCompletionsInput>
    create: XOR<ChallengeCreateWithoutCompletionsInput, ChallengeUncheckedCreateWithoutCompletionsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutCompletionsInput, ChallengeUncheckedUpdateWithoutCompletionsInput>
  }

  export type ChallengeUpdateWithoutCompletionsInput = {
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUpdateManyWithoutChallengeNestedInput
    likesList?: ChallengeLikeUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutCompletionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    relation?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    useEditor?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    instructions?: ChallengeInstructionsUncheckedUpdateManyWithoutChallengeNestedInput
    likesList?: ChallengeLikeUncheckedUpdateManyWithoutChallengeNestedInput
    solutions?: ChallengeSolutionsUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type CourseUpsertWithWhereUniqueWithoutCompletedChallengesInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCompletedChallengesInput, CourseUncheckedUpdateWithoutCompletedChallengesInput>
    create: XOR<CourseCreateWithoutCompletedChallengesInput, CourseUncheckedCreateWithoutCompletedChallengesInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCompletedChallengesInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCompletedChallengesInput, CourseUncheckedUpdateWithoutCompletedChallengesInput>
  }

  export type CourseUpdateManyWithWhereWithoutCompletedChallengesInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCompletedChallengesInput>
  }

  export type CourseRatingCreateManyUserInput = {
    id?: number
    courseId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ChallengeLikeCreateManyUserInput = {
    id?: number
    challengeId: number
  }

  export type UserProfileImageCreateManyUserInput = {
    id?: number
    path: string
  }

  export type CourseCreateManyCreatorInput = {
    id?: number
    title: string
    category: string
    level: $Enums.Level
    description: string
    duration?: string
    studentsCount?: number
    rating?: number
    likes?: number
    completions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseProgressCreateManyUserInput = {
    id?: number
    courseId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
  }

  export type userModuleProgressCreateManyUserInput = {
    id?: number
    courseModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
  }

  export type MiniModuleProgressCreateManyUserInput = {
    id?: number
    miniModuleId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLessonProgressCreateManyUserInput = {
    id?: number
    lessonId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseLikeCreateManyUserInput = {
    id?: number
    courseId: number
    createdAt?: Date | string
  }

  export type CompletedChallengesCreateManyUserInput = {
    id?: number
    challengeId: number
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: number
    receiverId: number
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
  }

  export type MessageCreateManyReceiverInput = {
    id?: number
    senderId: number
    content: string
    type?: string
    createdAt?: Date | string
    read?: boolean
  }

  export type CourseRatingUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type CourseRatingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseRatingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeLikeUpdateWithoutUserInput = {
    challenge?: ChallengeUpdateOneRequiredWithoutLikesListNestedInput
  }

  export type ChallengeLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeLikeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
  }

  export type UserProfileImageUpdateWithoutUserInput = {
    path?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileImageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileImageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
  }

  export type CourseUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
    completedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseProgressUpdateWithoutUserInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserCourseProgressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userModuleProgressUpdateWithoutUserInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    courseModule?: CourseModuleUpdateOneRequiredWithoutProgressNestedInput
  }

  export type userModuleProgressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userModuleProgressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MiniModuleProgressUpdateWithoutUserInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    miniModule?: MiniModuleUpdateOneRequiredWithoutProgressNestedInput
  }

  export type MiniModuleProgressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MiniModuleProgressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    miniModuleId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonProgressUpdateWithoutUserInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserLessonProgressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLikeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLikedByNestedInput
  }

  export type CourseLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLikeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedChallengesUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutCompletionsNestedInput
    Course?: CourseUpdateManyWithoutCompletedChallengesNestedInput
  }

  export type CompletedChallengesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUncheckedUpdateManyWithoutCompletedChallengesNestedInput
  }

  export type CompletedChallengesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiverId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUpdateWithoutReceiverInput = {
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseModuleCreateManyCourseInput = {
    id?: number
    title: string
    number: number
  }

  export type UserCourseProgressCreateManyCourseInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    rating?: number | null
  }

  export type CourseRatingCreateManyCourseInput = {
    id?: number
    userId: number
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type VideoCreateManyCourseInput = {
    id?: number
    title: string
    number: number
    url: string
  }

  export type UserCreateManyCourseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    hash: string
    username?: string | null
    role: $Enums.Role
    isPremium?: boolean
    provider?: string
    photo?: string | null
  }

  export type CourseLikeCreateManyCourseInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type CourseModuleUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModules?: MiniModuleUpdateManyWithoutCourseModuleNestedInput
    progress?: userModuleProgressUpdateManyWithoutCourseModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    miniModules?: MiniModuleUncheckedUpdateManyWithoutCourseModuleNestedInput
    progress?: userModuleProgressUncheckedUpdateManyWithoutCourseModuleNestedInput
  }

  export type CourseModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type UserCourseProgressUpdateWithoutCourseInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserCourseProgressUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCourseProgressUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseRatingUpdateWithoutCourseInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type CourseRatingUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseRatingUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutCourseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: CourseRatingUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    ratings?: CourseRatingUncheckedUpdateManyWithoutUserNestedInput
    ChallengeLike?: ChallengeLikeUncheckedUpdateManyWithoutUserNestedInput
    image?: UserProfileImageUncheckedUpdateManyWithoutUserNestedInput
    createdCourses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutUserNestedInput
    userModuleProgress?: userModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    MiniModuleProgress?: MiniModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    userLessonProgress?: UserLessonProgressUncheckedUpdateManyWithoutUserNestedInput
    courseLikes?: CourseLikeUncheckedUpdateManyWithoutUserNestedInput
    CompletedChallenges?: CompletedChallengesUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseLikeUpdateWithoutCourseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCourseLikesNestedInput
  }

  export type CourseLikeUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseLikeUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedChallengesUpdateWithoutCourseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompletedChallengesNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type CompletedChallengesUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedChallengesUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    challengeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MiniModuleCreateManyCourseModuleInput = {
    id?: number
    title: string
    number: number
  }

  export type userModuleProgressCreateManyCourseModuleInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
    courseId?: number | null
  }

  export type MiniModuleUpdateWithoutCourseModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUpdateManyWithoutMiniModuleNestedInput
    lessonVideos?: LessonVideoUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleUncheckedUpdateWithoutCourseModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    lessons?: LessonUncheckedUpdateManyWithoutMiniModuleNestedInput
    lessonVideos?: LessonVideoUncheckedUpdateManyWithoutMiniModuleNestedInput
    progress?: MiniModuleProgressUncheckedUpdateManyWithoutMiniModuleNestedInput
  }

  export type MiniModuleUncheckedUpdateManyWithoutCourseModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type userModuleProgressUpdateWithoutCourseModuleInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutUserModuleProgressNestedInput
  }

  export type userModuleProgressUncheckedUpdateWithoutCourseModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userModuleProgressUncheckedUpdateManyWithoutCourseModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LessonCreateManyMiniModuleInput = {
    id?: number
    title: string
    explanation: string
    more?: string | null
    example?: string | null
    note?: string | null
    assignment: string
    number: number
  }

  export type LessonVideoCreateManyMiniModuleInput = {
    id?: number
    title: string
    number: number
    url: string
  }

  export type MiniModuleProgressCreateManyMiniModuleInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateWithoutMiniModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    solutions?: LessonSolutionUpdateManyWithoutLessonNestedInput
    progress?: UserLessonProgressUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutMiniModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    solutions?: LessonSolutionUncheckedUpdateManyWithoutLessonNestedInput
    progress?: UserLessonProgressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutMiniModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    more?: NullableStringFieldUpdateOperationsInput | string | null
    example?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type LessonVideoUpdateWithoutMiniModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type LessonVideoUncheckedUpdateWithoutMiniModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type LessonVideoUncheckedUpdateManyWithoutMiniModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type MiniModuleProgressUpdateWithoutMiniModuleInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMiniModuleProgressNestedInput
  }

  export type MiniModuleProgressUncheckedUpdateWithoutMiniModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MiniModuleProgressUncheckedUpdateManyWithoutMiniModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonSolutionCreateManyLessonInput = {
    id?: number
    solution: string
  }

  export type UserLessonProgressCreateManyLessonInput = {
    id?: number
    userId: number
    currentStep?: number
    completed?: boolean
    startedAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonSolutionUpdateWithoutLessonInput = {
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type LessonSolutionUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type LessonSolutionUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type UserLessonProgressUpdateWithoutLessonInput = {
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserLessonProgressNestedInput
  }

  export type UserLessonProgressUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLessonProgressUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    currentStep?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstructionsCreateManyChallengeInput = {
    id?: number
    number: number
    instruction: string
    completed?: boolean
  }

  export type ChallengeLikeCreateManyChallengeInput = {
    id?: number
    userId: number
  }

  export type ChallengeSolutionsCreateManyChallengeInput = {
    id?: number
    number: number
    solution: string
  }

  export type CompletedChallengesCreateManyChallengeInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type ChallengeInstructionsUpdateWithoutChallengeInput = {
    number?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeInstructionsUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeInstructionsUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeLikeUpdateWithoutChallengeInput = {
    user?: UserUpdateOneRequiredWithoutChallengeLikeNestedInput
  }

  export type ChallengeLikeUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeLikeUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeSolutionsUpdateWithoutChallengeInput = {
    number?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSolutionsUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeSolutionsUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    solution?: StringFieldUpdateOperationsInput | string
  }

  export type CompletedChallengesUpdateWithoutChallengeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompletedChallengesNestedInput
    Course?: CourseUpdateManyWithoutCompletedChallengesNestedInput
  }

  export type CompletedChallengesUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Course?: CourseUncheckedUpdateManyWithoutCompletedChallengesNestedInput
  }

  export type CompletedChallengesUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutCompletedChallengesInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedCoursesNestedInput
    modules?: CourseModuleUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUpdateManyWithoutCourseNestedInput
    videos?: VideoUpdateManyWithoutCourseNestedInput
    users?: UserUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCompletedChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: CourseModuleUncheckedUpdateManyWithoutCourseNestedInput
    progress?: UserCourseProgressUncheckedUpdateManyWithoutCourseNestedInput
    ratings?: CourseRatingUncheckedUpdateManyWithoutCourseNestedInput
    videos?: VideoUncheckedUpdateManyWithoutCourseNestedInput
    users?: UserUncheckedUpdateManyWithoutCourseNestedInput
    likedBy?: CourseLikeUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCompletedChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    creatorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    level?: EnumLevelFieldUpdateOperationsInput | $Enums.Level
    description?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    studentsCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    completions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}